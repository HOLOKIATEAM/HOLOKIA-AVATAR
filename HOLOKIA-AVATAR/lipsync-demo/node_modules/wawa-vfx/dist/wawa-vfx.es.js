import { jsx as Fe, jsxs as _a, Fragment as Ta } from "react/jsx-runtime";
import { useFrame as Ra, extend as $c } from "@react-three/fiber";
import * as Oe from "react";
import g, { useCallback as W, forwardRef as be, Children as _t, isValidElement as xn, createElement as ee, cloneElement as ro, Fragment as Ia, useEffect as Y, createContext as vt, useMemo as ge, useContext as yt, useRef as _, useState as oe, useLayoutEffect as Qe, useReducer as oo, useImperativeHandle as Nn, useDebugValue as xc } from "react";
import * as un from "three";
import { Vector3 as Rt, Quaternion as Aa, Euler as io, Matrix4 as Ec, Color as Sc, AdditiveBlending as Oc, PlaneGeometry as Pc, DynamicDrawUsage as Et } from "three";
import * as Cc from "react-dom";
import _c, { flushSync as ka } from "react-dom";
import { createRoot as Tc } from "react-dom/client";
var Da = /* @__PURE__ */ ((e) => (e[e.Square = 0] = "Square", e[e.Circular = 1] = "Circular", e))(Da || {}), Ma = /* @__PURE__ */ ((e) => (e.StretchBillboard = "stretchBillboard", e.Billboard = "billboard", e.Mesh = "mesh", e))(Ma || {});
const Rc = [
  "easeLinear",
  "easeInPower1",
  "easeOutPower1",
  "easeInOutPower1",
  "easeInPower2",
  "easeOutPower2",
  "easeInOutPower2",
  "easeInPower3",
  "easeOutPower3",
  "easeInOutPower3",
  "easeInPower4",
  "easeOutPower4",
  "easeInOutPower4",
  "easeInQuad",
  "easeOutQuad",
  "easeInOutQuad",
  "easeInCubic",
  "easeOutCubic",
  "easeInOutCubic",
  "easeInQuart",
  "easeOutQuart",
  "easeInOutQuart",
  "easeInQuint",
  "easeOutQuint",
  "easeInOutQuint",
  "easeInSine",
  "easeOutSine",
  "easeInOutSine",
  "easeInExpo",
  "easeOutExpo",
  "easeInOutExpo",
  "easeInCirc",
  "easeOutCirc",
  "easeInOutCirc",
  "easeInElastic",
  "easeOutElastic",
  "easeInOutElastic",
  "easeInBack",
  "easeOutBack",
  "easeInOutBack",
  "easeInBounce",
  "easeOutBounce",
  "easeInOutBounce"
];
function fn(e, t) {
  return e + Math.floor(Math.random() * (t - e + 1));
}
function te(e, t) {
  return e + Math.random() * (t - e);
}
function we() {
  return we = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, we.apply(null, arguments);
}
function Ic(e, t) {
  typeof e == "function" ? e(t) : e != null && (e.current = t);
}
function ja(...e) {
  return (t) => e.forEach(
    (n) => Ic(n, t)
  );
}
function At(...e) {
  return W(ja(...e), e);
}
const La = /* @__PURE__ */ be((e, t) => {
  const { children: n, ...r } = e, o = _t.toArray(n), i = o.find(Ac);
  if (i) {
    const a = i.props.children, s = o.map((c) => c === i ? _t.count(a) > 1 ? _t.only(null) : /* @__PURE__ */ xn(a) ? a.props.children : null : c);
    return /* @__PURE__ */ ee(Ar, we({}, r, {
      ref: t
    }), /* @__PURE__ */ xn(a) ? /* @__PURE__ */ ro(a, void 0, s) : null);
  }
  return /* @__PURE__ */ ee(Ar, we({}, r, {
    ref: t
  }), n);
});
La.displayName = "Slot";
const Ar = /* @__PURE__ */ be((e, t) => {
  const { children: n, ...r } = e;
  return /* @__PURE__ */ xn(n) ? /* @__PURE__ */ ro(n, {
    ...kc(r, n.props),
    ref: ja(t, n.ref)
  }) : _t.count(n) > 1 ? _t.only(null) : null;
});
Ar.displayName = "SlotClone";
const za = ({ children: e }) => /* @__PURE__ */ ee(Ia, null, e);
function Ac(e) {
  return /* @__PURE__ */ xn(e) && e.type === za;
}
function kc(e, t) {
  const n = {
    ...t
  };
  for (const r in t) {
    const o = e[r], i = t[r];
    /^on[A-Z]/.test(r) ? o && i ? n[r] = (...s) => {
      i(...s), o(...s);
    } : o && (n[r] = o) : r === "style" ? n[r] = {
      ...o,
      ...i
    } : r === "className" && (n[r] = [
      o,
      i
    ].filter(Boolean).join(" "));
  }
  return {
    ...e,
    ...n
  };
}
const Dc = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], ut = Dc.reduce((e, t) => {
  const n = /* @__PURE__ */ be((r, o) => {
    const { asChild: i, ...a } = r, s = i ? La : t;
    return Y(() => {
      window[Symbol.for("radix-ui")] = !0;
    }, []), /* @__PURE__ */ ee(s, we({}, a, {
      ref: o
    }));
  });
  return n.displayName = `Primitive.${t}`, {
    ...e,
    [t]: n
  };
}, {});
function Mc(e, t) {
  e && ka(
    () => e.dispatchEvent(t)
  );
}
const jc = /* @__PURE__ */ be((e, t) => {
  var n;
  const { container: r = globalThis == null || (n = globalThis.document) === null || n === void 0 ? void 0 : n.body, ...o } = e;
  return r ? /* @__PURE__ */ _c.createPortal(/* @__PURE__ */ ee(ut.div, we({}, o, {
    ref: t
  })), r) : null;
}), Lc = jc;
var Ro = Object.prototype.hasOwnProperty;
function Xt(e, t) {
  var n, r;
  if (e === t) return !0;
  if (e && t && (n = e.constructor) === t.constructor) {
    if (n === Date) return e.getTime() === t.getTime();
    if (n === RegExp) return e.toString() === t.toString();
    if (n === Array) {
      if ((r = e.length) === t.length)
        for (; r-- && Xt(e[r], t[r]); ) ;
      return r === -1;
    }
    if (!n || typeof e == "object") {
      r = 0;
      for (n in e)
        if (Ro.call(e, n) && ++r && !Ro.call(t, n) || !(n in t) || !Xt(e[n], t[n])) return !1;
      return Object.keys(t).length === r;
    }
  }
  return e !== e && t !== t;
}
function Fn(e, t) {
  if (Object.is(e, t))
    return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  const n = Object.keys(e);
  if (n.length !== Object.keys(t).length)
    return !1;
  for (let r = 0; r < n.length; r++)
    if (!Object.prototype.hasOwnProperty.call(t, n[r]) || !Object.is(e[n[r]], t[n[r]]))
      return !1;
  return !0;
}
var Bn = function(t, n, r, o) {
  this.name = t, this.fn = n, this.args = r, this.modifiers = o;
};
Bn.prototype._test = function(t) {
  var n = this.fn;
  try {
    Tt(this.modifiers.slice(), n, this)(t);
  } catch {
    n = function() {
      return !1;
    };
  }
  try {
    return Tt(this.modifiers.slice(), n, this)(t);
  } catch {
    return !1;
  }
};
Bn.prototype._check = function(t) {
  try {
    Tt(this.modifiers.slice(), this.fn, this)(t);
  } catch {
    if (Tt(this.modifiers.slice(), function(r) {
      return r;
    }, this)(!1))
      return;
  }
  if (!Tt(this.modifiers.slice(), this.fn, this)(t))
    throw null;
};
Bn.prototype._testAsync = function(t) {
  var n = this;
  return new Promise(function(r, o) {
    Fa(
      n.modifiers.slice(),
      n.fn,
      n
    )(t).then(function(i) {
      i ? r(t) : o(null);
    }).catch(function(i) {
      return o(i);
    });
  });
};
function Na(e, t) {
  return t === void 0 && (t = "simple"), typeof e == "object" ? e[t] : e;
}
function Tt(e, t, n) {
  if (e.length) {
    var r = e.shift(), o = Tt(e, t, n);
    return r.perform(o, n);
  } else
    return Na(t);
}
function Fa(e, t, n) {
  if (e.length) {
    var r = e.shift(), o = Fa(e, t, n);
    return r.performAsync(o, n);
  } else
    return function(i) {
      return Promise.resolve(Na(t, "async")(i));
    };
}
var zc = function(t, n, r) {
  this.name = t, this.perform = n, this.performAsync = r;
}, ao = /* @__PURE__ */ function(e) {
  function t(n, r, o, i) {
    for (var a = [], s = arguments.length - 4; s-- > 0; ) a[s] = arguments[s + 4];
    e.call(this, a), e.captureStackTrace && e.captureStackTrace(this, t), this.rule = n, this.value = r, this.cause = o, this.target = i;
  }
  return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t;
}(Error), Be = function(t, n) {
  t === void 0 && (t = []), n === void 0 && (n = []), this.chain = t, this.nextRuleModifiers = n;
};
Be.prototype._applyRule = function(t, n) {
  var r = this;
  return function() {
    for (var o = [], i = arguments.length; i--; ) o[i] = arguments[i];
    return r.chain.push(
      new Bn(n, t.apply(r, o), o, r.nextRuleModifiers)
    ), r.nextRuleModifiers = [], r;
  };
};
Be.prototype._applyModifier = function(t, n) {
  return this.nextRuleModifiers.push(
    new zc(n, t.simple, t.async)
  ), this;
};
Be.prototype._clone = function() {
  return new Be(this.chain.slice(), this.nextRuleModifiers.slice());
};
Be.prototype.test = function(t) {
  return this.chain.every(function(n) {
    return n._test(t);
  });
};
Be.prototype.testAll = function(t) {
  var n = [];
  return this.chain.forEach(function(r) {
    try {
      r._check(t);
    } catch (o) {
      n.push(new ao(r, t, o));
    }
  }), n;
};
Be.prototype.check = function(t) {
  this.chain.forEach(function(n) {
    try {
      n._check(t);
    } catch (r) {
      throw new ao(n, t, r);
    }
  });
};
Be.prototype.testAsync = function(t) {
  var n = this;
  return new Promise(function(r, o) {
    Ba(t, n.chain.slice(), r, o);
  });
};
function Ba(e, t, n, r) {
  if (t.length) {
    var o = t.shift();
    o._testAsync(e).then(
      function() {
        Ba(e, t, n, r);
      },
      function(i) {
        r(new ao(o, e, i));
      }
    );
  } else
    n(e);
}
var Io = function(e, t) {
  return t && typeof e == "string" && e.trim().length === 0 ? !0 : e == null;
};
function Nc(e, t) {
  return t === void 0 && (t = !1), {
    simple: function(n) {
      return Io(n, t) || e.check(n) === void 0;
    },
    async: function(n) {
      return Io(n, t) || e.testAsync(n);
    }
  };
}
function Re() {
  return typeof Proxy < "u" ? Wa(new Be()) : kr(new Be());
}
var Qt = {};
Re.extend = function(e) {
  Object.assign(Qt, e);
};
Re.clearCustomRules = function() {
  Qt = {};
};
function Wa(e) {
  return new Proxy(e, {
    get: function(n, r) {
      if (r in n)
        return n[r];
      var o = Wa(e._clone());
      if (r in En)
        return o._applyModifier(En[r], r);
      if (r in Qt)
        return o._applyRule(Qt[r], r);
      if (r in Dr)
        return o._applyRule(Dr[r], r);
    }
  });
}
function kr(e) {
  var t = function(o, i) {
    return Object.keys(o).forEach(function(a) {
      i[a] = function() {
        for (var s = [], c = arguments.length; c--; ) s[c] = arguments[c];
        var l = kr(i._clone()), u = l._applyRule(
          o[a],
          a
        ).apply(void 0, s);
        return u;
      };
    }), i;
  }, n = t(Dr, e), r = t(
    Qt,
    n
  );
  return Object.keys(En).forEach(function(o) {
    Object.defineProperty(r, o, {
      get: function() {
        var i = kr(r._clone());
        return i._applyModifier(En[o], o);
      }
    });
  }), r;
}
var En = {
  not: {
    simple: function(e) {
      return function(t) {
        return !e(t);
      };
    },
    async: function(e) {
      return function(t) {
        return Promise.resolve(e(t)).then(function(n) {
          return !n;
        }).catch(function() {
          return !0;
        });
      };
    }
  },
  some: {
    simple: function(e) {
      return function(t) {
        return dn(t).some(function(n) {
          try {
            return e(n);
          } catch {
            return !1;
          }
        });
      };
    },
    async: function(e) {
      return function(t) {
        return Promise.all(
          dn(t).map(function(n) {
            try {
              return e(n).catch(function() {
                return !1;
              });
            } catch {
              return !1;
            }
          })
        ).then(function(n) {
          return n.some(Boolean);
        });
      };
    }
  },
  every: {
    simple: function(e) {
      return function(t) {
        return t !== !1 && dn(t).every(e);
      };
    },
    async: function(e) {
      return function(t) {
        return Promise.all(dn(t).map(e)).then(function(n) {
          return n.every(Boolean);
        });
      };
    }
  },
  strict: {
    simple: function(e, t) {
      return function(n) {
        return Ao(t) && n && typeof n == "object" ? Object.keys(t.args[0]).length === Object.keys(n).length && e(n) : e(n);
      };
    },
    async: function(e, t) {
      return function(n) {
        return Promise.resolve(e(n)).then(function(r) {
          return Ao(t) && n && typeof n == "object" ? Object.keys(t.args[0]).length === Object.keys(n).length && r : r;
        }).catch(function() {
          return !1;
        });
      };
    }
  }
};
function Ao(e) {
  return e && e.name === "schema" && e.args.length > 0 && typeof e.args[0] == "object";
}
function dn(e) {
  return typeof e == "string" ? e.split("") : e;
}
var Dr = {
  // Value
  equal: function(e) {
    return function(t) {
      return t == e;
    };
  },
  exact: function(e) {
    return function(t) {
      return t === e;
    };
  },
  // Types
  number: function(e) {
    return e === void 0 && (e = !0), function(t) {
      return typeof t == "number" && (e || isFinite(t));
    };
  },
  integer: function() {
    return function(e) {
      var t = Number.isInteger || Fc;
      return t(e);
    };
  },
  numeric: function() {
    return function(e) {
      return !isNaN(parseFloat(e)) && isFinite(e);
    };
  },
  string: function() {
    return St("string");
  },
  boolean: function() {
    return St("boolean");
  },
  undefined: function() {
    return St("undefined");
  },
  null: function() {
    return St("null");
  },
  array: function() {
    return St("array");
  },
  object: function() {
    return St("object");
  },
  instanceOf: function(e) {
    return function(t) {
      return t instanceof e;
    };
  },
  // Pattern
  pattern: function(e) {
    return function(t) {
      return e.test(t);
    };
  },
  lowercase: function() {
    return function(e) {
      return typeof e == "boolean" || e === e.toLowerCase() && e.trim() !== "";
    };
  },
  uppercase: function() {
    return function(e) {
      return e === e.toUpperCase() && e.trim() !== "";
    };
  },
  vowel: function() {
    return function(e) {
      return /^[aeiou]+$/i.test(e);
    };
  },
  consonant: function() {
    return function(e) {
      return /^(?=[^aeiou])([a-z]+)$/i.test(e);
    };
  },
  // Value at
  first: function(e) {
    return function(t) {
      return t[0] == e;
    };
  },
  last: function(e) {
    return function(t) {
      return t[t.length - 1] == e;
    };
  },
  // Length
  empty: function() {
    return function(e) {
      return e.length === 0;
    };
  },
  length: function(e, t) {
    return function(n) {
      return n.length >= e && n.length <= (t || e);
    };
  },
  minLength: function(e) {
    return function(t) {
      return t.length >= e;
    };
  },
  maxLength: function(e) {
    return function(t) {
      return t.length <= e;
    };
  },
  // Range
  negative: function() {
    return function(e) {
      return e < 0;
    };
  },
  positive: function() {
    return function(e) {
      return e >= 0;
    };
  },
  between: function(e, t) {
    return function(n) {
      return n >= e && n <= t;
    };
  },
  range: function(e, t) {
    return function(n) {
      return n >= e && n <= t;
    };
  },
  lessThan: function(e) {
    return function(t) {
      return t < e;
    };
  },
  lessThanOrEqual: function(e) {
    return function(t) {
      return t <= e;
    };
  },
  greaterThan: function(e) {
    return function(t) {
      return t > e;
    };
  },
  greaterThanOrEqual: function(e) {
    return function(t) {
      return t >= e;
    };
  },
  // Divisible
  even: function() {
    return function(e) {
      return e % 2 === 0;
    };
  },
  odd: function() {
    return function(e) {
      return e % 2 !== 0;
    };
  },
  includes: function(e) {
    return function(t) {
      return ~t.indexOf(e);
    };
  },
  schema: function(e) {
    return Bc(e);
  },
  // branching
  passesAnyOf: function() {
    for (var e = [], t = arguments.length; t--; ) e[t] = arguments[t];
    return function(n) {
      return e.some(function(r) {
        return r.test(n);
      });
    };
  },
  optional: Nc
};
function St(e) {
  return function(t) {
    return Array.isArray(t) && e === "array" || t === null && e === "null" || typeof t === e;
  };
}
function Fc(e) {
  return typeof e == "number" && isFinite(e) && Math.floor(e) === e;
}
function Bc(e) {
  return {
    simple: function(t) {
      var n = [];
      if (Object.keys(e).forEach(function(r) {
        var o = e[r];
        try {
          o.check((t || {})[r]);
        } catch (i) {
          i.target = r, n.push(i);
        }
      }), n.length > 0)
        throw n;
      return !0;
    },
    async: function(t) {
      var n = [], r = Object.keys(e).map(function(o) {
        var i = e[o];
        return i.testAsync((t || {})[o]).catch(function(a) {
          a.target = o, n.push(a);
        });
      });
      return Promise.all(r).then(function() {
        if (n.length > 0)
          throw n;
        return !0;
      });
    }
  };
}
var ae = "colors", Se = "sizes", D = "space", Wc = { gap: D, gridGap: D, columnGap: D, gridColumnGap: D, rowGap: D, gridRowGap: D, inset: D, insetBlock: D, insetBlockEnd: D, insetBlockStart: D, insetInline: D, insetInlineEnd: D, insetInlineStart: D, margin: D, marginTop: D, marginRight: D, marginBottom: D, marginLeft: D, marginBlock: D, marginBlockEnd: D, marginBlockStart: D, marginInline: D, marginInlineEnd: D, marginInlineStart: D, padding: D, paddingTop: D, paddingRight: D, paddingBottom: D, paddingLeft: D, paddingBlock: D, paddingBlockEnd: D, paddingBlockStart: D, paddingInline: D, paddingInlineEnd: D, paddingInlineStart: D, top: D, right: D, bottom: D, left: D, scrollMargin: D, scrollMarginTop: D, scrollMarginRight: D, scrollMarginBottom: D, scrollMarginLeft: D, scrollMarginX: D, scrollMarginY: D, scrollMarginBlock: D, scrollMarginBlockEnd: D, scrollMarginBlockStart: D, scrollMarginInline: D, scrollMarginInlineEnd: D, scrollMarginInlineStart: D, scrollPadding: D, scrollPaddingTop: D, scrollPaddingRight: D, scrollPaddingBottom: D, scrollPaddingLeft: D, scrollPaddingX: D, scrollPaddingY: D, scrollPaddingBlock: D, scrollPaddingBlockEnd: D, scrollPaddingBlockStart: D, scrollPaddingInline: D, scrollPaddingInlineEnd: D, scrollPaddingInlineStart: D, fontSize: "fontSizes", background: ae, backgroundColor: ae, backgroundImage: ae, borderImage: ae, border: ae, borderBlock: ae, borderBlockEnd: ae, borderBlockStart: ae, borderBottom: ae, borderBottomColor: ae, borderColor: ae, borderInline: ae, borderInlineEnd: ae, borderInlineStart: ae, borderLeft: ae, borderLeftColor: ae, borderRight: ae, borderRightColor: ae, borderTop: ae, borderTopColor: ae, caretColor: ae, color: ae, columnRuleColor: ae, fill: ae, outline: ae, outlineColor: ae, stroke: ae, textDecorationColor: ae, fontFamily: "fonts", fontWeight: "fontWeights", lineHeight: "lineHeights", letterSpacing: "letterSpacings", blockSize: Se, minBlockSize: Se, maxBlockSize: Se, inlineSize: Se, minInlineSize: Se, maxInlineSize: Se, width: Se, minWidth: Se, maxWidth: Se, height: Se, minHeight: Se, maxHeight: Se, flexBasis: Se, gridTemplateColumns: Se, gridTemplateRows: Se, borderWidth: "borderWidths", borderTopWidth: "borderWidths", borderRightWidth: "borderWidths", borderBottomWidth: "borderWidths", borderLeftWidth: "borderWidths", borderStyle: "borderStyles", borderTopStyle: "borderStyles", borderRightStyle: "borderStyles", borderBottomStyle: "borderStyles", borderLeftStyle: "borderStyles", borderRadius: "radii", borderTopLeftRadius: "radii", borderTopRightRadius: "radii", borderBottomRightRadius: "radii", borderBottomLeftRadius: "radii", boxShadow: "shadows", textShadow: "shadows", transition: "transitions", zIndex: "zIndices" }, Uc = (e, t) => typeof t == "function" ? { "()": Function.prototype.toString.call(t) } : t, kt = () => {
  const e = /* @__PURE__ */ Object.create(null);
  return (t, n, ...r) => {
    const o = ((i) => JSON.stringify(i, Uc))(t);
    return o in e ? e[o] : e[o] = n(t, ...r);
  };
}, gt = Symbol.for("sxs.internal"), so = (e, t) => Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)), ko = (e) => {
  for (const t in e) return !0;
  return !1;
}, { hasOwnProperty: Vc } = Object.prototype, Mr = (e) => e.includes("-") ? e : e.replace(/[A-Z]/g, (t) => "-" + t.toLowerCase()), Hc = /\s+(?![^()]*\))/, Ot = (e) => (t) => e(...typeof t == "string" ? String(t).split(Hc) : [t]), Do = { appearance: (e) => ({ WebkitAppearance: e, appearance: e }), backfaceVisibility: (e) => ({ WebkitBackfaceVisibility: e, backfaceVisibility: e }), backdropFilter: (e) => ({ WebkitBackdropFilter: e, backdropFilter: e }), backgroundClip: (e) => ({ WebkitBackgroundClip: e, backgroundClip: e }), boxDecorationBreak: (e) => ({ WebkitBoxDecorationBreak: e, boxDecorationBreak: e }), clipPath: (e) => ({ WebkitClipPath: e, clipPath: e }), content: (e) => ({ content: e.includes('"') || e.includes("'") || /^([A-Za-z]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)$/.test(e) ? e : `"${e}"` }), hyphens: (e) => ({ WebkitHyphens: e, hyphens: e }), maskImage: (e) => ({ WebkitMaskImage: e, maskImage: e }), maskSize: (e) => ({ WebkitMaskSize: e, maskSize: e }), tabSize: (e) => ({ MozTabSize: e, tabSize: e }), textSizeAdjust: (e) => ({ WebkitTextSizeAdjust: e, textSizeAdjust: e }), userSelect: (e) => ({ WebkitUserSelect: e, userSelect: e }), marginBlock: Ot((e, t) => ({ marginBlockStart: e, marginBlockEnd: t || e })), marginInline: Ot((e, t) => ({ marginInlineStart: e, marginInlineEnd: t || e })), maxSize: Ot((e, t) => ({ maxBlockSize: e, maxInlineSize: t || e })), minSize: Ot((e, t) => ({ minBlockSize: e, minInlineSize: t || e })), paddingBlock: Ot((e, t) => ({ paddingBlockStart: e, paddingBlockEnd: t || e })), paddingInline: Ot((e, t) => ({ paddingInlineStart: e, paddingInlineEnd: t || e })) }, rr = /([\d.]+)([^]*)/, Yc = (e, t) => e.length ? e.reduce((n, r) => (n.push(...t.map((o) => o.includes("&") ? o.replace(/&/g, /[ +>|~]/.test(r) && /&.*&/.test(o) ? `:is(${r})` : r) : r + " " + o)), n), []) : t, qc = (e, t) => e in Kc && typeof t == "string" ? t.replace(/^((?:[^]*[^\w-])?)(fit-content|stretch)((?:[^\w-][^]*)?)$/, (n, r, o, i) => r + (o === "stretch" ? `-moz-available${i};${Mr(e)}:${r}-webkit-fill-available` : `-moz-fit-content${i};${Mr(e)}:${r}fit-content`) + i) : String(t), Kc = { blockSize: 1, height: 1, inlineSize: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, width: 1 }, Xe = (e) => e ? e + "-" : "", Ua = (e, t, n) => e.replace(/([+-])?((?:\d+(?:\.\d*)?|\.\d+)(?:[Ee][+-]?\d+)?)?(\$|--)([$\w-]+)/g, (r, o, i, a, s) => a == "$" == !!i ? r : (o || a == "--" ? "calc(" : "") + "var(--" + (a === "$" ? Xe(t) + (s.includes("$") ? "" : Xe(n)) + s.replace(/\$/g, "-") : s) + ")" + (o || a == "--" ? "*" + (o || "") + (i || "1") + ")" : "")), Gc = /\s*,\s*(?![^()]*\))/, Xc = Object.prototype.toString, Ct = (e, t, n, r, o) => {
  let i, a, s;
  const c = (l, u, f) => {
    let d, p;
    const m = (h) => {
      for (d in h) {
        const y = d.charCodeAt(0) === 64, w = y && Array.isArray(h[d]) ? h[d] : [h[d]];
        for (p of w) {
          const x = /[A-Z]/.test(b = d) ? b : b.replace(/-[^]/g, (E) => E[1].toUpperCase()), $ = typeof p == "object" && p && p.toString === Xc && (!r.utils[x] || !u.length);
          if (x in r.utils && !$) {
            const E = r.utils[x];
            if (E !== a) {
              a = E, m(E(p)), a = null;
              continue;
            }
          } else if (x in Do) {
            const E = Do[x];
            if (E !== s) {
              s = E, m(E(p)), s = null;
              continue;
            }
          }
          if (y && (v = d.slice(1) in r.media ? "@media " + r.media[d.slice(1)] : d, d = v.replace(/\(\s*([\w-]+)\s*(=|<|<=|>|>=)\s*([\w-]+)\s*(?:(<|<=|>|>=)\s*([\w-]+)\s*)?\)/g, (E, O, C, B, R, T) => {
            const A = rr.test(O), M = 0.0625 * (A ? -1 : 1), [Z, G] = A ? [B, O] : [O, B];
            return "(" + (C[0] === "=" ? "" : C[0] === ">" === A ? "max-" : "min-") + Z + ":" + (C[0] !== "=" && C.length === 1 ? G.replace(rr, (J, ie, ce) => Number(ie) + M * (C === ">" ? 1 : -1) + ce) : G) + (R ? ") and (" + (R[0] === ">" ? "min-" : "max-") + Z + ":" + (R.length === 1 ? T.replace(rr, (J, ie, ce) => Number(ie) + M * (R === ">" ? -1 : 1) + ce) : T) : "") + ")";
          })), $) {
            const E = y ? f.concat(d) : [...f], O = y ? [...u] : Yc(u, d.split(Gc));
            i !== void 0 && o(Mo(...i)), i = void 0, c(p, O, E);
          } else i === void 0 && (i = [[], u, f]), d = y || d.charCodeAt(0) !== 36 ? d : `--${Xe(r.prefix)}${d.slice(1).replace(/\$/g, "-")}`, p = $ ? p : typeof p == "number" ? p && x in Qc ? String(p) + "px" : String(p) : Ua(qc(x, p ?? ""), r.prefix, r.themeMap[x]), i[0].push(`${y ? `${d} ` : `${Mr(d)}:`}${p}`);
        }
      }
      var v, b;
    };
    m(l), i !== void 0 && o(Mo(...i)), i = void 0;
  };
  c(e, t, n);
}, Mo = (e, t, n) => `${n.map((r) => `${r}{`).join("")}${t.length ? `${t.join(",")}{` : ""}${e.join(";")}${t.length ? "}" : ""}${Array(n.length ? n.length + 1 : 0).join("}")}`, Qc = { animationDelay: 1, animationDuration: 1, backgroundSize: 1, blockSize: 1, border: 1, borderBlock: 1, borderBlockEnd: 1, borderBlockEndWidth: 1, borderBlockStart: 1, borderBlockStartWidth: 1, borderBlockWidth: 1, borderBottom: 1, borderBottomLeftRadius: 1, borderBottomRightRadius: 1, borderBottomWidth: 1, borderEndEndRadius: 1, borderEndStartRadius: 1, borderInlineEnd: 1, borderInlineEndWidth: 1, borderInlineStart: 1, borderInlineStartWidth: 1, borderInlineWidth: 1, borderLeft: 1, borderLeftWidth: 1, borderRadius: 1, borderRight: 1, borderRightWidth: 1, borderSpacing: 1, borderStartEndRadius: 1, borderStartStartRadius: 1, borderTop: 1, borderTopLeftRadius: 1, borderTopRightRadius: 1, borderTopWidth: 1, borderWidth: 1, bottom: 1, columnGap: 1, columnRule: 1, columnRuleWidth: 1, columnWidth: 1, containIntrinsicSize: 1, flexBasis: 1, fontSize: 1, gap: 1, gridAutoColumns: 1, gridAutoRows: 1, gridTemplateColumns: 1, gridTemplateRows: 1, height: 1, inlineSize: 1, inset: 1, insetBlock: 1, insetBlockEnd: 1, insetBlockStart: 1, insetInline: 1, insetInlineEnd: 1, insetInlineStart: 1, left: 1, letterSpacing: 1, margin: 1, marginBlock: 1, marginBlockEnd: 1, marginBlockStart: 1, marginBottom: 1, marginInline: 1, marginInlineEnd: 1, marginInlineStart: 1, marginLeft: 1, marginRight: 1, marginTop: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, offsetDistance: 1, offsetRotate: 1, outline: 1, outlineOffset: 1, outlineWidth: 1, overflowClipMargin: 1, padding: 1, paddingBlock: 1, paddingBlockEnd: 1, paddingBlockStart: 1, paddingBottom: 1, paddingInline: 1, paddingInlineEnd: 1, paddingInlineStart: 1, paddingLeft: 1, paddingRight: 1, paddingTop: 1, perspective: 1, right: 1, rowGap: 1, scrollMargin: 1, scrollMarginBlock: 1, scrollMarginBlockEnd: 1, scrollMarginBlockStart: 1, scrollMarginBottom: 1, scrollMarginInline: 1, scrollMarginInlineEnd: 1, scrollMarginInlineStart: 1, scrollMarginLeft: 1, scrollMarginRight: 1, scrollMarginTop: 1, scrollPadding: 1, scrollPaddingBlock: 1, scrollPaddingBlockEnd: 1, scrollPaddingBlockStart: 1, scrollPaddingBottom: 1, scrollPaddingInline: 1, scrollPaddingInlineEnd: 1, scrollPaddingInlineStart: 1, scrollPaddingLeft: 1, scrollPaddingRight: 1, scrollPaddingTop: 1, shapeMargin: 1, textDecoration: 1, textDecorationThickness: 1, textIndent: 1, textUnderlineOffset: 1, top: 1, transitionDelay: 1, transitionDuration: 1, verticalAlign: 1, width: 1, wordSpacing: 1 }, jo = (e) => String.fromCharCode(e + (e > 25 ? 39 : 97)), mt = (e) => ((t) => {
  let n, r = "";
  for (n = Math.abs(t); n > 52; n = n / 52 | 0) r = jo(n % 52) + r;
  return jo(n % 52) + r;
})(((t, n) => {
  let r = n.length;
  for (; r; ) t = 33 * t ^ n.charCodeAt(--r);
  return t;
})(5381, JSON.stringify(e)) >>> 0), Vt = ["themed", "global", "styled", "onevar", "resonevar", "allvar", "inline"], Zc = (e) => {
  if (e.href && !e.href.startsWith(location.origin)) return !1;
  try {
    return !!e.cssRules;
  } catch {
    return !1;
  }
}, Jc = (e) => {
  let t;
  const n = () => {
    const { cssRules: o } = t.sheet;
    return [].map.call(o, (i, a) => {
      const { cssText: s } = i;
      let c = "";
      if (s.startsWith("--sxs")) return "";
      if (o[a - 1] && (c = o[a - 1].cssText).startsWith("--sxs")) {
        if (!i.cssRules.length) return "";
        for (const l in t.rules) if (t.rules[l].group === i) return `--sxs{--sxs:${[...t.rules[l].cache].join(" ")}}${s}`;
        return i.cssRules.length ? `${c}${s}` : "";
      }
      return s;
    }).join("");
  }, r = () => {
    if (t) {
      const { rules: s, sheet: c } = t;
      if (!c.deleteRule) {
        for (; Object(Object(c.cssRules)[0]).type === 3; ) c.cssRules.splice(0, 1);
        c.cssRules = [];
      }
      for (const l in s) delete s[l];
    }
    const o = Object(e).styleSheets || [];
    for (const s of o) if (Zc(s)) {
      for (let c = 0, l = s.cssRules; l[c]; ++c) {
        const u = Object(l[c]);
        if (u.type !== 1) continue;
        const f = Object(l[c + 1]);
        if (f.type !== 4) continue;
        ++c;
        const { cssText: d } = u;
        if (!d.startsWith("--sxs")) continue;
        const p = d.slice(14, -3).trim().split(/\s+/), m = Vt[p[0]];
        m && (t || (t = { sheet: s, reset: r, rules: {}, toString: n }), t.rules[m] = { group: f, index: c, cache: new Set(p) });
      }
      if (t) break;
    }
    if (!t) {
      const s = (c, l) => ({ type: l, cssRules: [], insertRule(u, f) {
        this.cssRules.splice(f, 0, s(u, { import: 3, undefined: 1 }[(u.toLowerCase().match(/^@([a-z]+)/) || [])[1]] || 4));
      }, get cssText() {
        return c === "@media{}" ? `@media{${[].map.call(this.cssRules, (u) => u.cssText).join("")}}` : c;
      } });
      t = { sheet: e ? (e.head || e).appendChild(document.createElement("style")).sheet : s("", "text/css"), rules: {}, reset: r, toString: n };
    }
    const { sheet: i, rules: a } = t;
    for (let s = Vt.length - 1; s >= 0; --s) {
      const c = Vt[s];
      if (!a[c]) {
        const l = Vt[s + 1], u = a[l] ? a[l].index : i.cssRules.length;
        i.insertRule("@media{}", u), i.insertRule(`--sxs{--sxs:${s}}`, u), a[c] = { group: i.cssRules[u + 1], index: u, cache: /* @__PURE__ */ new Set([s]) };
      }
      el(a[c]);
    }
  };
  return r(), t;
}, el = (e) => {
  const t = e.group;
  let n = t.cssRules.length;
  e.apply = (r) => {
    try {
      t.insertRule(r, n), ++n;
    } catch {
    }
  };
}, Bt = Symbol(), tl = kt(), Lo = (e, t) => tl(e, () => (...n) => {
  let r = { type: null, composers: /* @__PURE__ */ new Set() };
  for (const o of n) if (o != null) if (o[gt]) {
    r.type == null && (r.type = o[gt].type);
    for (const i of o[gt].composers) r.composers.add(i);
  } else o.constructor !== Object || o.$$typeof ? r.type == null && (r.type = o) : r.composers.add(nl(o, e));
  return r.type == null && (r.type = "span"), r.composers.size || r.composers.add(["PJLV", {}, [], [], {}, []]), rl(e, r, t);
}), nl = ({ variants: e, compoundVariants: t, defaultVariants: n, ...r }, o) => {
  const i = `${Xe(o.prefix)}c-${mt(r)}`, a = [], s = [], c = /* @__PURE__ */ Object.create(null), l = [];
  for (const d in n) c[d] = String(n[d]);
  if (typeof e == "object" && e) for (const d in e) {
    u = c, f = d, Vc.call(u, f) || (c[d] = "undefined");
    const p = e[d];
    for (const m in p) {
      const h = { [d]: String(m) };
      String(m) === "undefined" && l.push(d);
      const v = p[m], b = [h, v, !ko(v)];
      a.push(b);
    }
  }
  var u, f;
  if (typeof t == "object" && t) for (const d of t) {
    let { css: p, ...m } = d;
    p = typeof p == "object" && p || {};
    for (const v in m) m[v] = String(m[v]);
    const h = [m, p, !ko(p)];
    s.push(h);
  }
  return [i, r, a, s, c, l];
}, rl = (e, t, n) => {
  const [r, o, i, a] = ol(t.composers), s = typeof t.type == "function" || t.type.$$typeof ? ((f) => {
    function d() {
      for (let p = 0; p < d[Bt].length; p++) {
        const [m, h] = d[Bt][p];
        f.rules[m].apply(h);
      }
      return d[Bt] = [], null;
    }
    return d[Bt] = [], d.rules = {}, Vt.forEach((p) => d.rules[p] = { apply: (m) => d[Bt].push([p, m]) }), d;
  })(n) : null, c = (s || n).rules, l = `.${r}${o.length > 1 ? `:where(.${o.slice(1).join(".")})` : ""}`, u = (f) => {
    f = typeof f == "object" && f || il;
    const { css: d, ...p } = f, m = {};
    for (const b in i) if (delete p[b], b in f) {
      let y = f[b];
      typeof y == "object" && y ? m[b] = { "@initial": i[b], ...y } : (y = String(y), m[b] = y !== "undefined" || a.has(b) ? y : i[b]);
    } else m[b] = i[b];
    const h = /* @__PURE__ */ new Set([...o]);
    for (const [b, y, w, x] of t.composers) {
      n.rules.styled.cache.has(b) || (n.rules.styled.cache.add(b), Ct(y, [`.${b}`], [], e, (O) => {
        c.styled.apply(O);
      }));
      const $ = zo(w, m, e.media), E = zo(x, m, e.media, !0);
      for (const O of $) if (O !== void 0) for (const [C, B, R] of O) {
        const T = `${b}-${mt(B)}-${C}`;
        h.add(T);
        const A = (R ? n.rules.resonevar : n.rules.onevar).cache, M = R ? c.resonevar : c.onevar;
        A.has(T) || (A.add(T), Ct(B, [`.${T}`], [], e, (Z) => {
          M.apply(Z);
        }));
      }
      for (const O of E) if (O !== void 0) for (const [C, B] of O) {
        const R = `${b}-${mt(B)}-${C}`;
        h.add(R), n.rules.allvar.cache.has(R) || (n.rules.allvar.cache.add(R), Ct(B, [`.${R}`], [], e, (T) => {
          c.allvar.apply(T);
        }));
      }
    }
    if (typeof d == "object" && d) {
      const b = `${r}-i${mt(d)}-css`;
      h.add(b), n.rules.inline.cache.has(b) || (n.rules.inline.cache.add(b), Ct(d, [`.${b}`], [], e, (y) => {
        c.inline.apply(y);
      }));
    }
    for (const b of String(f.className || "").trim().split(/\s+/)) b && h.add(b);
    const v = p.className = [...h].join(" ");
    return { type: t.type, className: v, selector: l, props: p, toString: () => v, deferredInjector: s };
  };
  return so(u, { className: r, selector: l, [gt]: t, toString: () => (n.rules.styled.cache.has(r) || u(), r) });
}, ol = (e) => {
  let t = "";
  const n = [], r = {}, o = [];
  for (const [i, , , , a, s] of e) {
    t === "" && (t = i), n.push(i), o.push(...s);
    for (const c in a) {
      const l = a[c];
      (r[c] === void 0 || l !== "undefined" || s.includes(l)) && (r[c] = l);
    }
  }
  return [t, n, r, new Set(o)];
}, zo = (e, t, n, r) => {
  const o = [];
  e: for (let [i, a, s] of e) {
    if (s) continue;
    let c, l = 0, u = !1;
    for (c in i) {
      const f = i[c];
      let d = t[c];
      if (d !== f) {
        if (typeof d != "object" || !d) continue e;
        {
          let p, m, h = 0;
          for (const v in d) {
            if (f === String(d[v])) {
              if (v !== "@initial") {
                const b = v.slice(1);
                (m = m || []).push(b in n ? n[b] : v.replace(/^@media ?/, "")), u = !0;
              }
              l += h, p = !0;
            }
            ++h;
          }
          if (m && m.length && (a = { ["@media " + m.join(", ")]: a }), !p) continue e;
        }
      }
    }
    (o[l] = o[l] || []).push([r ? "cv" : `${c}-${i[c]}`, a, u]);
  }
  return o;
}, il = {}, al = kt(), sl = (e, t) => al(e, () => (...n) => {
  const r = () => {
    for (let o of n) {
      o = typeof o == "object" && o || {};
      let i = mt(o);
      if (!t.rules.global.cache.has(i)) {
        if (t.rules.global.cache.add(i), "@import" in o) {
          let a = [].indexOf.call(t.sheet.cssRules, t.rules.themed.group) - 1;
          for (let s of [].concat(o["@import"])) s = s.includes('"') || s.includes("'") ? s : `"${s}"`, t.sheet.insertRule(`@import ${s};`, a++);
          delete o["@import"];
        }
        Ct(o, [], [], e, (a) => {
          t.rules.global.apply(a);
        });
      }
    }
    return "";
  };
  return so(r, { toString: r });
}), cl = kt(), ll = (e, t) => cl(e, () => (n) => {
  const r = `${Xe(e.prefix)}k-${mt(n)}`, o = () => {
    if (!t.rules.global.cache.has(r)) {
      t.rules.global.cache.add(r);
      const i = [];
      Ct(n, [], [], e, (s) => i.push(s));
      const a = `@keyframes ${r}{${i.join("")}}`;
      t.rules.global.apply(a);
    }
    return r;
  };
  return so(o, { get name() {
    return o();
  }, toString: o });
}), ul = class {
  constructor(e, t, n, r) {
    this.token = e == null ? "" : String(e), this.value = t == null ? "" : String(t), this.scale = n == null ? "" : String(n), this.prefix = r == null ? "" : String(r);
  }
  get computedValue() {
    return "var(" + this.variable + ")";
  }
  get variable() {
    return "--" + Xe(this.prefix) + Xe(this.scale) + this.token;
  }
  toString() {
    return this.computedValue;
  }
}, fl = kt(), dl = (e, t) => fl(e, () => (n, r) => {
  r = typeof n == "object" && n || Object(r);
  const o = `.${n = (n = typeof n == "string" ? n : "") || `${Xe(e.prefix)}t-${mt(r)}`}`, i = {}, a = [];
  for (const c in r) {
    i[c] = {};
    for (const l in r[c]) {
      const u = `--${Xe(e.prefix)}${c}-${l}`, f = Ua(String(r[c][l]), e.prefix, c);
      i[c][l] = new ul(l, f, c, e.prefix), a.push(`${u}:${f}`);
    }
  }
  const s = () => {
    if (a.length && !t.rules.themed.cache.has(n)) {
      t.rules.themed.cache.add(n);
      const c = `${r === e.theme ? ":root," : ""}.${n}{${a.join(";")}}`;
      t.rules.themed.apply(c);
    }
    return n;
  };
  return { ...i, get className() {
    return s();
  }, selector: o, toString: s };
}), pl = kt(), hl = kt(), gl = (e) => {
  const t = ((n) => {
    let r = !1;
    const o = pl(n, (i) => {
      r = !0;
      const a = "prefix" in (i = typeof i == "object" && i || {}) ? String(i.prefix) : "", s = typeof i.media == "object" && i.media || {}, c = typeof i.root == "object" ? i.root || null : globalThis.document || null, l = typeof i.theme == "object" && i.theme || {}, u = { prefix: a, media: s, theme: l, themeMap: typeof i.themeMap == "object" && i.themeMap || { ...Wc }, utils: typeof i.utils == "object" && i.utils || {} }, f = Jc(c), d = { css: Lo(u, f), globalCss: sl(u, f), keyframes: ll(u, f), createTheme: dl(u, f), reset() {
        f.reset(), d.theme.toString();
      }, theme: {}, sheet: f, config: u, prefix: a, getCssText: f.toString, toString: f.toString };
      return String(d.theme = d.createTheme(l)), d;
    });
    return r || o.reset(), o;
  })(e);
  return t.styled = (({ config: n, sheet: r }) => hl(n, () => {
    const o = Lo(n, r);
    return (...i) => {
      const a = o(...i), s = a[gt].type, c = g.forwardRef((l, u) => {
        const f = l && l.as || s, { props: d, deferredInjector: p } = a(l);
        return delete d.as, d.ref = u, p ? g.createElement(g.Fragment, null, g.createElement(f, d), g.createElement(p, null)) : g.createElement(f, d);
      });
      return c.className = a.className, c.displayName = `Styled.${s.displayName || s.name || s}`, c.selector = a.selector, c.toString = () => a.selector, c[gt] = a[gt], c;
    };
  }))(t), t;
};
function ml(e, t, n) {
  return Math.max(t, Math.min(e, n));
}
const xe = {
  toVector(e, t) {
    return e === void 0 && (e = t), Array.isArray(e) ? e : [e, e];
  },
  add(e, t) {
    return [e[0] + t[0], e[1] + t[1]];
  },
  sub(e, t) {
    return [e[0] - t[0], e[1] - t[1]];
  },
  addTo(e, t) {
    e[0] += t[0], e[1] += t[1];
  },
  subTo(e, t) {
    e[0] -= t[0], e[1] -= t[1];
  }
};
function No(e, t, n) {
  return t === 0 || Math.abs(t) === 1 / 0 ? Math.pow(e, n * 5) : e * t * n / (t + n * e);
}
function Fo(e, t, n, r = 0.15) {
  return r === 0 ? ml(e, t, n) : e < t ? -No(t - e, n - t, r) + t : e > n ? +No(e - n, n - t, r) + n : e;
}
function vl(e, [t, n], [r, o]) {
  const [[i, a], [s, c]] = e;
  return [Fo(t, i, a, r), Fo(n, s, c, o)];
}
function bl(e, t) {
  if (typeof e != "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function yl(e) {
  var t = bl(e, "string");
  return typeof t == "symbol" ? t : String(t);
}
function Te(e, t, n) {
  return t = yl(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Bo(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function de(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Bo(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Bo(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
const Va = {
  pointer: {
    start: "down",
    change: "move",
    end: "up"
  },
  mouse: {
    start: "down",
    change: "move",
    end: "up"
  },
  touch: {
    start: "start",
    change: "move",
    end: "end"
  },
  gesture: {
    start: "start",
    change: "change",
    end: "end"
  }
};
function Wo(e) {
  return e ? e[0].toUpperCase() + e.slice(1) : "";
}
const wl = ["enter", "leave"];
function $l(e = !1, t) {
  return e && !wl.includes(t);
}
function xl(e, t = "", n = !1) {
  const r = Va[e], o = r && r[t] || t;
  return "on" + Wo(e) + Wo(o) + ($l(n, o) ? "Capture" : "");
}
const El = ["gotpointercapture", "lostpointercapture"];
function Sl(e) {
  let t = e.substring(2).toLowerCase();
  const n = !!~t.indexOf("passive");
  n && (t = t.replace("passive", ""));
  const r = El.includes(t) ? "capturecapture" : "capture", o = !!~t.indexOf(r);
  return o && (t = t.replace("capture", "")), {
    device: t,
    capture: o,
    passive: n
  };
}
function Ol(e, t = "") {
  const n = Va[e], r = n && n[t] || t;
  return e + r;
}
function Wn(e) {
  return "touches" in e;
}
function Ha(e) {
  return Wn(e) ? "touch" : "pointerType" in e ? e.pointerType : "mouse";
}
function Pl(e) {
  return Array.from(e.touches).filter((t) => {
    var n, r;
    return t.target === e.currentTarget || ((n = e.currentTarget) === null || n === void 0 || (r = n.contains) === null || r === void 0 ? void 0 : r.call(n, t.target));
  });
}
function Cl(e) {
  return e.type === "touchend" || e.type === "touchcancel" ? e.changedTouches : e.targetTouches;
}
function Ya(e) {
  return Wn(e) ? Cl(e)[0] : e;
}
function _l(e) {
  return Pl(e).map((t) => t.identifier);
}
function or(e) {
  const t = Ya(e);
  return Wn(e) ? t.identifier : t.pointerId;
}
function Uo(e) {
  const t = Ya(e);
  return [t.clientX, t.clientY];
}
function Tl(e) {
  const t = {};
  if ("buttons" in e && (t.buttons = e.buttons), "shiftKey" in e) {
    const {
      shiftKey: n,
      altKey: r,
      metaKey: o,
      ctrlKey: i
    } = e;
    Object.assign(t, {
      shiftKey: n,
      altKey: r,
      metaKey: o,
      ctrlKey: i
    });
  }
  return t;
}
function Sn(e, ...t) {
  return typeof e == "function" ? e(...t) : e;
}
function Rl() {
}
function Il(...e) {
  return e.length === 0 ? Rl : e.length === 1 ? e[0] : function() {
    let t;
    for (const n of e)
      t = n.apply(this, arguments) || t;
    return t;
  };
}
function Vo(e, t) {
  return Object.assign({}, t, e || {});
}
const Al = 32;
class kl {
  constructor(t, n, r) {
    this.ctrl = t, this.args = n, this.key = r, this.state || (this.state = {}, this.computeValues([0, 0]), this.computeInitial(), this.init && this.init(), this.reset());
  }
  get state() {
    return this.ctrl.state[this.key];
  }
  set state(t) {
    this.ctrl.state[this.key] = t;
  }
  get shared() {
    return this.ctrl.state.shared;
  }
  get eventStore() {
    return this.ctrl.gestureEventStores[this.key];
  }
  get timeoutStore() {
    return this.ctrl.gestureTimeoutStores[this.key];
  }
  get config() {
    return this.ctrl.config[this.key];
  }
  get sharedConfig() {
    return this.ctrl.config.shared;
  }
  get handler() {
    return this.ctrl.handlers[this.key];
  }
  reset() {
    const {
      state: t,
      shared: n,
      ingKey: r,
      args: o
    } = this;
    n[r] = t._active = t.active = t._blocked = t._force = !1, t._step = [!1, !1], t.intentional = !1, t._movement = [0, 0], t._distance = [0, 0], t._direction = [0, 0], t._delta = [0, 0], t._bounds = [[-1 / 0, 1 / 0], [-1 / 0, 1 / 0]], t.args = o, t.axis = void 0, t.memo = void 0, t.elapsedTime = t.timeDelta = 0, t.direction = [0, 0], t.distance = [0, 0], t.overflow = [0, 0], t._movementBound = [!1, !1], t.velocity = [0, 0], t.movement = [0, 0], t.delta = [0, 0], t.timeStamp = 0;
  }
  start(t) {
    const n = this.state, r = this.config;
    n._active || (this.reset(), this.computeInitial(), n._active = !0, n.target = t.target, n.currentTarget = t.currentTarget, n.lastOffset = r.from ? Sn(r.from, n) : n.offset, n.offset = n.lastOffset, n.startTime = n.timeStamp = t.timeStamp);
  }
  computeValues(t) {
    const n = this.state;
    n._values = t, n.values = this.config.transform(t);
  }
  computeInitial() {
    const t = this.state;
    t._initial = t._values, t.initial = t.values;
  }
  compute(t) {
    const {
      state: n,
      config: r,
      shared: o
    } = this;
    n.args = this.args;
    let i = 0;
    if (t && (n.event = t, r.preventDefault && t.cancelable && n.event.preventDefault(), n.type = t.type, o.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size, o.locked = !!document.pointerLockElement, Object.assign(o, Tl(t)), o.down = o.pressed = o.buttons % 2 === 1 || o.touches > 0, i = t.timeStamp - n.timeStamp, n.timeStamp = t.timeStamp, n.elapsedTime = n.timeStamp - n.startTime), n._active) {
      const E = n._delta.map(Math.abs);
      xe.addTo(n._distance, E);
    }
    this.axisIntent && this.axisIntent(t);
    const [a, s] = n._movement, [c, l] = r.threshold, {
      _step: u,
      values: f
    } = n;
    if (r.hasCustomTransform ? (u[0] === !1 && (u[0] = Math.abs(a) >= c && f[0]), u[1] === !1 && (u[1] = Math.abs(s) >= l && f[1])) : (u[0] === !1 && (u[0] = Math.abs(a) >= c && Math.sign(a) * c), u[1] === !1 && (u[1] = Math.abs(s) >= l && Math.sign(s) * l)), n.intentional = u[0] !== !1 || u[1] !== !1, !n.intentional) return;
    const d = [0, 0];
    if (r.hasCustomTransform) {
      const [E, O] = f;
      d[0] = u[0] !== !1 ? E - u[0] : 0, d[1] = u[1] !== !1 ? O - u[1] : 0;
    } else
      d[0] = u[0] !== !1 ? a - u[0] : 0, d[1] = u[1] !== !1 ? s - u[1] : 0;
    this.restrictToAxis && !n._blocked && this.restrictToAxis(d);
    const p = n.offset, m = n._active && !n._blocked || n.active;
    m && (n.first = n._active && !n.active, n.last = !n._active && n.active, n.active = o[this.ingKey] = n._active, t && (n.first && ("bounds" in r && (n._bounds = Sn(r.bounds, n)), this.setup && this.setup()), n.movement = d, this.computeOffset()));
    const [h, v] = n.offset, [[b, y], [w, x]] = n._bounds;
    n.overflow = [h < b ? -1 : h > y ? 1 : 0, v < w ? -1 : v > x ? 1 : 0], n._movementBound[0] = n.overflow[0] ? n._movementBound[0] === !1 ? n._movement[0] : n._movementBound[0] : !1, n._movementBound[1] = n.overflow[1] ? n._movementBound[1] === !1 ? n._movement[1] : n._movementBound[1] : !1;
    const $ = n._active ? r.rubberband || [0, 0] : [0, 0];
    if (n.offset = vl(n._bounds, n.offset, $), n.delta = xe.sub(n.offset, p), this.computeMovement(), m && (!n.last || i > Al)) {
      n.delta = xe.sub(n.offset, p);
      const E = n.delta.map(Math.abs);
      xe.addTo(n.distance, E), n.direction = n.delta.map(Math.sign), n._direction = n._delta.map(Math.sign), !n.first && i > 0 && (n.velocity = [E[0] / i, E[1] / i], n.timeDelta = i);
    }
  }
  emit() {
    const t = this.state, n = this.shared, r = this.config;
    if (t._active || this.clean(), (t._blocked || !t.intentional) && !t._force && !r.triggerAllEvents) return;
    const o = this.handler(de(de(de({}, n), t), {}, {
      [this.aliasKey]: t.values
    }));
    o !== void 0 && (t.memo = o);
  }
  clean() {
    this.eventStore.clean(), this.timeoutStore.clean();
  }
}
function Dl([e, t], n) {
  const r = Math.abs(e), o = Math.abs(t);
  if (r > o && r > n)
    return "x";
  if (o > r && o > n)
    return "y";
}
class Ml extends kl {
  constructor(...t) {
    super(...t), Te(this, "aliasKey", "xy");
  }
  reset() {
    super.reset(), this.state.axis = void 0;
  }
  init() {
    this.state.offset = [0, 0], this.state.lastOffset = [0, 0];
  }
  computeOffset() {
    this.state.offset = xe.add(this.state.lastOffset, this.state.movement);
  }
  computeMovement() {
    this.state.movement = xe.sub(this.state.offset, this.state.lastOffset);
  }
  axisIntent(t) {
    const n = this.state, r = this.config;
    if (!n.axis && t) {
      const o = typeof r.axisThreshold == "object" ? r.axisThreshold[Ha(t)] : r.axisThreshold;
      n.axis = Dl(n._movement, o);
    }
    n._blocked = (r.lockDirection || !!r.axis) && !n.axis || !!r.axis && r.axis !== n.axis;
  }
  restrictToAxis(t) {
    if (this.config.axis || this.config.lockDirection)
      switch (this.state.axis) {
        case "x":
          t[1] = 0;
          break;
        case "y":
          t[0] = 0;
          break;
      }
  }
}
const Ho = (e) => e, Yo = 0.15, co = {
  enabled(e = !0) {
    return e;
  },
  eventOptions(e, t, n) {
    return de(de({}, n.shared.eventOptions), e);
  },
  preventDefault(e = !1) {
    return e;
  },
  triggerAllEvents(e = !1) {
    return e;
  },
  rubberband(e = 0) {
    switch (e) {
      case !0:
        return [Yo, Yo];
      case !1:
        return [0, 0];
      default:
        return xe.toVector(e);
    }
  },
  from(e) {
    if (typeof e == "function") return e;
    if (e != null) return xe.toVector(e);
  },
  transform(e, t, n) {
    const r = e || n.shared.transform;
    if (this.hasCustomTransform = !!r, process.env.NODE_ENV === "development") {
      const o = r || Ho;
      return (i) => {
        const a = o(i);
        return (!isFinite(a[0]) || !isFinite(a[1])) && console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${a[0]},${[1]}]`), a;
      };
    }
    return r || Ho;
  },
  threshold(e) {
    return xe.toVector(e, 0);
  }
};
process.env.NODE_ENV === "development" && Object.assign(co, {
  domTarget(e) {
    if (e !== void 0)
      throw Error("[@use-gesture]: `domTarget` option has been renamed to `target`.");
    return NaN;
  },
  lockDirection(e) {
    if (e !== void 0)
      throw Error("[@use-gesture]: `lockDirection` option has been merged with `axis`. Use it as in `{ axis: 'lock' }`");
    return NaN;
  },
  initial(e) {
    if (e !== void 0)
      throw Error("[@use-gesture]: `initial` option has been renamed to `from`.");
    return NaN;
  }
});
const jl = 0, en = de(de({}, co), {}, {
  axis(e, t, {
    axis: n
  }) {
    if (this.lockDirection = n === "lock", !this.lockDirection) return n;
  },
  axisThreshold(e = jl) {
    return e;
  },
  bounds(e = {}) {
    if (typeof e == "function")
      return (i) => en.bounds(e(i));
    if ("current" in e)
      return () => e.current;
    if (typeof HTMLElement == "function" && e instanceof HTMLElement)
      return e;
    const {
      left: t = -1 / 0,
      right: n = 1 / 0,
      top: r = -1 / 0,
      bottom: o = 1 / 0
    } = e;
    return [[t, n], [r, o]];
  }
}), qo = {
  ArrowRight: (e, t = 1) => [e * t, 0],
  ArrowLeft: (e, t = 1) => [-1 * e * t, 0],
  ArrowUp: (e, t = 1) => [0, -1 * e * t],
  ArrowDown: (e, t = 1) => [0, e * t]
};
class Ll extends Ml {
  constructor(...t) {
    super(...t), Te(this, "ingKey", "dragging");
  }
  reset() {
    super.reset();
    const t = this.state;
    t._pointerId = void 0, t._pointerActive = !1, t._keyboardActive = !1, t._preventScroll = !1, t._delayed = !1, t.swipe = [0, 0], t.tap = !1, t.canceled = !1, t.cancel = this.cancel.bind(this);
  }
  setup() {
    const t = this.state;
    if (t._bounds instanceof HTMLElement) {
      const n = t._bounds.getBoundingClientRect(), r = t.currentTarget.getBoundingClientRect(), o = {
        left: n.left - r.left + t.offset[0],
        right: n.right - r.right + t.offset[0],
        top: n.top - r.top + t.offset[1],
        bottom: n.bottom - r.bottom + t.offset[1]
      };
      t._bounds = en.bounds(o);
    }
  }
  cancel() {
    const t = this.state;
    t.canceled || (t.canceled = !0, t._active = !1, setTimeout(() => {
      this.compute(), this.emit();
    }, 0));
  }
  setActive() {
    this.state._active = this.state._pointerActive || this.state._keyboardActive;
  }
  clean() {
    this.pointerClean(), this.state._pointerActive = !1, this.state._keyboardActive = !1, super.clean();
  }
  pointerDown(t) {
    const n = this.config, r = this.state;
    if (t.buttons != null && (Array.isArray(n.pointerButtons) ? !n.pointerButtons.includes(t.buttons) : n.pointerButtons !== -1 && n.pointerButtons !== t.buttons)) return;
    const o = this.ctrl.setEventIds(t);
    n.pointerCapture && t.target.setPointerCapture(t.pointerId), !(o && o.size > 1 && r._pointerActive) && (this.start(t), this.setupPointer(t), r._pointerId = or(t), r._pointerActive = !0, this.computeValues(Uo(t)), this.computeInitial(), n.preventScrollAxis && Ha(t) !== "mouse" ? (r._active = !1, this.setupScrollPrevention(t)) : n.delay > 0 ? (this.setupDelayTrigger(t), n.triggerAllEvents && (this.compute(t), this.emit())) : this.startPointerDrag(t));
  }
  startPointerDrag(t) {
    const n = this.state;
    n._active = !0, n._preventScroll = !0, n._delayed = !1, this.compute(t), this.emit();
  }
  pointerMove(t) {
    const n = this.state, r = this.config;
    if (!n._pointerActive) return;
    const o = or(t);
    if (n._pointerId !== void 0 && o !== n._pointerId) return;
    const i = Uo(t);
    if (document.pointerLockElement === t.target ? n._delta = [t.movementX, t.movementY] : (n._delta = xe.sub(i, n._values), this.computeValues(i)), xe.addTo(n._movement, n._delta), this.compute(t), n._delayed && n.intentional) {
      this.timeoutStore.remove("dragDelay"), n.active = !1, this.startPointerDrag(t);
      return;
    }
    if (r.preventScrollAxis && !n._preventScroll)
      if (n.axis)
        if (n.axis === r.preventScrollAxis || r.preventScrollAxis === "xy") {
          n._active = !1, this.clean();
          return;
        } else {
          this.timeoutStore.remove("startPointerDrag"), this.startPointerDrag(t);
          return;
        }
      else
        return;
    this.emit();
  }
  pointerUp(t) {
    this.ctrl.setEventIds(t);
    try {
      this.config.pointerCapture && t.target.hasPointerCapture(t.pointerId) && t.target.releasePointerCapture(t.pointerId);
    } catch {
      process.env.NODE_ENV === "development" && console.warn("[@use-gesture]: If you see this message, it's likely that you're using an outdated version of `@react-three/fiber`. \n\nPlease upgrade to the latest version.");
    }
    const n = this.state, r = this.config;
    if (!n._active || !n._pointerActive) return;
    const o = or(t);
    if (n._pointerId !== void 0 && o !== n._pointerId) return;
    this.state._pointerActive = !1, this.setActive(), this.compute(t);
    const [i, a] = n._distance;
    if (n.tap = i <= r.tapsThreshold && a <= r.tapsThreshold, n.tap && r.filterTaps)
      n._force = !0;
    else {
      const [s, c] = n._delta, [l, u] = n._movement, [f, d] = r.swipe.velocity, [p, m] = r.swipe.distance, h = r.swipe.duration;
      if (n.elapsedTime < h) {
        const v = Math.abs(s / n.timeDelta), b = Math.abs(c / n.timeDelta);
        v > f && Math.abs(l) > p && (n.swipe[0] = Math.sign(s)), b > d && Math.abs(u) > m && (n.swipe[1] = Math.sign(c));
      }
    }
    this.emit();
  }
  pointerClick(t) {
    !this.state.tap && t.detail > 0 && (t.preventDefault(), t.stopPropagation());
  }
  setupPointer(t) {
    const n = this.config, r = n.device;
    if (process.env.NODE_ENV === "development")
      try {
        if (r === "pointer" && n.preventScrollDelay === void 0) {
          const o = "uv" in t ? t.sourceEvent.currentTarget : t.currentTarget;
          window.getComputedStyle(o).touchAction === "auto" && console.warn("[@use-gesture]: The drag target has its `touch-action` style property set to `auto`. It is recommended to add `touch-action: 'none'` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.\n\nThis message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.", o);
        }
      } catch {
      }
    n.pointerLock && t.currentTarget.requestPointerLock(), n.pointerCapture || (this.eventStore.add(this.sharedConfig.window, r, "change", this.pointerMove.bind(this)), this.eventStore.add(this.sharedConfig.window, r, "end", this.pointerUp.bind(this)), this.eventStore.add(this.sharedConfig.window, r, "cancel", this.pointerUp.bind(this)));
  }
  pointerClean() {
    this.config.pointerLock && document.pointerLockElement === this.state.currentTarget && document.exitPointerLock();
  }
  preventScroll(t) {
    this.state._preventScroll && t.cancelable && t.preventDefault();
  }
  setupScrollPrevention(t) {
    this.state._preventScroll = !1, zl(t);
    const n = this.eventStore.add(this.sharedConfig.window, "touch", "change", this.preventScroll.bind(this), {
      passive: !1
    });
    this.eventStore.add(this.sharedConfig.window, "touch", "end", n), this.eventStore.add(this.sharedConfig.window, "touch", "cancel", n), this.timeoutStore.add("startPointerDrag", this.startPointerDrag.bind(this), this.config.preventScrollDelay, t);
  }
  setupDelayTrigger(t) {
    this.state._delayed = !0, this.timeoutStore.add("dragDelay", () => {
      this.state._step = [0, 0], this.startPointerDrag(t);
    }, this.config.delay);
  }
  keyDown(t) {
    const n = qo[t.key];
    if (n) {
      const r = this.state, o = t.shiftKey ? 10 : t.altKey ? 0.1 : 1;
      this.start(t), r._delta = n(this.config.keyboardDisplacement, o), r._keyboardActive = !0, xe.addTo(r._movement, r._delta), this.compute(t), this.emit();
    }
  }
  keyUp(t) {
    t.key in qo && (this.state._keyboardActive = !1, this.setActive(), this.compute(t), this.emit());
  }
  bind(t) {
    const n = this.config.device;
    t(n, "start", this.pointerDown.bind(this)), this.config.pointerCapture && (t(n, "change", this.pointerMove.bind(this)), t(n, "end", this.pointerUp.bind(this)), t(n, "cancel", this.pointerUp.bind(this)), t("lostPointerCapture", "", this.pointerUp.bind(this))), this.config.keys && (t("key", "down", this.keyDown.bind(this)), t("key", "up", this.keyUp.bind(this))), this.config.filterTaps && t("click", "", this.pointerClick.bind(this), {
      capture: !0,
      passive: !1
    });
  }
}
function zl(e) {
  "persist" in e && typeof e.persist == "function" && e.persist();
}
const tn = typeof window < "u" && window.document && window.document.createElement;
function qa() {
  return tn && "ontouchstart" in window;
}
function Nl() {
  return qa() || tn && window.navigator.maxTouchPoints > 1;
}
function Fl() {
  return tn && "onpointerdown" in window;
}
function Bl() {
  return tn && "exitPointerLock" in window.document;
}
function Wl() {
  try {
    return "constructor" in GestureEvent;
  } catch {
    return !1;
  }
}
const Ie = {
  isBrowser: tn,
  gesture: Wl(),
  touch: qa(),
  touchscreen: Nl(),
  pointer: Fl(),
  pointerLock: Bl()
}, Ul = 250, Vl = 180, Hl = 0.5, Yl = 50, ql = 250, Kl = 10, Ko = {
  mouse: 0,
  touch: 0,
  pen: 8
}, Ka = de(de({}, en), {}, {
  device(e, t, {
    pointer: {
      touch: n = !1,
      lock: r = !1,
      mouse: o = !1
    } = {}
  }) {
    return this.pointerLock = r && Ie.pointerLock, Ie.touch && n ? "touch" : this.pointerLock ? "mouse" : Ie.pointer && !o ? "pointer" : Ie.touch ? "touch" : "mouse";
  },
  preventScrollAxis(e, t, {
    preventScroll: n
  }) {
    if (this.preventScrollDelay = typeof n == "number" ? n : n || n === void 0 && e ? Ul : void 0, !(!Ie.touchscreen || n === !1))
      return e || (n !== void 0 ? "y" : void 0);
  },
  pointerCapture(e, t, {
    pointer: {
      capture: n = !0,
      buttons: r = 1,
      keys: o = !0
    } = {}
  }) {
    return this.pointerButtons = r, this.keys = o, !this.pointerLock && this.device === "pointer" && n;
  },
  threshold(e, t, {
    filterTaps: n = !1,
    tapsThreshold: r = 3,
    axis: o = void 0
  }) {
    const i = xe.toVector(e, n ? r : o ? 1 : 0);
    return this.filterTaps = n, this.tapsThreshold = r, i;
  },
  swipe({
    velocity: e = Hl,
    distance: t = Yl,
    duration: n = ql
  } = {}) {
    return {
      velocity: this.transform(xe.toVector(e)),
      distance: this.transform(xe.toVector(t)),
      duration: n
    };
  },
  delay(e = 0) {
    switch (e) {
      case !0:
        return Vl;
      case !1:
        return 0;
      default:
        return e;
    }
  },
  axisThreshold(e) {
    return e ? de(de({}, Ko), e) : Ko;
  },
  keyboardDisplacement(e = Kl) {
    return e;
  }
});
process.env.NODE_ENV === "development" && Object.assign(Ka, {
  useTouch(e) {
    if (e !== void 0)
      throw Error("[@use-gesture]: `useTouch` option has been renamed to `pointer.touch`. Use it as in `{ pointer: { touch: true } }`.");
    return NaN;
  },
  experimental_preventWindowScrollY(e) {
    if (e !== void 0)
      throw Error("[@use-gesture]: `experimental_preventWindowScrollY` option has been renamed to `preventScroll`.");
    return NaN;
  },
  swipeVelocity(e) {
    if (e !== void 0)
      throw Error("[@use-gesture]: `swipeVelocity` option has been renamed to `swipe.velocity`. Use it as in `{ swipe: { velocity: 0.5 } }`.");
    return NaN;
  },
  swipeDistance(e) {
    if (e !== void 0)
      throw Error("[@use-gesture]: `swipeDistance` option has been renamed to `swipe.distance`. Use it as in `{ swipe: { distance: 50 } }`.");
    return NaN;
  },
  swipeDuration(e) {
    if (e !== void 0)
      throw Error("[@use-gesture]: `swipeDuration` option has been renamed to `swipe.duration`. Use it as in `{ swipe: { duration: 250 } }`.");
    return NaN;
  }
});
de(de({}, co), {}, {
  device(e, t, {
    shared: n,
    pointer: {
      touch: r = !1
    } = {}
  }) {
    if (n.target && !Ie.touch && Ie.gesture) return "gesture";
    if (Ie.touch && r) return "touch";
    if (Ie.touchscreen) {
      if (Ie.pointer) return "pointer";
      if (Ie.touch) return "touch";
    }
  },
  bounds(e, t, {
    scaleBounds: n = {},
    angleBounds: r = {}
  }) {
    const o = (a) => {
      const s = Vo(Sn(n, a), {
        min: -1 / 0,
        max: 1 / 0
      });
      return [s.min, s.max];
    }, i = (a) => {
      const s = Vo(Sn(r, a), {
        min: -1 / 0,
        max: 1 / 0
      });
      return [s.min, s.max];
    };
    return typeof n != "function" && typeof r != "function" ? [o(), i()] : (a) => [o(a), i(a)];
  },
  threshold(e, t, n) {
    return this.lockDirection = n.axis === "lock", xe.toVector(e, this.lockDirection ? [0.1, 3] : 0);
  },
  modifierKey(e) {
    return e === void 0 ? "ctrlKey" : e;
  },
  pinchOnWheel(e = !0) {
    return e;
  }
});
de(de({}, en), {}, {
  mouseOnly: (e = !0) => e
});
de(de({}, en), {}, {
  mouseOnly: (e = !0) => e
});
const Ga = /* @__PURE__ */ new Map(), jr = /* @__PURE__ */ new Map();
function Gl(e) {
  Ga.set(e.key, e.engine), jr.set(e.key, e.resolver);
}
const Xl = {
  key: "drag",
  engine: Ll,
  resolver: Ka
};
function Ql(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Zl(e, t) {
  if (e == null) return {};
  var n = Ql(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
const Jl = {
  target(e) {
    if (e)
      return () => "current" in e ? e.current : e;
  },
  enabled(e = !0) {
    return e;
  },
  window(e = Ie.isBrowser ? window : void 0) {
    return e;
  },
  eventOptions({
    passive: e = !0,
    capture: t = !1
  } = {}) {
    return {
      passive: e,
      capture: t
    };
  },
  transform(e) {
    return e;
  }
}, eu = ["target", "eventOptions", "window", "enabled", "transform"];
function $n(e = {}, t) {
  const n = {};
  for (const [r, o] of Object.entries(t))
    switch (typeof o) {
      case "function":
        if (process.env.NODE_ENV === "development") {
          const i = o.call(n, e[r], r, e);
          Number.isNaN(i) || (n[r] = i);
        } else
          n[r] = o.call(n, e[r], r, e);
        break;
      case "object":
        n[r] = $n(e[r], o);
        break;
      case "boolean":
        o && (n[r] = e[r]);
        break;
    }
  return n;
}
function tu(e, t, n = {}) {
  const r = e, {
    target: o,
    eventOptions: i,
    window: a,
    enabled: s,
    transform: c
  } = r, l = Zl(r, eu);
  if (n.shared = $n({
    target: o,
    eventOptions: i,
    window: a,
    enabled: s,
    transform: c
  }, Jl), t) {
    const u = jr.get(t);
    n[t] = $n(de({
      shared: n.shared
    }, l), u);
  } else
    for (const u in l) {
      const f = jr.get(u);
      if (f)
        n[u] = $n(de({
          shared: n.shared
        }, l[u]), f);
      else if (process.env.NODE_ENV === "development" && !["drag", "pinch", "scroll", "wheel", "move", "hover"].includes(u)) {
        if (u === "domTarget")
          throw Error("[@use-gesture]: `domTarget` option has been renamed to `target`.");
        console.warn(`[@use-gesture]: Unknown config key \`${u}\` was used. Please read the documentation for further information.`);
      }
    }
  return n;
}
class Xa {
  constructor(t, n) {
    Te(this, "_listeners", /* @__PURE__ */ new Set()), this._ctrl = t, this._gestureKey = n;
  }
  add(t, n, r, o, i) {
    const a = this._listeners, s = Ol(n, r), c = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {}, l = de(de({}, c), i);
    t.addEventListener(s, o, l);
    const u = () => {
      t.removeEventListener(s, o, l), a.delete(u);
    };
    return a.add(u), u;
  }
  clean() {
    this._listeners.forEach((t) => t()), this._listeners.clear();
  }
}
class nu {
  constructor() {
    Te(this, "_timeouts", /* @__PURE__ */ new Map());
  }
  add(t, n, r = 140, ...o) {
    this.remove(t), this._timeouts.set(t, window.setTimeout(n, r, ...o));
  }
  remove(t) {
    const n = this._timeouts.get(t);
    n && window.clearTimeout(n);
  }
  clean() {
    this._timeouts.forEach((t) => void window.clearTimeout(t)), this._timeouts.clear();
  }
}
class ru {
  constructor(t) {
    Te(this, "gestures", /* @__PURE__ */ new Set()), Te(this, "_targetEventStore", new Xa(this)), Te(this, "gestureEventStores", {}), Te(this, "gestureTimeoutStores", {}), Te(this, "handlers", {}), Te(this, "config", {}), Te(this, "pointerIds", /* @__PURE__ */ new Set()), Te(this, "touchIds", /* @__PURE__ */ new Set()), Te(this, "state", {
      shared: {
        shiftKey: !1,
        metaKey: !1,
        ctrlKey: !1,
        altKey: !1
      }
    }), ou(this, t);
  }
  setEventIds(t) {
    if (Wn(t))
      return this.touchIds = new Set(_l(t)), this.touchIds;
    if ("pointerId" in t)
      return t.type === "pointerup" || t.type === "pointercancel" ? this.pointerIds.delete(t.pointerId) : t.type === "pointerdown" && this.pointerIds.add(t.pointerId), this.pointerIds;
  }
  applyHandlers(t, n) {
    this.handlers = t, this.nativeHandlers = n;
  }
  applyConfig(t, n) {
    this.config = tu(t, n, this.config);
  }
  clean() {
    this._targetEventStore.clean();
    for (const t of this.gestures)
      this.gestureEventStores[t].clean(), this.gestureTimeoutStores[t].clean();
  }
  effect() {
    return this.config.shared.target && this.bind(), () => this._targetEventStore.clean();
  }
  bind(...t) {
    const n = this.config.shared, r = {};
    let o;
    if (!(n.target && (o = n.target(), !o))) {
      if (n.enabled) {
        for (const a of this.gestures) {
          const s = this.config[a], c = Go(r, s.eventOptions, !!o);
          if (s.enabled) {
            const l = Ga.get(a);
            new l(this, t, a).bind(c);
          }
        }
        const i = Go(r, n.eventOptions, !!o);
        for (const a in this.nativeHandlers)
          i(a, "", (s) => this.nativeHandlers[a](de(de({}, this.state.shared), {}, {
            event: s,
            args: t
          })), void 0, !0);
      }
      for (const i in r)
        r[i] = Il(...r[i]);
      if (!o) return r;
      for (const i in r) {
        const {
          device: a,
          capture: s,
          passive: c
        } = Sl(i);
        this._targetEventStore.add(o, a, "", r[i], {
          capture: s,
          passive: c
        });
      }
    }
  }
}
function Pt(e, t) {
  e.gestures.add(t), e.gestureEventStores[t] = new Xa(e, t), e.gestureTimeoutStores[t] = new nu();
}
function ou(e, t) {
  t.drag && Pt(e, "drag"), t.wheel && Pt(e, "wheel"), t.scroll && Pt(e, "scroll"), t.move && Pt(e, "move"), t.pinch && Pt(e, "pinch"), t.hover && Pt(e, "hover");
}
const Go = (e, t, n) => (r, o, i, a = {}, s = !1) => {
  var c, l;
  const u = (c = a.capture) !== null && c !== void 0 ? c : t.capture, f = (l = a.passive) !== null && l !== void 0 ? l : t.passive;
  let d = s ? r : xl(r, o, u);
  n && f && (d += "Passive"), e[d] = e[d] || [], e[d].push(i);
};
function iu(e, t = {}, n, r) {
  const o = g.useMemo(() => new ru(e), []);
  if (o.applyHandlers(e, r), o.applyConfig(t, n), g.useEffect(o.effect.bind(o)), g.useEffect(() => o.clean.bind(o), []), t.target === void 0)
    return o.bind.bind(o);
}
function au(e, t) {
  return Gl(Xl), iu({
    drag: e
  }, t || {}, "drag");
}
function He(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(o) {
    if (e == null || e(o), n === !1 || !o.defaultPrevented) return t == null ? void 0 : t(o);
  };
}
function Qa(e, t = []) {
  let n = [];
  function r(i, a) {
    const s = /* @__PURE__ */ vt(a), c = n.length;
    n = [
      ...n,
      a
    ];
    function l(f) {
      const { scope: d, children: p, ...m } = f, h = (d == null ? void 0 : d[e][c]) || s, v = ge(
        () => m,
        Object.values(m)
      );
      return /* @__PURE__ */ ee(h.Provider, {
        value: v
      }, p);
    }
    function u(f, d) {
      const p = (d == null ? void 0 : d[e][c]) || s, m = yt(p);
      if (m) return m;
      if (a !== void 0) return a;
      throw new Error(`\`${f}\` must be used within \`${i}\``);
    }
    return l.displayName = i + "Provider", [
      l,
      u
    ];
  }
  const o = () => {
    const i = n.map((a) => /* @__PURE__ */ vt(a));
    return function(s) {
      const c = (s == null ? void 0 : s[e]) || i;
      return ge(
        () => ({
          [`__scope${e}`]: {
            ...s,
            [e]: c
          }
        }),
        [
          s,
          c
        ]
      );
    };
  };
  return o.scopeName = e, [
    r,
    su(o, ...t)
  ];
}
function su(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map(
      (o) => ({
        useScope: o(),
        scopeName: o.scopeName
      })
    );
    return function(i) {
      const a = r.reduce((s, { useScope: c, scopeName: l }) => {
        const f = c(i)[`__scope${l}`];
        return {
          ...s,
          ...f
        };
      }, {});
      return ge(
        () => ({
          [`__scope${t.scopeName}`]: a
        }),
        [
          a
        ]
      );
    };
  };
  return n.scopeName = t.scopeName, n;
}
function Dt(e) {
  const t = _(e);
  return Y(() => {
    t.current = e;
  }), ge(
    () => (...n) => {
      var r;
      return (r = t.current) === null || r === void 0 ? void 0 : r.call(t, ...n);
    },
    []
  );
}
function cu(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Dt(e);
  Y(() => {
    const r = (o) => {
      o.key === "Escape" && n(o);
    };
    return t.addEventListener("keydown", r), () => t.removeEventListener("keydown", r);
  }, [
    n,
    t
  ]);
}
const Lr = "dismissableLayer.update", lu = "dismissableLayer.pointerDownOutside", uu = "dismissableLayer.focusOutside";
let Xo;
const fu = /* @__PURE__ */ vt({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), du = /* @__PURE__ */ be((e, t) => {
  var n;
  const { disableOutsidePointerEvents: r = !1, onEscapeKeyDown: o, onPointerDownOutside: i, onFocusOutside: a, onInteractOutside: s, onDismiss: c, ...l } = e, u = yt(fu), [f, d] = oe(null), p = (n = f == null ? void 0 : f.ownerDocument) !== null && n !== void 0 ? n : globalThis == null ? void 0 : globalThis.document, [, m] = oe({}), h = At(
    t,
    (C) => d(C)
  ), v = Array.from(u.layers), [b] = [
    ...u.layersWithOutsidePointerEventsDisabled
  ].slice(-1), y = v.indexOf(b), w = f ? v.indexOf(f) : -1, x = u.layersWithOutsidePointerEventsDisabled.size > 0, $ = w >= y, E = pu((C) => {
    const B = C.target, R = [
      ...u.branches
    ].some(
      (T) => T.contains(B)
    );
    !$ || R || (i == null || i(C), s == null || s(C), C.defaultPrevented || c == null || c());
  }, p), O = hu((C) => {
    const B = C.target;
    [
      ...u.branches
    ].some(
      (T) => T.contains(B)
    ) || (a == null || a(C), s == null || s(C), C.defaultPrevented || c == null || c());
  }, p);
  return cu((C) => {
    w === u.layers.size - 1 && (o == null || o(C), !C.defaultPrevented && c && (C.preventDefault(), c()));
  }, p), Y(() => {
    if (f)
      return r && (u.layersWithOutsidePointerEventsDisabled.size === 0 && (Xo = p.body.style.pointerEvents, p.body.style.pointerEvents = "none"), u.layersWithOutsidePointerEventsDisabled.add(f)), u.layers.add(f), Qo(), () => {
        r && u.layersWithOutsidePointerEventsDisabled.size === 1 && (p.body.style.pointerEvents = Xo);
      };
  }, [
    f,
    p,
    r,
    u
  ]), Y(() => () => {
    f && (u.layers.delete(f), u.layersWithOutsidePointerEventsDisabled.delete(f), Qo());
  }, [
    f,
    u
  ]), Y(() => {
    const C = () => m({});
    return document.addEventListener(Lr, C), () => document.removeEventListener(Lr, C);
  }, []), /* @__PURE__ */ ee(ut.div, we({}, l, {
    ref: h,
    style: {
      pointerEvents: x ? $ ? "auto" : "none" : void 0,
      ...e.style
    },
    onFocusCapture: He(e.onFocusCapture, O.onFocusCapture),
    onBlurCapture: He(e.onBlurCapture, O.onBlurCapture),
    onPointerDownCapture: He(e.onPointerDownCapture, E.onPointerDownCapture)
  }));
});
function pu(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Dt(e), r = _(!1), o = _(() => {
  });
  return Y(() => {
    const i = (s) => {
      if (s.target && !r.current) {
        let l = function() {
          Za(lu, n, c, {
            discrete: !0
          });
        };
        const c = {
          originalEvent: s
        };
        s.pointerType === "touch" ? (t.removeEventListener("click", o.current), o.current = l, t.addEventListener("click", o.current, {
          once: !0
        })) : l();
      }
      r.current = !1;
    }, a = window.setTimeout(() => {
      t.addEventListener("pointerdown", i);
    }, 0);
    return () => {
      window.clearTimeout(a), t.removeEventListener("pointerdown", i), t.removeEventListener("click", o.current);
    };
  }, [
    t,
    n
  ]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function hu(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Dt(e), r = _(!1);
  return Y(() => {
    const o = (i) => {
      i.target && !r.current && Za(uu, n, {
        originalEvent: i
      }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", o), () => t.removeEventListener("focusin", o);
  }, [
    t,
    n
  ]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function Qo() {
  const e = new CustomEvent(Lr);
  document.dispatchEvent(e);
}
function Za(e, t, n, { discrete: r }) {
  const o = n.originalEvent.target, i = new CustomEvent(e, {
    bubbles: !1,
    cancelable: !0,
    detail: n
  });
  t && o.addEventListener(e, t, {
    once: !0
  }), r ? Mc(o, i) : o.dispatchEvent(i);
}
const ct = globalThis != null && globalThis.document ? Qe : () => {
}, gu = Oe.useId || (() => {
});
let mu = 0;
function vu(e) {
  const [t, n] = Oe.useState(gu());
  return ct(() => {
    n(
      (r) => r ?? String(mu++)
    );
  }, [
    e
  ]), t ? `radix-${t}` : "";
}
function wt(e) {
  return e.split("-")[0];
}
function nn(e) {
  return e.split("-")[1];
}
function Mt(e) {
  return ["top", "bottom"].includes(wt(e)) ? "x" : "y";
}
function lo(e) {
  return e === "y" ? "height" : "width";
}
function Zo(e, t, n) {
  let { reference: r, floating: o } = e;
  const i = r.x + r.width / 2 - o.width / 2, a = r.y + r.height / 2 - o.height / 2, s = Mt(t), c = lo(s), l = r[c] / 2 - o[c] / 2, u = s === "x";
  let f;
  switch (wt(t)) {
    case "top":
      f = { x: i, y: r.y - o.height };
      break;
    case "bottom":
      f = { x: i, y: r.y + r.height };
      break;
    case "right":
      f = { x: r.x + r.width, y: a };
      break;
    case "left":
      f = { x: r.x - o.width, y: a };
      break;
    default:
      f = { x: r.x, y: r.y };
  }
  switch (nn(t)) {
    case "start":
      f[s] -= l * (n && u ? -1 : 1);
      break;
    case "end":
      f[s] += l * (n && u ? -1 : 1);
  }
  return f;
}
const bu = async (e, t, n) => {
  const { placement: r = "bottom", strategy: o = "absolute", middleware: i = [], platform: a } = n, s = await (a.isRTL == null ? void 0 : a.isRTL(t));
  let c = await a.getElementRects({ reference: e, floating: t, strategy: o }), { x: l, y: u } = Zo(c, r, s), f = r, d = {}, p = 0;
  for (let m = 0; m < i.length; m++) {
    const { name: h, fn: v } = i[m], { x: b, y, data: w, reset: x } = await v({ x: l, y: u, initialPlacement: r, placement: f, strategy: o, middlewareData: d, rects: c, platform: a, elements: { reference: e, floating: t } });
    l = b ?? l, u = y ?? u, d = { ...d, [h]: { ...d[h], ...w } }, x && p <= 50 && (p++, typeof x == "object" && (x.placement && (f = x.placement), x.rects && (c = x.rects === !0 ? await a.getElementRects({ reference: e, floating: t, strategy: o }) : x.rects), { x: l, y: u } = Zo(c, f, s)), m = -1);
  }
  return { x: l, y: u, placement: f, strategy: o, middlewareData: d };
};
function Ja(e) {
  return typeof e != "number" ? function(t) {
    return { top: 0, right: 0, bottom: 0, left: 0, ...t };
  }(e) : { top: e, right: e, bottom: e, left: e };
}
function On(e) {
  return { ...e, top: e.y, left: e.x, right: e.x + e.width, bottom: e.y + e.height };
}
async function Zt(e, t) {
  var n;
  t === void 0 && (t = {});
  const { x: r, y: o, platform: i, rects: a, elements: s, strategy: c } = e, { boundary: l = "clippingAncestors", rootBoundary: u = "viewport", elementContext: f = "floating", altBoundary: d = !1, padding: p = 0 } = t, m = Ja(p), h = s[d ? f === "floating" ? "reference" : "floating" : f], v = On(await i.getClippingRect({ element: (n = await (i.isElement == null ? void 0 : i.isElement(h))) == null || n ? h : h.contextElement || await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(s.floating)), boundary: l, rootBoundary: u, strategy: c })), b = On(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: f === "floating" ? { ...a.floating, x: r, y: o } : a.reference, offsetParent: await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(s.floating)), strategy: c }) : a[f]);
  return { top: v.top - b.top + m.top, bottom: b.bottom - v.bottom + m.bottom, left: v.left - b.left + m.left, right: b.right - v.right + m.right };
}
const yu = Math.min, pt = Math.max;
function zr(e, t, n) {
  return pt(e, yu(t, n));
}
const Jo = (e) => ({ name: "arrow", options: e, async fn(t) {
  const { element: n, padding: r = 0 } = e ?? {}, { x: o, y: i, placement: a, rects: s, platform: c } = t;
  if (n == null) return {};
  const l = Ja(r), u = { x: o, y: i }, f = Mt(a), d = nn(a), p = lo(f), m = await c.getDimensions(n), h = f === "y" ? "top" : "left", v = f === "y" ? "bottom" : "right", b = s.reference[p] + s.reference[f] - u[f] - s.floating[p], y = u[f] - s.reference[f], w = await (c.getOffsetParent == null ? void 0 : c.getOffsetParent(n));
  let x = w ? f === "y" ? w.clientHeight || 0 : w.clientWidth || 0 : 0;
  x === 0 && (x = s.floating[p]);
  const $ = b / 2 - y / 2, E = l[h], O = x - m[p] - l[v], C = x / 2 - m[p] / 2 + $, B = zr(E, C, O), R = (d === "start" ? l[h] : l[v]) > 0 && C !== B && s.reference[p] <= s.floating[p];
  return { [f]: u[f] - (R ? C < E ? E - C : O - C : 0), data: { [f]: B, centerOffset: C - B } };
} }), wu = { left: "right", right: "left", bottom: "top", top: "bottom" };
function Pn(e) {
  return e.replace(/left|right|bottom|top/g, (t) => wu[t]);
}
function $u(e, t, n) {
  n === void 0 && (n = !1);
  const r = nn(e), o = Mt(e), i = lo(o);
  let a = o === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[i] > t.floating[i] && (a = Pn(a)), { main: a, cross: Pn(a) };
}
const xu = { start: "end", end: "start" };
function ei(e) {
  return e.replace(/start|end/g, (t) => xu[t]);
}
const es = ["top", "right", "bottom", "left"];
es.reduce((e, t) => e.concat(t, t + "-start", t + "-end"), []);
const Eu = function(e) {
  return e === void 0 && (e = {}), { name: "flip", options: e, async fn(t) {
    var n;
    const { placement: r, middlewareData: o, rects: i, initialPlacement: a, platform: s, elements: c } = t, { mainAxis: l = !0, crossAxis: u = !0, fallbackPlacements: f, fallbackStrategy: d = "bestFit", flipAlignment: p = !0, ...m } = e, h = wt(r), v = f || (h === a || !p ? [Pn(a)] : function(C) {
      const B = Pn(C);
      return [ei(C), B, ei(B)];
    }(a)), b = [a, ...v], y = await Zt(t, m), w = [];
    let x = ((n = o.flip) == null ? void 0 : n.overflows) || [];
    if (l && w.push(y[h]), u) {
      const { main: C, cross: B } = $u(r, i, await (s.isRTL == null ? void 0 : s.isRTL(c.floating)));
      w.push(y[C], y[B]);
    }
    if (x = [...x, { placement: r, overflows: w }], !w.every((C) => C <= 0)) {
      var $, E;
      const C = (($ = (E = o.flip) == null ? void 0 : E.index) != null ? $ : 0) + 1, B = b[C];
      if (B) return { data: { index: C, overflows: x }, reset: { placement: B } };
      let R = "bottom";
      switch (d) {
        case "bestFit": {
          var O;
          const T = (O = x.map((A) => [A, A.overflows.filter((M) => M > 0).reduce((M, Z) => M + Z, 0)]).sort((A, M) => A[1] - M[1])[0]) == null ? void 0 : O[0].placement;
          T && (R = T);
          break;
        }
        case "initialPlacement":
          R = a;
      }
      if (r !== R) return { reset: { placement: R } };
    }
    return {};
  } };
};
function ti(e, t) {
  return { top: e.top - t.height, right: e.right - t.width, bottom: e.bottom - t.height, left: e.left - t.width };
}
function ni(e) {
  return es.some((t) => e[t] >= 0);
}
const Su = function(e) {
  let { strategy: t = "referenceHidden", ...n } = e === void 0 ? {} : e;
  return { name: "hide", async fn(r) {
    const { rects: o } = r;
    switch (t) {
      case "referenceHidden": {
        const i = ti(await Zt(r, { ...n, elementContext: "reference" }), o.reference);
        return { data: { referenceHiddenOffsets: i, referenceHidden: ni(i) } };
      }
      case "escaped": {
        const i = ti(await Zt(r, { ...n, altBoundary: !0 }), o.floating);
        return { data: { escapedOffsets: i, escaped: ni(i) } };
      }
      default:
        return {};
    }
  } };
}, Ou = function(e) {
  return e === void 0 && (e = 0), { name: "offset", options: e, async fn(t) {
    const { x: n, y: r } = t, o = await async function(i, a) {
      const { placement: s, platform: c, elements: l } = i, u = await (c.isRTL == null ? void 0 : c.isRTL(l.floating)), f = wt(s), d = nn(s), p = Mt(s) === "x", m = ["left", "top"].includes(f) ? -1 : 1, h = u && p ? -1 : 1, v = typeof a == "function" ? a(i) : a;
      let { mainAxis: b, crossAxis: y, alignmentAxis: w } = typeof v == "number" ? { mainAxis: v, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...v };
      return d && typeof w == "number" && (y = d === "end" ? -1 * w : w), p ? { x: y * h, y: b * m } : { x: b * m, y: y * h };
    }(t, e);
    return { x: n + o.x, y: r + o.y, data: o };
  } };
};
function ts(e) {
  return e === "x" ? "y" : "x";
}
const Pu = function(e) {
  return e === void 0 && (e = {}), { name: "shift", options: e, async fn(t) {
    const { x: n, y: r, placement: o } = t, { mainAxis: i = !0, crossAxis: a = !1, limiter: s = { fn: (v) => {
      let { x: b, y } = v;
      return { x: b, y };
    } }, ...c } = e, l = { x: n, y: r }, u = await Zt(t, c), f = Mt(wt(o)), d = ts(f);
    let p = l[f], m = l[d];
    if (i) {
      const v = f === "y" ? "bottom" : "right";
      p = zr(p + u[f === "y" ? "top" : "left"], p, p - u[v]);
    }
    if (a) {
      const v = d === "y" ? "bottom" : "right";
      m = zr(m + u[d === "y" ? "top" : "left"], m, m - u[v]);
    }
    const h = s.fn({ ...t, [f]: p, [d]: m });
    return { ...h, data: { x: h.x - n, y: h.y - r } };
  } };
}, Cu = function(e) {
  return e === void 0 && (e = {}), { options: e, fn(t) {
    const { x: n, y: r, placement: o, rects: i, middlewareData: a } = t, { offset: s = 0, mainAxis: c = !0, crossAxis: l = !0 } = e, u = { x: n, y: r }, f = Mt(o), d = ts(f);
    let p = u[f], m = u[d];
    const h = typeof s == "function" ? s({ ...i, placement: o }) : s, v = typeof h == "number" ? { mainAxis: h, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...h };
    if (c) {
      const $ = f === "y" ? "height" : "width", E = i.reference[f] - i.floating[$] + v.mainAxis, O = i.reference[f] + i.reference[$] - v.mainAxis;
      p < E ? p = E : p > O && (p = O);
    }
    if (l) {
      var b, y, w, x;
      const $ = f === "y" ? "width" : "height", E = ["top", "left"].includes(wt(o)), O = i.reference[d] - i.floating[$] + (E && (b = (y = a.offset) == null ? void 0 : y[d]) != null ? b : 0) + (E ? 0 : v.crossAxis), C = i.reference[d] + i.reference[$] + (E ? 0 : (w = (x = a.offset) == null ? void 0 : x[d]) != null ? w : 0) - (E ? v.crossAxis : 0);
      m < O ? m = O : m > C && (m = C);
    }
    return { [f]: p, [d]: m };
  } };
}, _u = function(e) {
  return e === void 0 && (e = {}), { name: "size", options: e, async fn(t) {
    const { placement: n, rects: r, platform: o, elements: i } = t, { apply: a, ...s } = e, c = await Zt(t, s), l = wt(n), u = nn(n);
    let f, d;
    l === "top" || l === "bottom" ? (f = l, d = u === (await (o.isRTL == null ? void 0 : o.isRTL(i.floating)) ? "start" : "end") ? "left" : "right") : (d = l, f = u === "end" ? "top" : "bottom");
    const p = pt(c.left, 0), m = pt(c.right, 0), h = pt(c.top, 0), v = pt(c.bottom, 0), b = { availableHeight: r.floating.height - (["left", "right"].includes(n) ? 2 * (h !== 0 || v !== 0 ? h + v : pt(c.top, c.bottom)) : c[f]), availableWidth: r.floating.width - (["top", "bottom"].includes(n) ? 2 * (p !== 0 || m !== 0 ? p + m : pt(c.left, c.right)) : c[d]) }, y = await o.getDimensions(i.floating);
    a == null || a({ ...t, ...b });
    const w = await o.getDimensions(i.floating);
    return y.width !== w.width || y.height !== w.height ? { reset: { rects: !0 } } : {};
  } };
};
function ns(e) {
  return e && e.document && e.location && e.alert && e.setInterval;
}
function Ze(e) {
  if (e == null) return window;
  if (!ns(e)) {
    const t = e.ownerDocument;
    return t && t.defaultView || window;
  }
  return e;
}
function rn(e) {
  return Ze(e).getComputedStyle(e);
}
function qe(e) {
  return ns(e) ? "" : e ? (e.nodeName || "").toLowerCase() : "";
}
function rs() {
  const e = navigator.userAgentData;
  return e != null && e.brands ? e.brands.map((t) => t.brand + "/" + t.version).join(" ") : navigator.userAgent;
}
function We(e) {
  return e instanceof Ze(e).HTMLElement;
}
function ft(e) {
  return e instanceof Ze(e).Element;
}
function uo(e) {
  return typeof ShadowRoot > "u" ? !1 : e instanceof Ze(e).ShadowRoot || e instanceof ShadowRoot;
}
function Un(e) {
  const { overflow: t, overflowX: n, overflowY: r } = rn(e);
  return /auto|scroll|overlay|hidden/.test(t + r + n);
}
function Tu(e) {
  return ["table", "td", "th"].includes(qe(e));
}
function ri(e) {
  const t = /firefox/i.test(rs()), n = rn(e);
  return n.transform !== "none" || n.perspective !== "none" || n.contain === "paint" || ["transform", "perspective"].includes(n.willChange) || t && n.willChange === "filter" || t && !!n.filter && n.filter !== "none";
}
function os() {
  return !/^((?!chrome|android).)*safari/i.test(rs());
}
const oi = Math.min, Yt = Math.max, Cn = Math.round;
function Ke(e, t, n) {
  var r, o, i, a;
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const s = e.getBoundingClientRect();
  let c = 1, l = 1;
  t && We(e) && (c = e.offsetWidth > 0 && Cn(s.width) / e.offsetWidth || 1, l = e.offsetHeight > 0 && Cn(s.height) / e.offsetHeight || 1);
  const u = ft(e) ? Ze(e) : window, f = !os() && n, d = (s.left + (f && (r = (o = u.visualViewport) == null ? void 0 : o.offsetLeft) != null ? r : 0)) / c, p = (s.top + (f && (i = (a = u.visualViewport) == null ? void 0 : a.offsetTop) != null ? i : 0)) / l, m = s.width / c, h = s.height / l;
  return { width: m, height: h, top: p, right: d + m, bottom: p + h, left: d, x: d, y: p };
}
function lt(e) {
  return (t = e, (t instanceof Ze(t).Node ? e.ownerDocument : e.document) || window.document).documentElement;
  var t;
}
function Vn(e) {
  return ft(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset };
}
function is(e) {
  return Ke(lt(e)).left + Vn(e).scrollLeft;
}
function Ru(e, t, n) {
  const r = We(t), o = lt(t), i = Ke(e, r && function(c) {
    const l = Ke(c);
    return Cn(l.width) !== c.offsetWidth || Cn(l.height) !== c.offsetHeight;
  }(t), n === "fixed");
  let a = { scrollLeft: 0, scrollTop: 0 };
  const s = { x: 0, y: 0 };
  if (r || !r && n !== "fixed") if ((qe(t) !== "body" || Un(o)) && (a = Vn(t)), We(t)) {
    const c = Ke(t, !0);
    s.x = c.x + t.clientLeft, s.y = c.y + t.clientTop;
  } else o && (s.x = is(o));
  return { x: i.left + a.scrollLeft - s.x, y: i.top + a.scrollTop - s.y, width: i.width, height: i.height };
}
function as(e) {
  return qe(e) === "html" ? e : e.assignedSlot || e.parentNode || (uo(e) ? e.host : null) || lt(e);
}
function ii(e) {
  return We(e) && getComputedStyle(e).position !== "fixed" ? e.offsetParent : null;
}
function Nr(e) {
  const t = Ze(e);
  let n = ii(e);
  for (; n && Tu(n) && getComputedStyle(n).position === "static"; ) n = ii(n);
  return n && (qe(n) === "html" || qe(n) === "body" && getComputedStyle(n).position === "static" && !ri(n)) ? t : n || function(r) {
    let o = as(r);
    for (uo(o) && (o = o.host); We(o) && !["html", "body"].includes(qe(o)); ) {
      if (ri(o)) return o;
      o = o.parentNode;
    }
    return null;
  }(e) || t;
}
function ai(e) {
  if (We(e)) return { width: e.offsetWidth, height: e.offsetHeight };
  const t = Ke(e);
  return { width: t.width, height: t.height };
}
function ss(e) {
  const t = as(e);
  return ["html", "body", "#document"].includes(qe(t)) ? e.ownerDocument.body : We(t) && Un(t) ? t : ss(t);
}
function _n(e, t) {
  var n;
  t === void 0 && (t = []);
  const r = ss(e), o = r === ((n = e.ownerDocument) == null ? void 0 : n.body), i = Ze(r), a = o ? [i].concat(i.visualViewport || [], Un(r) ? r : []) : r, s = t.concat(a);
  return o ? s : s.concat(_n(a));
}
function si(e, t, n) {
  return t === "viewport" ? On(function(r, o) {
    const i = Ze(r), a = lt(r), s = i.visualViewport;
    let c = a.clientWidth, l = a.clientHeight, u = 0, f = 0;
    if (s) {
      c = s.width, l = s.height;
      const d = os();
      (d || !d && o === "fixed") && (u = s.offsetLeft, f = s.offsetTop);
    }
    return { width: c, height: l, x: u, y: f };
  }(e, n)) : ft(t) ? function(r, o) {
    const i = Ke(r, !1, o === "fixed"), a = i.top + r.clientTop, s = i.left + r.clientLeft;
    return { top: a, left: s, x: s, y: a, right: s + r.clientWidth, bottom: a + r.clientHeight, width: r.clientWidth, height: r.clientHeight };
  }(t, n) : On(function(r) {
    var o;
    const i = lt(r), a = Vn(r), s = (o = r.ownerDocument) == null ? void 0 : o.body, c = Yt(i.scrollWidth, i.clientWidth, s ? s.scrollWidth : 0, s ? s.clientWidth : 0), l = Yt(i.scrollHeight, i.clientHeight, s ? s.scrollHeight : 0, s ? s.clientHeight : 0);
    let u = -a.scrollLeft + is(r);
    const f = -a.scrollTop;
    return rn(s || i).direction === "rtl" && (u += Yt(i.clientWidth, s ? s.clientWidth : 0) - c), { width: c, height: l, x: u, y: f };
  }(lt(e)));
}
function Iu(e) {
  const t = _n(e), n = ["absolute", "fixed"].includes(rn(e).position) && We(e) ? Nr(e) : e;
  return ft(n) ? t.filter((r) => ft(r) && function(o, i) {
    const a = i.getRootNode == null ? void 0 : i.getRootNode();
    if (o.contains(i)) return !0;
    if (a && uo(a)) {
      let s = i;
      do {
        if (s && o === s) return !0;
        s = s.parentNode || s.host;
      } while (s);
    }
    return !1;
  }(r, n) && qe(r) !== "body") : [];
}
const Au = { getClippingRect: function(e) {
  let { element: t, boundary: n, rootBoundary: r, strategy: o } = e;
  const i = [...n === "clippingAncestors" ? Iu(t) : [].concat(n), r], a = i[0], s = i.reduce((c, l) => {
    const u = si(t, l, o);
    return c.top = Yt(u.top, c.top), c.right = oi(u.right, c.right), c.bottom = oi(u.bottom, c.bottom), c.left = Yt(u.left, c.left), c;
  }, si(t, a, o));
  return { width: s.right - s.left, height: s.bottom - s.top, x: s.left, y: s.top };
}, convertOffsetParentRelativeRectToViewportRelativeRect: function(e) {
  let { rect: t, offsetParent: n, strategy: r } = e;
  const o = We(n), i = lt(n);
  if (n === i) return t;
  let a = { scrollLeft: 0, scrollTop: 0 };
  const s = { x: 0, y: 0 };
  if ((o || !o && r !== "fixed") && ((qe(n) !== "body" || Un(i)) && (a = Vn(n)), We(n))) {
    const c = Ke(n, !0);
    s.x = c.x + n.clientLeft, s.y = c.y + n.clientTop;
  }
  return { ...t, x: t.x - a.scrollLeft + s.x, y: t.y - a.scrollTop + s.y };
}, isElement: ft, getDimensions: ai, getOffsetParent: Nr, getDocumentElement: lt, getElementRects: (e) => {
  let { reference: t, floating: n, strategy: r } = e;
  return { reference: Ru(t, Nr(n), r), floating: { ...ai(n), x: 0, y: 0 } };
}, getClientRects: (e) => Array.from(e.getClientRects()), isRTL: (e) => rn(e).direction === "rtl" };
function ku(e, t, n, r) {
  r === void 0 && (r = {});
  const { ancestorScroll: o = !0, ancestorResize: i = !0, elementResize: a = !0, animationFrame: s = !1 } = r, c = o && !s, l = i && !s, u = c || l ? [...ft(e) ? _n(e) : [], ..._n(t)] : [];
  u.forEach((m) => {
    c && m.addEventListener("scroll", n, { passive: !0 }), l && m.addEventListener("resize", n);
  });
  let f, d = null;
  if (a) {
    let m = !0;
    d = new ResizeObserver(() => {
      m || n(), m = !1;
    }), ft(e) && !s && d.observe(e), d.observe(t);
  }
  let p = s ? Ke(e) : null;
  return s && function m() {
    const h = Ke(e);
    !p || h.x === p.x && h.y === p.y && h.width === p.width && h.height === p.height || n(), p = h, f = requestAnimationFrame(m);
  }(), n(), () => {
    var m;
    u.forEach((h) => {
      c && h.removeEventListener("scroll", n), l && h.removeEventListener("resize", n);
    }), (m = d) == null || m.disconnect(), d = null, s && cancelAnimationFrame(f);
  };
}
const Du = (e, t, n) => bu(e, t, { platform: Au, ...n });
var Fr = typeof document < "u" ? Qe : Y;
function Br(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, r, o;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n != t.length) return !1;
      for (r = n; r-- !== 0; )
        if (!Br(e[r], t[r]))
          return !1;
      return !0;
    }
    if (o = Object.keys(e), n = o.length, n !== Object.keys(t).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(t, o[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const i = o[r];
      if (!(i === "_owner" && e.$$typeof) && !Br(e[i], t[i]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function Mu(e) {
  const t = Oe.useRef(e);
  return Fr(() => {
    t.current = e;
  }), t;
}
function ju(e) {
  let {
    middleware: t,
    placement: n = "bottom",
    strategy: r = "absolute",
    whileElementsMounted: o
  } = e === void 0 ? {} : e;
  const i = Oe.useRef(null), a = Oe.useRef(null), s = Mu(o), c = Oe.useRef(null), [l, u] = Oe.useState({
    // Setting these to `null` will allow the consumer to determine if
    // `computePosition()` has run yet
    x: null,
    y: null,
    strategy: r,
    placement: n,
    middlewareData: {}
  }), [f, d] = Oe.useState(t);
  Br(f == null ? void 0 : f.map((w) => {
    let {
      options: x
    } = w;
    return x;
  }), t == null ? void 0 : t.map((w) => {
    let {
      options: x
    } = w;
    return x;
  })) || d(t);
  const p = Oe.useCallback(() => {
    !i.current || !a.current || Du(i.current, a.current, {
      middleware: f,
      placement: n,
      strategy: r
    }).then((w) => {
      m.current && Cc.flushSync(() => {
        u(w);
      });
    });
  }, [f, n, r]);
  Fr(() => {
    m.current && p();
  }, [p]);
  const m = Oe.useRef(!1);
  Fr(() => (m.current = !0, () => {
    m.current = !1;
  }), []);
  const h = Oe.useCallback(() => {
    if (typeof c.current == "function" && (c.current(), c.current = null), i.current && a.current)
      if (s.current) {
        const w = s.current(i.current, a.current, p);
        c.current = w;
      } else
        p();
  }, [p, s]), v = Oe.useCallback((w) => {
    i.current = w, h();
  }, [h]), b = Oe.useCallback((w) => {
    a.current = w, h();
  }, [h]), y = Oe.useMemo(() => ({
    reference: i,
    floating: a
  }), []);
  return Oe.useMemo(() => ({
    ...l,
    update: p,
    refs: y,
    reference: v,
    floating: b
  }), [l, p, y, v, b]);
}
const Lu = (e) => {
  const {
    element: t,
    padding: n
  } = e;
  function r(o) {
    return Object.prototype.hasOwnProperty.call(o, "current");
  }
  return {
    name: "arrow",
    options: e,
    fn(o) {
      return r(t) ? t.current != null ? Jo({
        element: t.current,
        padding: n
      }).fn(o) : {} : t ? Jo({
        element: t,
        padding: n
      }).fn(o) : {};
    }
  };
}, zu = /* @__PURE__ */ be((e, t) => {
  const { children: n, width: r = 10, height: o = 5, ...i } = e;
  return /* @__PURE__ */ ee(ut.svg, we({}, i, {
    ref: t,
    width: r,
    height: o,
    viewBox: "0 0 30 10",
    preserveAspectRatio: "none"
  }), e.asChild ? n : /* @__PURE__ */ ee("polygon", {
    points: "0,0 30,0 15,10"
  }));
}), Nu = zu;
function Fu(e) {
  const [t, n] = oe(void 0);
  return ct(() => {
    if (e) {
      n({
        width: e.offsetWidth,
        height: e.offsetHeight
      });
      const r = new ResizeObserver((o) => {
        if (!Array.isArray(o) || !o.length) return;
        const i = o[0];
        let a, s;
        if ("borderBoxSize" in i) {
          const c = i.borderBoxSize, l = Array.isArray(c) ? c[0] : c;
          a = l.inlineSize, s = l.blockSize;
        } else
          a = e.offsetWidth, s = e.offsetHeight;
        n({
          width: a,
          height: s
        });
      });
      return r.observe(e, {
        box: "border-box"
      }), () => r.unobserve(e);
    } else
      n(void 0);
  }, [
    e
  ]), t;
}
const cs = "Popper", [fo, ls] = Qa(cs), [Bu, us] = fo(cs), Wu = (e) => {
  const { __scopePopper: t, children: n } = e, [r, o] = oe(null);
  return /* @__PURE__ */ ee(Bu, {
    scope: t,
    anchor: r,
    onAnchorChange: o
  }, n);
}, Uu = "PopperAnchor", Vu = /* @__PURE__ */ be((e, t) => {
  const { __scopePopper: n, virtualRef: r, ...o } = e, i = us(Uu, n), a = _(null), s = At(t, a);
  return Y(() => {
    i.onAnchorChange((r == null ? void 0 : r.current) || a.current);
  }), r ? null : /* @__PURE__ */ ee(ut.div, we({}, o, {
    ref: s
  }));
}), Tn = "PopperContent", [Hu, Yu] = fo(Tn), [qu, Ku] = fo(Tn, {
  hasParent: !1,
  positionUpdateFns: /* @__PURE__ */ new Set()
}), Gu = /* @__PURE__ */ be((e, t) => {
  var n, r, o, i, a, s, c, l;
  const { __scopePopper: u, side: f = "bottom", sideOffset: d = 0, align: p = "center", alignOffset: m = 0, arrowPadding: h = 0, collisionBoundary: v = [], collisionPadding: b = 0, sticky: y = "partial", hideWhenDetached: w = !1, avoidCollisions: x = !0, onPlaced: $, ...E } = e, O = us(Tn, u), [C, B] = oe(null), R = At(
    t,
    (nt) => B(nt)
  ), [T, A] = oe(null), M = Fu(T), Z = (n = M == null ? void 0 : M.width) !== null && n !== void 0 ? n : 0, G = (r = M == null ? void 0 : M.height) !== null && r !== void 0 ? r : 0, J = f + (p !== "center" ? "-" + p : ""), ie = typeof b == "number" ? b : {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...b
  }, ce = Array.isArray(v) ? v : [
    v
  ], he = ce.length > 0, S = {
    padding: ie,
    boundary: ce.filter(ef),
    // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
    altBoundary: he
  }, { reference: P, floating: H, strategy: U, x: N, y: q, placement: L, middlewareData: j, update: V } = ju({
    // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
    strategy: "fixed",
    placement: J,
    whileElementsMounted: ku,
    middleware: [
      tf(),
      Ou({
        mainAxis: d + G,
        alignmentAxis: m
      }),
      x ? Pu({
        mainAxis: !0,
        crossAxis: !1,
        limiter: y === "partial" ? Cu() : void 0,
        ...S
      }) : void 0,
      T ? Lu({
        element: T,
        padding: h
      }) : void 0,
      x ? Eu({
        ...S
      }) : void 0,
      _u({
        ...S,
        apply: ({ elements: nt, availableWidth: k, availableHeight: K }) => {
          nt.floating.style.setProperty("--radix-popper-available-width", `${k}px`), nt.floating.style.setProperty("--radix-popper-available-height", `${K}px`);
        }
      }),
      nf({
        arrowWidth: Z,
        arrowHeight: G
      }),
      w ? Su({
        strategy: "referenceHidden"
      }) : void 0
    ].filter(Ju)
  });
  ct(() => {
    P(O.anchor);
  }, [
    P,
    O.anchor
  ]);
  const Q = N !== null && q !== null, [X, me] = fs(L), I = Dt($);
  ct(() => {
    Q && (I == null || I());
  }, [
    Q,
    I
  ]);
  const ve = (o = j.arrow) === null || o === void 0 ? void 0 : o.x, ze = (i = j.arrow) === null || i === void 0 ? void 0 : i.y, Ue = ((a = j.arrow) === null || a === void 0 ? void 0 : a.centerOffset) !== 0, [$t, Kn] = oe();
  ct(() => {
    C && Kn(window.getComputedStyle(C).zIndex);
  }, [
    C
  ]);
  const { hasParent: Gn, positionUpdateFns: et } = Ku(Tn, u), tt = !Gn;
  Qe(() => {
    if (!tt)
      return et.add(V), () => {
        et.delete(V);
      };
  }, [
    tt,
    et,
    V
  ]), ct(() => {
    tt && Q && Array.from(et).reverse().forEach(
      (nt) => requestAnimationFrame(nt)
    );
  }, [
    tt,
    Q,
    et
  ]);
  const Nt = {
    "data-side": X,
    "data-align": me,
    ...E,
    ref: R,
    style: {
      ...E.style,
      // if the PopperContent hasn't been placed yet (not all measurements done)
      // we prevent animations so that users's animation don't kick in too early referring wrong sides
      animation: Q ? void 0 : "none",
      // hide the content if using the hide middleware and should be hidden
      opacity: (s = j.hide) !== null && s !== void 0 && s.referenceHidden ? 0 : void 0
    }
  };
  return /* @__PURE__ */ ee("div", {
    ref: H,
    "data-radix-popper-content-wrapper": "",
    style: {
      position: U,
      left: 0,
      top: 0,
      transform: Q ? `translate3d(${Math.round(N)}px, ${Math.round(q)}px, 0)` : "translate3d(0, -200%, 0)",
      // keep off the page when measuring
      minWidth: "max-content",
      zIndex: $t,
      "--radix-popper-transform-origin": [
        (c = j.transformOrigin) === null || c === void 0 ? void 0 : c.x,
        (l = j.transformOrigin) === null || l === void 0 ? void 0 : l.y
      ].join(" ")
    },
    dir: e.dir
  }, /* @__PURE__ */ ee(Hu, {
    scope: u,
    placedSide: X,
    onArrowChange: A,
    arrowX: ve,
    arrowY: ze,
    shouldHideArrow: Ue
  }, tt ? /* @__PURE__ */ ee(qu, {
    scope: u,
    hasParent: !0,
    positionUpdateFns: et
  }, /* @__PURE__ */ ee(ut.div, Nt)) : /* @__PURE__ */ ee(ut.div, Nt)));
}), Xu = "PopperArrow", Qu = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, Zu = /* @__PURE__ */ be(function(t, n) {
  const { __scopePopper: r, ...o } = t, i = Yu(Xu, r), a = Qu[i.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ ee("span", {
      ref: i.onArrowChange,
      style: {
        position: "absolute",
        left: i.arrowX,
        top: i.arrowY,
        [a]: 0,
        transformOrigin: {
          top: "",
          right: "0 0",
          bottom: "center 0",
          left: "100% 0"
        }[i.placedSide],
        transform: {
          top: "translateY(100%)",
          right: "translateY(50%) rotate(90deg) translateX(-50%)",
          bottom: "rotate(180deg)",
          left: "translateY(50%) rotate(-90deg) translateX(50%)"
        }[i.placedSide],
        visibility: i.shouldHideArrow ? "hidden" : void 0
      }
    }, /* @__PURE__ */ ee(Nu, we({}, o, {
      ref: n,
      style: {
        ...o.style,
        // ensures the element can be measured correctly (mostly for if SVG)
        display: "block"
      }
    })))
  );
});
function Ju(e) {
  return e !== void 0;
}
function ef(e) {
  return e !== null;
}
const tf = () => ({
  name: "anchorCssProperties",
  fn(e) {
    const { rects: t, elements: n } = e, { width: r, height: o } = t.reference;
    return n.floating.style.setProperty("--radix-popper-anchor-width", `${r}px`), n.floating.style.setProperty("--radix-popper-anchor-height", `${o}px`), {};
  }
}), nf = (e) => ({
  name: "transformOrigin",
  options: e,
  fn(t) {
    var n, r, o, i, a;
    const { placement: s, rects: c, middlewareData: l } = t, f = ((n = l.arrow) === null || n === void 0 ? void 0 : n.centerOffset) !== 0, d = f ? 0 : e.arrowWidth, p = f ? 0 : e.arrowHeight, [m, h] = fs(s), v = {
      start: "0%",
      center: "50%",
      end: "100%"
    }[h], b = ((r = (o = l.arrow) === null || o === void 0 ? void 0 : o.x) !== null && r !== void 0 ? r : 0) + d / 2, y = ((i = (a = l.arrow) === null || a === void 0 ? void 0 : a.y) !== null && i !== void 0 ? i : 0) + p / 2;
    let w = "", x = "";
    return m === "bottom" ? (w = f ? v : `${b}px`, x = `${-p}px`) : m === "top" ? (w = f ? v : `${b}px`, x = `${c.floating.height + p}px`) : m === "right" ? (w = `${-p}px`, x = f ? v : `${y}px`) : m === "left" && (w = `${c.floating.width + p}px`, x = f ? v : `${y}px`), {
      data: {
        x: w,
        y: x
      }
    };
  }
});
function fs(e) {
  const [t, n = "center"] = e.split("-");
  return [
    t,
    n
  ];
}
const rf = Wu, of = Vu, af = Gu, sf = Zu;
function cf(e, t) {
  return oo((n, r) => {
    const o = t[n][r];
    return o ?? n;
  }, e);
}
const ds = (e) => {
  const { present: t, children: n } = e, r = lf(t), o = typeof n == "function" ? n({
    present: r.isPresent
  }) : _t.only(n), i = At(r.ref, o.ref);
  return typeof n == "function" || r.isPresent ? /* @__PURE__ */ ro(o, {
    ref: i
  }) : null;
};
ds.displayName = "Presence";
function lf(e) {
  const [t, n] = oe(), r = _({}), o = _(e), i = _("none"), a = e ? "mounted" : "unmounted", [s, c] = cf(a, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return Y(() => {
    const l = pn(r.current);
    i.current = s === "mounted" ? l : "none";
  }, [
    s
  ]), ct(() => {
    const l = r.current, u = o.current;
    if (u !== e) {
      const d = i.current, p = pn(l);
      e ? c("MOUNT") : p === "none" || (l == null ? void 0 : l.display) === "none" ? c("UNMOUNT") : c(u && d !== p ? "ANIMATION_OUT" : "UNMOUNT"), o.current = e;
    }
  }, [
    e,
    c
  ]), ct(() => {
    if (t) {
      const l = (f) => {
        const p = pn(r.current).includes(f.animationName);
        f.target === t && p && ka(
          () => c("ANIMATION_END")
        );
      }, u = (f) => {
        f.target === t && (i.current = pn(r.current));
      };
      return t.addEventListener("animationstart", u), t.addEventListener("animationcancel", l), t.addEventListener("animationend", l), () => {
        t.removeEventListener("animationstart", u), t.removeEventListener("animationcancel", l), t.removeEventListener("animationend", l);
      };
    } else
      c("ANIMATION_END");
  }, [
    t,
    c
  ]), {
    isPresent: [
      "mounted",
      "unmountSuspended"
    ].includes(s),
    ref: W((l) => {
      l && (r.current = getComputedStyle(l)), n(l);
    }, [])
  };
}
function pn(e) {
  return (e == null ? void 0 : e.animationName) || "none";
}
function uf({ prop: e, defaultProp: t, onChange: n = () => {
} }) {
  const [r, o] = ff({
    defaultProp: t,
    onChange: n
  }), i = e !== void 0, a = i ? e : r, s = Dt(n), c = W((l) => {
    if (i) {
      const f = typeof l == "function" ? l(e) : l;
      f !== e && s(f);
    } else o(l);
  }, [
    i,
    e,
    o,
    s
  ]);
  return [
    a,
    c
  ];
}
function ff({ defaultProp: e, onChange: t }) {
  const n = oe(e), [r] = n, o = _(r), i = Dt(t);
  return Y(() => {
    o.current !== r && (i(r), o.current = r);
  }, [
    r,
    o,
    i
  ]), n;
}
const df = /* @__PURE__ */ be((e, t) => /* @__PURE__ */ ee(ut.span, we({}, e, {
  ref: t,
  style: {
    // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
    position: "absolute",
    border: 0,
    width: 1,
    height: 1,
    padding: 0,
    margin: -1,
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    wordWrap: "normal",
    ...e.style
  }
}))), pf = df, [Hn, Zm] = Qa("Tooltip", [
  ls
]), Yn = ls(), hf = "TooltipProvider", Wr = "tooltip.open", [Jm, po] = Hn(hf), ho = "Tooltip", [gf, qn] = Hn(ho), mf = (e) => {
  const { __scopeTooltip: t, children: n, open: r, defaultOpen: o = !1, onOpenChange: i, disableHoverableContent: a, delayDuration: s } = e, c = po(ho, e.__scopeTooltip), l = Yn(t), [u, f] = oe(null), d = vu(), p = _(0), m = a ?? c.disableHoverableContent, h = s ?? c.delayDuration, v = _(!1), [b = !1, y] = uf({
    prop: r,
    defaultProp: o,
    onChange: (O) => {
      O ? (c.onOpen(), document.dispatchEvent(new CustomEvent(Wr))) : c.onClose(), i == null || i(O);
    }
  }), w = ge(() => b ? v.current ? "delayed-open" : "instant-open" : "closed", [
    b
  ]), x = W(() => {
    window.clearTimeout(p.current), v.current = !1, y(!0);
  }, [
    y
  ]), $ = W(() => {
    window.clearTimeout(p.current), y(!1);
  }, [
    y
  ]), E = W(() => {
    window.clearTimeout(p.current), p.current = window.setTimeout(() => {
      v.current = !0, y(!0);
    }, h);
  }, [
    h,
    y
  ]);
  return Y(() => () => window.clearTimeout(p.current), []), /* @__PURE__ */ ee(rf, l, /* @__PURE__ */ ee(gf, {
    scope: t,
    contentId: d,
    open: b,
    stateAttribute: w,
    trigger: u,
    onTriggerChange: f,
    onTriggerEnter: W(() => {
      c.isOpenDelayed ? E() : x();
    }, [
      c.isOpenDelayed,
      E,
      x
    ]),
    onTriggerLeave: W(() => {
      m ? $() : window.clearTimeout(p.current);
    }, [
      $,
      m
    ]),
    onOpen: x,
    onClose: $,
    disableHoverableContent: m
  }, n));
}, ci = "TooltipTrigger", vf = /* @__PURE__ */ be((e, t) => {
  const { __scopeTooltip: n, ...r } = e, o = qn(ci, n), i = po(ci, n), a = Yn(n), s = _(null), c = At(t, s, o.onTriggerChange), l = _(!1), u = _(!1), f = W(
    () => l.current = !1,
    []
  );
  return Y(() => () => document.removeEventListener("pointerup", f), [
    f
  ]), /* @__PURE__ */ ee(of, we({
    asChild: !0
  }, a), /* @__PURE__ */ ee(ut.button, we({
    // We purposefully avoid adding `type=button` here because tooltip triggers are also
    // commonly anchors and the anchor `type` attribute signifies MIME type.
    "aria-describedby": o.open ? o.contentId : void 0,
    "data-state": o.stateAttribute
  }, r, {
    ref: c,
    onPointerMove: He(e.onPointerMove, (d) => {
      d.pointerType !== "touch" && !u.current && !i.isPointerInTransitRef.current && (o.onTriggerEnter(), u.current = !0);
    }),
    onPointerLeave: He(e.onPointerLeave, () => {
      o.onTriggerLeave(), u.current = !1;
    }),
    onPointerDown: He(e.onPointerDown, () => {
      l.current = !0, document.addEventListener("pointerup", f, {
        once: !0
      });
    }),
    onFocus: He(e.onFocus, () => {
      l.current || o.onOpen();
    }),
    onBlur: He(e.onBlur, o.onClose),
    onClick: He(e.onClick, o.onClose)
  })));
}), bf = "TooltipPortal", [e0, yf] = Hn(bf, {
  forceMount: void 0
}), Jt = "TooltipContent", wf = /* @__PURE__ */ be((e, t) => {
  const n = yf(Jt, e.__scopeTooltip), { forceMount: r = n.forceMount, side: o = "top", ...i } = e, a = qn(Jt, e.__scopeTooltip);
  return /* @__PURE__ */ ee(ds, {
    present: r || a.open
  }, a.disableHoverableContent ? /* @__PURE__ */ ee(ps, we({
    side: o
  }, i, {
    ref: t
  })) : /* @__PURE__ */ ee($f, we({
    side: o
  }, i, {
    ref: t
  })));
}), $f = /* @__PURE__ */ be((e, t) => {
  const n = qn(Jt, e.__scopeTooltip), r = po(Jt, e.__scopeTooltip), o = _(null), i = At(t, o), [a, s] = oe(null), { trigger: c, onClose: l } = n, u = o.current, { onPointerInTransitChange: f } = r, d = W(() => {
    s(null), f(!1);
  }, [
    f
  ]), p = W((m, h) => {
    const v = m.currentTarget, b = {
      x: m.clientX,
      y: m.clientY
    }, y = Pf(b, v.getBoundingClientRect()), w = y === "right" || y === "bottom" ? -5 : 5, $ = y === "right" || y === "left" ? {
      x: m.clientX + w,
      y: m.clientY
    } : {
      x: m.clientX,
      y: m.clientY + w
    }, E = Cf(h.getBoundingClientRect()), O = Tf([
      $,
      ...E
    ]);
    s(O), f(!0);
  }, [
    f
  ]);
  return Y(() => () => d(), [
    d
  ]), Y(() => {
    if (c && u) {
      const m = (v) => p(v, u), h = (v) => p(v, c);
      return c.addEventListener("pointerleave", m), u.addEventListener("pointerleave", h), () => {
        c.removeEventListener("pointerleave", m), u.removeEventListener("pointerleave", h);
      };
    }
  }, [
    c,
    u,
    p,
    d
  ]), Y(() => {
    if (a) {
      const m = (h) => {
        const v = h.target, b = {
          x: h.clientX,
          y: h.clientY
        }, y = (c == null ? void 0 : c.contains(v)) || (u == null ? void 0 : u.contains(v)), w = !_f(b, a);
        y ? d() : w && (d(), l());
      };
      return document.addEventListener("pointermove", m), () => document.removeEventListener("pointermove", m);
    }
  }, [
    c,
    u,
    a,
    l,
    d
  ]), /* @__PURE__ */ ee(ps, we({}, e, {
    ref: i
  }));
}), [xf, Ef] = Hn(ho, {
  isInside: !1
}), ps = /* @__PURE__ */ be((e, t) => {
  const { __scopeTooltip: n, children: r, "aria-label": o, onEscapeKeyDown: i, onPointerDownOutside: a, ...s } = e, c = qn(Jt, n), l = Yn(n), { onClose: u } = c;
  return Y(() => (document.addEventListener(Wr, u), () => document.removeEventListener(Wr, u)), [
    u
  ]), Y(() => {
    if (c.trigger) {
      const f = (d) => {
        const p = d.target;
        p != null && p.contains(c.trigger) && u();
      };
      return window.addEventListener("scroll", f, {
        capture: !0
      }), () => window.removeEventListener("scroll", f, {
        capture: !0
      });
    }
  }, [
    c.trigger,
    u
  ]), /* @__PURE__ */ ee(du, {
    asChild: !0,
    disableOutsidePointerEvents: !1,
    onEscapeKeyDown: i,
    onPointerDownOutside: a,
    onFocusOutside: (f) => f.preventDefault(),
    onDismiss: u
  }, /* @__PURE__ */ ee(af, we({
    "data-state": c.stateAttribute
  }, l, s, {
    ref: t,
    style: {
      ...s.style,
      "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
      "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
      "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
    }
  }), /* @__PURE__ */ ee(za, null, r), /* @__PURE__ */ ee(xf, {
    scope: n,
    isInside: !0
  }, /* @__PURE__ */ ee(pf, {
    id: c.contentId,
    role: "tooltip"
  }, o || r))));
}), Sf = "TooltipArrow", Of = /* @__PURE__ */ be((e, t) => {
  const { __scopeTooltip: n, ...r } = e, o = Yn(n);
  return Ef(Sf, n).isInside ? null : /* @__PURE__ */ ee(sf, we({}, o, r, {
    ref: t
  }));
});
function Pf(e, t) {
  const n = Math.abs(t.top - e.y), r = Math.abs(t.bottom - e.y), o = Math.abs(t.right - e.x), i = Math.abs(t.left - e.x);
  switch (Math.min(n, r, o, i)) {
    case i:
      return "left";
    case o:
      return "right";
    case n:
      return "top";
    case r:
      return "bottom";
    default:
      return null;
  }
}
function Cf(e) {
  const { top: t, right: n, bottom: r, left: o } = e;
  return [
    {
      x: o,
      y: t
    },
    {
      x: n,
      y: t
    },
    {
      x: n,
      y: r
    },
    {
      x: o,
      y: r
    }
  ];
}
function _f(e, t) {
  const { x: n, y: r } = e;
  let o = !1;
  for (let i = 0, a = t.length - 1; i < t.length; a = i++) {
    const s = t[i].x, c = t[i].y, l = t[a].x, u = t[a].y;
    c > r != u > r && n < (l - s) * (r - c) / (u - c) + s && (o = !o);
  }
  return o;
}
function Tf(e) {
  const t = e.slice();
  return t.sort((n, r) => n.x < r.x ? -1 : n.x > r.x ? 1 : n.y < r.y ? -1 : n.y > r.y ? 1 : 0), Rf(t);
}
function Rf(e) {
  if (e.length <= 1) return e.slice();
  const t = [];
  for (let r = 0; r < e.length; r++) {
    const o = e[r];
    for (; t.length >= 2; ) {
      const i = t[t.length - 1], a = t[t.length - 2];
      if ((i.x - a.x) * (o.y - a.y) >= (i.y - a.y) * (o.x - a.x)) t.pop();
      else break;
    }
    t.push(o);
  }
  t.pop();
  const n = [];
  for (let r = e.length - 1; r >= 0; r--) {
    const o = e[r];
    for (; n.length >= 2; ) {
      const i = n[n.length - 1], a = n[n.length - 2];
      if ((i.x - a.x) * (o.y - a.y) >= (i.y - a.y) * (o.x - a.x)) n.pop();
      else break;
    }
    n.push(o);
  }
  return n.pop(), t.length === 1 && n.length === 1 && t[0].x === n[0].x && t[0].y === n[0].y ? t : t.concat(n);
}
const If = mf, Af = vf, kf = wf, Df = Of;
function Mf(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function se(e, t) {
  if (e == null) return {};
  var n = Mf(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
let fe;
(function(e) {
  e[e.UNSUPPORTED_INPUT = 0] = "UNSUPPORTED_INPUT", e[e.NO_COMPONENT_FOR_TYPE = 1] = "NO_COMPONENT_FOR_TYPE", e[e.UNKNOWN_INPUT = 2] = "UNKNOWN_INPUT", e[e.DUPLICATE_KEYS = 3] = "DUPLICATE_KEYS", e[e.ALREADY_REGISTERED_TYPE = 4] = "ALREADY_REGISTERED_TYPE", e[e.CLIPBOARD_ERROR = 5] = "CLIPBOARD_ERROR", e[e.THEME_ERROR = 6] = "THEME_ERROR", e[e.PATH_DOESNT_EXIST = 7] = "PATH_DOESNT_EXIST", e[e.INPUT_TYPE_OVERRIDE = 8] = "INPUT_TYPE_OVERRIDE", e[e.EMPTY_KEY = 9] = "EMPTY_KEY";
})(fe || (fe = {}));
const jf = {
  [fe.UNSUPPORTED_INPUT]: (e, t) => [`An input with type \`${e}\` input was found at path \`${t}\` but it's not supported yet.`],
  [fe.NO_COMPONENT_FOR_TYPE]: (e, t) => [`Type \`${e}\` found at path \`${t}\` can't be displayed in panel because no component supports it yet.`],
  [fe.UNKNOWN_INPUT]: (e, t) => [`input at path \`${e}\` is not recognized.`, t],
  [fe.DUPLICATE_KEYS]: (e, t, n) => [`Key \`${e}\` of path \`${t}\` already exists at path \`${n}\`. Even nested keys need to be unique. Rename one of the keys.`],
  [fe.ALREADY_REGISTERED_TYPE]: (e) => [`Type ${e} has already been registered. You can't register a component with the same type.`],
  [fe.CLIPBOARD_ERROR]: (e) => ["Error copying the value", e],
  [fe.THEME_ERROR]: (e, t) => [`Error accessing the theme \`${e}.${t}\` value.`],
  [fe.PATH_DOESNT_EXIST]: (e) => [`Error getting the value at path \`${e}\`. There is probably an error in your \`render\` function.`],
  [fe.PATH_DOESNT_EXIST]: (e) => [`Error accessing the value at path \`${e}\``],
  [fe.INPUT_TYPE_OVERRIDE]: (e, t, n) => [`Input at path \`${e}\` already exists with type: \`${t}\`. Its type cannot be overridden with type \`${n}\`.`],
  [fe.EMPTY_KEY]: () => ["Keys can not be empty, if you want to hide a label use whitespace."]
};
function hs(e, t, ...n) {
  const [r, ...o] = jf[t](...n);
  console[e]("LEVA: " + r, ...o);
}
const Ye = hs.bind(null, "warn"), Lf = hs.bind(null, "log"), zf = ["value"], Nf = ["schema"], Ff = ["value"], gs = [], bt = {};
function li(e) {
  let {
    value: t
  } = e, n = se(e, zf);
  for (let r of gs) {
    const o = r(t, n);
    if (o) return o;
  }
}
function Je(e, t) {
  let {
    schema: n
  } = t, r = se(t, Nf);
  if (e in bt) {
    Ye(fe.ALREADY_REGISTERED_TYPE, e);
    return;
  }
  gs.push((o, i) => n(o, i) && e), bt[e] = r;
}
function ir(e, t, n, r) {
  const {
    normalize: o
  } = bt[e];
  if (o) return o(t, n, r);
  if (typeof t != "object" || !("value" in t)) return {
    value: t
  };
  const {
    value: i
  } = t, a = se(t, Ff);
  return {
    value: i,
    settings: a
  };
}
function Bf(e, t, n, r, o, i) {
  const {
    sanitize: a
  } = bt[e];
  return a ? a(t, n, r, o, i) : t;
}
function ui(e, t, n) {
  const {
    format: r
  } = bt[e];
  return r ? r(t, n) : t;
}
function Wf(e, t, n) {
  return t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function fi(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function F(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fi(Object(n), !0).forEach(function(r) {
      Wf(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fi(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
const dt = (e, t, n) => e > n ? n : e < t ? t : e, Uf = (e) => {
  if (e === "" || typeof e == "number") return e;
  try {
    const t = st(e);
    if (!isNaN(t)) return t;
  } catch {
  }
  return parseFloat(e);
}, Vf = Math.log(10);
function di(e) {
  let t = Math.abs(+String(e).replace(".", ""));
  if (t === 0) return 0.01;
  for (; t !== 0 && t % 10 === 0; ) t /= 10;
  const n = Math.floor(Math.log(t) / Vf) + 1, r = Math.floor(Math.log10(Math.abs(e))), o = Math.pow(10, r - n);
  return Math.max(o, 1e-3);
}
const Rn = (e, t, n) => n === t ? 0 : (dt(e, t, n) - t) / (n - t), In = (e, t, n) => e * (n - t) + t, Hf = () => "_" + Math.random().toString(36).substr(2, 9), pi = /\(([0-9+\-*/^ .]+)\)/, hi = /(\d+(?:\.\d+)?) ?\^ ?(\d+(?:\.\d+)?)/, gi = /(\d+(?:\.\d+)?) ?\* ?(\d+(?:\.\d+)?)/, mi = /(\d+(?:\.\d+)?) ?\/ ?(\d+(?:\.\d+)?)/, vi = /(\d+(?:\.\d+)?) ?\+ ?(\d+(?:\.\d+)?)/, bi = /(\d+(?:\.\d+)?) ?- ?(\d+(?:\.\d+)?)/;
function st(e) {
  if (isNaN(Number(e)))
    if (pi.test(e)) {
      const t = e.replace(pi, (n, r) => String(st(r)));
      return st(t);
    } else if (hi.test(e)) {
      const t = e.replace(hi, (n, r, o) => String(Math.pow(Number(r), Number(o))));
      return st(t);
    } else if (gi.test(e)) {
      const t = e.replace(gi, (n, r, o) => String(Number(r) * Number(o)));
      return st(t);
    } else if (mi.test(e)) {
      const t = e.replace(mi, (n, r, o) => {
        if (o != 0) return String(Number(r) / Number(o));
        throw new Error("Division by zero");
      });
      return st(t);
    } else if (vi.test(e)) {
      const t = e.replace(vi, (n, r, o) => String(Number(r) + Number(o)));
      return st(t);
    } else if (bi.test(e)) {
      const t = e.replace(bi, (n, r, o) => String(Number(r) - Number(o)));
      return st(t);
    } else
      return Number(e);
  return Number(e);
}
function Yf(e, t) {
  return t.reduce((n, r) => (e && e.hasOwnProperty(r) && (n[r] = e[r]), n), {});
}
function qf(e, t) {
  const n = F({}, e);
  return t.forEach((r) => r in e && delete n[r]), n;
}
function Kf(e, t) {
  return e.reduce((n, r, o) => Object.assign(n, {
    [t[o]]: r
  }), {});
}
function ms(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
const Gf = (e) => ms(e) && Object.keys(e).length === 0;
let ke;
(function(e) {
  e.BUTTON = "BUTTON", e.BUTTON_GROUP = "BUTTON_GROUP", e.MONITOR = "MONITOR", e.FOLDER = "FOLDER";
})(ke || (ke = {}));
let je;
(function(e) {
  e.SELECT = "SELECT", e.IMAGE = "IMAGE", e.NUMBER = "NUMBER", e.COLOR = "COLOR", e.STRING = "STRING", e.BOOLEAN = "BOOLEAN", e.INTERVAL = "INTERVAL", e.VECTOR3D = "VECTOR3D", e.VECTOR2D = "VECTOR2D";
})(je || (je = {}));
const Xf = ["type", "__customInput"], Qf = ["render", "label", "optional", "order", "disabled", "hint", "onChange", "onEditStart", "onEditEnd", "transient"], Zf = ["type"];
function vs(e, t, n = {}, r) {
  var o, i;
  if (typeof e != "object" || Array.isArray(e))
    return {
      type: r,
      input: e,
      options: F({
        key: t,
        label: t,
        optional: !1,
        disabled: !1,
        order: 0
      }, n)
    };
  if ("__customInput" in e) {
    const {
      type: $,
      __customInput: E
    } = e, O = se(e, Xf);
    return vs(E, t, O, $);
  }
  const {
    render: a,
    label: s,
    optional: c,
    order: l = 0,
    disabled: u,
    hint: f,
    onChange: d,
    onEditStart: p,
    onEditEnd: m,
    transient: h
  } = e, v = se(e, Qf), b = F({
    render: a,
    key: t,
    label: s ?? t,
    hint: f,
    transient: h ?? !!d,
    onEditStart: p,
    onEditEnd: m,
    disabled: u,
    optional: c,
    order: l
  }, n);
  let {
    type: y
  } = v, w = se(v, Zf);
  if (y = r ?? y, y in ke)
    return {
      type: y,
      input: w,
      options: b
    };
  let x;
  return r && ms(w) && "value" in w ? x = w.value : x = Gf(w) ? void 0 : w, {
    type: y,
    input: x,
    options: F(F({}, b), {}, {
      onChange: d,
      optional: (o = b.optional) !== null && o !== void 0 ? o : !1,
      disabled: (i = b.disabled) !== null && i !== void 0 ? i : !1
    })
  };
}
function Jf(e, t, n, r) {
  const o = vs(e, t), {
    type: i,
    input: a,
    options: s
  } = o;
  if (i)
    return i in ke ? o : {
      type: i,
      input: ir(i, a, n, r),
      options: s
    };
  let c = li(a);
  return c ? {
    type: c,
    input: ir(c, a, n, r),
    options: s
  } : (c = li({
    value: a
  }), c ? {
    type: c,
    input: ir(c, {
      value: a
    }, n, r),
    options: s
  } : !1);
}
function yi(e, t, n, r, o) {
  const {
    value: i,
    type: a,
    settings: s
  } = e;
  e.value = bs({
    type: a,
    value: i,
    settings: s
  }, t, n, r), e.fromPanel = o;
}
const ed = function(t, n, r) {
  this.type = "LEVA_ERROR", this.message = "LEVA: " + t, this.previousValue = n, this.error = r;
};
function bs({
  type: e,
  value: t,
  settings: n
}, r, o, i) {
  const a = e !== "SELECT" && typeof r == "function" ? r(t) : r;
  let s;
  try {
    s = Bf(e, a, n, t, o, i);
  } catch (c) {
    throw new ed(`The value \`${r}\` did not result in a correct value.`, t, c);
  }
  return Xt(s, t) ? t : s;
}
const ys = (e, t, n = !1) => {
  let r = 0;
  return function() {
    const o = arguments, i = n && !r, a = () => e.apply(this, o);
    window.clearTimeout(r), r = window.setTimeout(a, t), i && a();
  };
}, ws = (e) => e.shiftKey ? 5 : e.altKey ? 1 / 5 : 1, td = ["value"], nd = ["min", "max"], rd = (e) => {
  if (typeof e == "number") return !0;
  if (typeof e == "string") {
    const t = parseFloat(e);
    return isNaN(t) ? !1 : e.substring(("" + t).length).trim().length < 4;
  }
  return !1;
}, $s = (e, {
  min: t = -1 / 0,
  max: n = 1 / 0,
  suffix: r
}) => {
  const o = parseFloat(e);
  if (e === "" || isNaN(o)) throw Error("Invalid number");
  const i = dt(o, t, n);
  return r ? i + r : i;
}, od = (e, {
  pad: t = 0,
  suffix: n
}) => {
  const r = parseFloat(e).toFixed(t);
  return n ? r + n : r;
}, xs = (e) => {
  let {
    value: t
  } = e, n = se(e, td);
  const {
    min: r = -1 / 0,
    max: o = 1 / 0
  } = n, i = se(n, nd);
  let a = parseFloat(t);
  const s = typeof t == "string" ? t.substring(("" + a).length) : void 0;
  a = dt(a, r, o);
  let c = n.step;
  c || (Number.isFinite(r) ? Number.isFinite(o) ? c = +(Math.abs(o - r) / 100).toPrecision(1) : c = +(Math.abs(a - r) / 100).toPrecision(1) : Number.isFinite(o) && (c = +(Math.abs(o - a) / 100).toPrecision(1)));
  const l = c ? di(c) * 10 : di(a);
  c = c || l / 10;
  const u = Math.round(dt(Math.log10(1 / l), 0, 2));
  return {
    value: s ? a + s : a,
    settings: F({
      initialValue: a,
      step: c,
      pad: u,
      min: r,
      max: o,
      suffix: s
    }, i)
  };
}, Es = (e, {
  step: t,
  initialValue: n
}) => {
  const r = Math.round((e - n) / t);
  return n + r * t;
};
var Ss = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  schema: rd,
  sanitize: $s,
  format: od,
  normalize: xs,
  sanitizeStep: Es
});
function pe() {
  return pe = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, pe.apply(this, arguments);
}
const Os = vt({});
function Ee() {
  return yt(Os);
}
const go = vt(null), Ps = vt(null), Cs = vt(null);
function on() {
  return yt(Ps);
}
function id() {
  return yt(Cs);
}
const _s = () => ({
  colors: {
    elevation1: "#292d39",
    elevation2: "#181c20",
    elevation3: "#373c4b",
    accent1: "#0066dc",
    accent2: "#007bff",
    accent3: "#3c93ff",
    highlight1: "#535760",
    highlight2: "#8c92a4",
    highlight3: "#fefefe",
    vivid1: "#ffcc00",
    folderWidgetColor: "$highlight2",
    folderTextColor: "$highlight3",
    toolTipBackground: "$highlight3",
    toolTipText: "$elevation2"
  },
  radii: {
    xs: "2px",
    sm: "3px",
    lg: "10px"
  },
  space: {
    xs: "3px",
    sm: "6px",
    md: "10px",
    rowGap: "7px",
    colGap: "7px"
  },
  fonts: {
    mono: "ui-monospace, SFMono-Regular, Menlo, 'Roboto Mono', monospace",
    sans: "system-ui, sans-serif"
  },
  fontSizes: {
    root: "11px",
    toolTip: "$root"
  },
  sizes: {
    rootWidth: "280px",
    controlWidth: "160px",
    numberInputMinWidth: "38px",
    scrubberWidth: "8px",
    scrubberHeight: "16px",
    rowHeight: "24px",
    folderTitleHeight: "20px",
    checkboxSize: "16px",
    joystickWidth: "100px",
    joystickHeight: "100px",
    colorPickerWidth: "$controlWidth",
    colorPickerHeight: "100px",
    imagePreviewWidth: "$controlWidth",
    imagePreviewHeight: "100px",
    monitorHeight: "60px",
    titleBarHeight: "39px"
  },
  shadows: {
    level1: "0 0 9px 0 #00000088",
    level2: "0 4px 14px #00000033"
  },
  borderWidths: {
    root: "0px",
    input: "1px",
    focus: "1px",
    hover: "1px",
    active: "1px",
    folder: "1px"
  },
  fontWeights: {
    label: "normal",
    folder: "normal",
    button: "normal"
  }
});
function hn(e, t) {
  const [n, r] = e.split(" "), o = {};
  return n !== "none" && (o.boxShadow = `${t.inset ? "inset " : ""}0 0 0 $borderWidths${[t.key]} $colors${n !== "default" && n || t.borderColor}`), r && (o.backgroundColor = r), o;
}
const Wt = {
  $inputStyle: () => (e) => hn(e, {
    key: "$input",
    borderColor: "$highlight1",
    inset: !0
  }),
  $focusStyle: () => (e) => hn(e, {
    key: "$focus",
    borderColor: "$accent2"
  }),
  $hoverStyle: () => (e) => hn(e, {
    key: "$hover",
    borderColor: "$accent1",
    inset: !0
  }),
  $activeStyle: () => (e) => hn(e, {
    key: "$active",
    borderColor: "$accent1",
    inset: !0
  })
}, {
  styled: z,
  css: t0,
  createTheme: ad,
  globalCss: sd,
  keyframes: n0
} = gl({
  prefix: "leva",
  theme: _s(),
  utils: F(F({}, Wt), {}, {
    $flex: () => ({
      display: "flex",
      alignItems: "center"
    }),
    $flexCenter: () => ({
      display: "flex",
      alignItems: "center",
      justifyContent: "center"
    }),
    $reset: () => ({
      outline: "none",
      fontSize: "inherit",
      fontWeight: "inherit",
      color: "inherit",
      fontFamily: "inherit",
      border: "none",
      backgroundColor: "transparent",
      appearance: "none"
    }),
    $draggable: () => ({
      touchAction: "none",
      WebkitUserDrag: "none",
      userSelect: "none"
    }),
    $focus: (e) => ({
      "&:focus": Wt.$focusStyle()(e)
    }),
    $focusWithin: (e) => ({
      "&:focus-within": Wt.$focusStyle()(e)
    }),
    $hover: (e) => ({
      "&:hover": Wt.$hoverStyle()(e)
    }),
    $active: (e) => ({
      "&:active": Wt.$activeStyle()(e)
    })
  })
}), cd = sd({
  ".leva__panel__dragged": {
    WebkitUserDrag: "none",
    userSelect: "none",
    input: {
      userSelect: "none"
    },
    "*": {
      cursor: "ew-resize !important"
    }
  }
});
function ld(e) {
  const t = _s();
  if (!e) return {
    theme: t,
    className: ""
  };
  Object.keys(e).forEach((r) => {
    Object.assign(t[r], e[r]);
  });
  const n = ad(t);
  return {
    theme: t,
    className: n.className
  };
}
function Ge(e, t) {
  const {
    theme: n
  } = yt(go);
  if (!(e in n) || !(t in n[e]))
    return Ye(fe.THEME_ERROR, e, t), "";
  let r = t;
  for (; ; ) {
    let o = n[e][r];
    if (typeof o == "string" && o.charAt(0) === "$") r = o.substr(1);
    else return o;
  }
}
const Ts = z("input", {
  $reset: "",
  padding: "0 $sm",
  width: 0,
  minWidth: 0,
  flex: 1,
  height: "100%",
  variants: {
    levaType: {
      number: {
        textAlign: "right"
      }
    },
    as: {
      textarea: {
        padding: "$sm"
      }
    }
  }
}), Rs = z("div", {
  $draggable: "",
  height: "100%",
  $flexCenter: "",
  position: "relative",
  padding: "0 $xs",
  fontSize: "0.8em",
  opacity: 0.8,
  cursor: "default",
  touchAction: "none",
  [`& + ${Ts}`]: {
    paddingLeft: 0
  }
}), ud = z(Rs, {
  cursor: "ew-resize",
  marginRight: "-$xs",
  textTransform: "uppercase",
  opacity: 0.3,
  "&:hover": {
    opacity: 1
  },
  variants: {
    dragging: {
      true: {
        backgroundColor: "$accent2",
        opacity: 1
      }
    }
  }
}), fd = z("div", {
  $flex: "",
  position: "relative",
  borderRadius: "$sm",
  overflow: "hidden",
  color: "inherit",
  height: "$rowHeight",
  backgroundColor: "$elevation3",
  $inputStyle: "$elevation1",
  $hover: "",
  $focusWithin: "",
  variants: {
    textArea: {
      true: {
        height: "auto"
      }
    }
  }
}), dd = ["innerLabel", "value", "onUpdate", "onChange", "onKeyDown", "type", "id", "inputType", "rows"], pd = ["onUpdate"];
function mo(e) {
  let {
    innerLabel: t,
    value: n,
    onUpdate: r,
    onChange: o,
    onKeyDown: i,
    type: a,
    id: s,
    inputType: c = "text",
    rows: l = 0
  } = e, u = se(e, dd);
  const {
    id: f,
    emitOnEditStart: d,
    emitOnEditEnd: p,
    disabled: m
  } = Ee(), h = s || f, v = _(null), b = l > 0, y = b ? "textarea" : "input", w = W((E) => (O) => {
    const C = O.currentTarget.value;
    E(C);
  }, []);
  g.useEffect(() => {
    const E = v.current, O = w((C) => {
      r(C), p();
    });
    return E == null || E.addEventListener("blur", O), () => E == null ? void 0 : E.removeEventListener("blur", O);
  }, [w, r, p]);
  const x = W((E) => {
    E.key === "Enter" && w(r)(E);
  }, [w, r]), $ = Object.assign({
    as: y
  }, b ? {
    rows: l
  } : {}, u);
  return g.createElement(fd, {
    textArea: b
  }, t && typeof t == "string" ? g.createElement(Rs, null, t) : t, g.createElement(Ts, pe({
    levaType: a,
    ref: v,
    id: h,
    type: c,
    autoComplete: "off",
    spellCheck: "false",
    value: n,
    onChange: w(o),
    onFocus: () => d(),
    onKeyPress: x,
    onKeyDown: i,
    disabled: m
  }, $)));
}
function hd(e) {
  let {
    onUpdate: t
  } = e, n = se(e, pd);
  const r = W((i) => t(Uf(i)), [t]), o = W((i) => {
    const a = i.key === "ArrowUp" ? 1 : i.key === "ArrowDown" ? -1 : 0;
    if (a) {
      i.preventDefault();
      const s = i.altKey ? 0.1 : i.shiftKey ? 10 : 1;
      t((c) => parseFloat(c) + a * s);
    }
  }, [t]);
  return g.createElement(mo, pe({}, n, {
    onUpdate: r,
    onKeyDown: o,
    type: "number"
  }));
}
const An = z("div", {}), Ur = z("div", {
  position: "relative",
  background: "$elevation2",
  transition: "height 300ms ease",
  variants: {
    fill: {
      true: {},
      false: {}
    },
    flat: {
      false: {},
      true: {}
    },
    isRoot: {
      true: {},
      false: {
        paddingLeft: "$md",
        "&::after": {
          content: '""',
          position: "absolute",
          left: 0,
          top: 0,
          width: "$borderWidths$folder",
          height: "100%",
          backgroundColor: "$folderWidgetColor",
          opacity: 0.4,
          transform: "translateX(-50%)"
        }
      }
    }
  },
  compoundVariants: [{
    isRoot: !0,
    fill: !1,
    css: {
      overflowY: "auto",
      maxHeight: "calc(100vh - 20px - $$titleBarHeight)"
    }
  }, {
    isRoot: !0,
    flat: !1,
    css: {
      borderRadius: "$lg"
    }
  }]
}), gd = z("div", {
  $flex: "",
  color: "$folderTextColor",
  userSelect: "none",
  cursor: "pointer",
  height: "$folderTitleHeight",
  fontWeight: "$folder",
  "> svg": {
    marginLeft: -4,
    marginRight: 4,
    cursor: "pointer",
    fill: "$folderWidgetColor",
    opacity: 0.6
  },
  "&:hover > svg": {
    fill: "$folderWidgetColor"
  },
  [`&:hover + ${Ur}::after`]: {
    opacity: 0.6
  },
  [`${An}:hover > & + ${Ur}::after`]: {
    opacity: 0.6
  },
  [`${An}:hover > & > svg`]: {
    opacity: 1
  }
}), Is = z("div", {
  position: "relative",
  display: "grid",
  gridTemplateColumns: "100%",
  rowGap: "$rowGap",
  transition: "opacity 250ms ease",
  variants: {
    toggled: {
      true: {
        opacity: 1,
        transitionDelay: "250ms"
      },
      false: {
        opacity: 0,
        transitionDelay: "0ms",
        pointerEvents: "none"
      }
    },
    isRoot: {
      true: {
        "& > div": {
          paddingLeft: "$md",
          paddingRight: "$md"
        },
        "& > div:first-of-type": {
          paddingTop: "$sm"
        },
        "& > div:last-of-type": {
          paddingBottom: "$sm"
        },
        [`> ${An}:not(:first-of-type)`]: {
          paddingTop: "$sm",
          marginTop: "$md",
          borderTop: "$borderWidths$folder solid $colors$elevation1"
        }
      }
    }
  }
}), As = z("div", {
  position: "relative",
  zIndex: 100,
  display: "grid",
  rowGap: "$rowGap",
  gridTemplateRows: "minmax($sizes$rowHeight, max-content)",
  alignItems: "center",
  color: "$highlight2",
  [`${Is} > &`]: {
    "&:first-of-type": {
      marginTop: "$rowGap"
    },
    "&:last-of-type": {
      marginBottom: "$rowGap"
    }
  },
  variants: {
    disabled: {
      true: {
        pointerEvents: "none"
      },
      false: {
        "&:hover,&:focus-within": {
          color: "$highlight3"
        }
      }
    }
  }
}), ks = z(As, {
  gridTemplateColumns: "auto $sizes$controlWidth",
  columnGap: "$colGap"
}), md = z("div", {
  $flex: "",
  height: "100%",
  position: "relative",
  overflow: "hidden",
  "& > div": {
    marginLeft: "$colGap",
    padding: "0 $xs",
    opacity: 0.4
  },
  "& > div:hover": {
    opacity: 0.8
  },
  "& > div > svg": {
    display: "none",
    cursor: "pointer",
    width: 13,
    minWidth: 13,
    height: 13,
    backgroundColor: "$elevation2"
  },
  "&:hover > div > svg": {
    display: "block"
  },
  variants: {
    align: {
      top: {
        height: "100%",
        alignItems: "flex-start",
        paddingTop: "$sm"
      }
    }
  }
}), vd = z("input", {
  $reset: "",
  height: 0,
  width: 0,
  opacity: 0,
  margin: 0,
  "& + label": {
    position: "relative",
    $flexCenter: "",
    height: "100%",
    userSelect: "none",
    cursor: "pointer",
    paddingLeft: 2,
    paddingRight: "$sm",
    pointerEvents: "auto"
  },
  "& + label:after": {
    content: '""',
    width: 6,
    height: 6,
    backgroundColor: "$elevation3",
    borderRadius: "50%",
    $activeStyle: ""
  },
  "&:focus + label:after": {
    $focusStyle: ""
  },
  "& + label:active:after": {
    backgroundColor: "$accent1",
    $focusStyle: ""
  },
  "&:checked + label:after": {
    backgroundColor: "$accent1"
  }
}), Vr = z("label", {
  fontWeight: "$label",
  overflow: "hidden",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap",
  "& > svg": {
    display: "block"
  }
}), bd = z("div", {
  opacity: 1,
  variants: {
    disabled: {
      true: {
        opacity: 0.6,
        pointerEvents: "none",
        [`& ${Vr}`]: {
          pointerEvents: "auto"
        }
      }
    }
  }
}), Ds = z("div", {
  position: "fixed",
  top: 0,
  bottom: 0,
  right: 0,
  left: 0,
  zIndex: 1e3,
  userSelect: "none"
}), yd = z("div", {
  background: "$toolTipBackground",
  fontFamily: "$sans",
  fontSize: "$toolTip",
  padding: "$xs $sm",
  color: "$toolTipText",
  borderRadius: "$xs",
  boxShadow: "$level2",
  maxWidth: 260
}), wd = z(Df, {
  fill: "$toolTipBackground"
});
function vo({
  children: e
}) {
  const {
    className: t
  } = yt(go);
  return g.createElement(Lc, {
    className: t
  }, e);
}
const $d = ["align"];
function xd() {
  const {
    id: e,
    disable: t,
    disabled: n
  } = Ee();
  return g.createElement(g.Fragment, null, g.createElement(vd, {
    id: e + "__disable",
    type: "checkbox",
    checked: !n,
    onChange: () => t(!n)
  }), g.createElement("label", {
    htmlFor: e + "__disable"
  }));
}
function Ed(e) {
  const {
    id: t,
    optional: n,
    hint: r
  } = Ee(), o = e.htmlFor || (t ? {
    htmlFor: t
  } : null), i = !r && typeof e.children == "string" ? {
    title: e.children
  } : null;
  return g.createElement(g.Fragment, null, n && g.createElement(xd, null), r !== void 0 ? g.createElement(If, null, g.createElement(Af, {
    asChild: !0
  }, g.createElement(Vr, pe({}, o, e))), g.createElement(kf, {
    side: "top",
    sideOffset: 2
  }, g.createElement(yd, null, r, g.createElement(wd, null)))) : g.createElement(Vr, pe({}, o, i, e)));
}
function Le(e) {
  let {
    align: t
  } = e, n = se(e, $d);
  const {
    value: r,
    label: o,
    key: i,
    disabled: a
  } = Ee(), {
    hideCopyButton: s
  } = id(), c = !s && i !== void 0, [l, u] = oe(!1), f = async () => {
    try {
      await navigator.clipboard.writeText(JSON.stringify({
        [i]: r ?? ""
      })), u(!0);
    } catch {
      Ye(fe.CLIPBOARD_ERROR, {
        [i]: r
      });
    }
  };
  return g.createElement(md, {
    align: t,
    onPointerLeave: () => u(!1)
  }, g.createElement(Ed, n), c && !a && g.createElement("div", {
    title: `Click to copy ${typeof o == "string" ? o : i} value`
  }, l ? g.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor"
  }, g.createElement("path", {
    d: "M9 2a1 1 0 000 2h2a1 1 0 100-2H9z"
  }), g.createElement("path", {
    fillRule: "evenodd",
    d: "M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm9.707 5.707a1 1 0 00-1.414-1.414L9 12.586l-1.293-1.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z",
    clipRule: "evenodd"
  })) : g.createElement("svg", {
    onClick: f,
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor"
  }, g.createElement("path", {
    d: "M8 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1z"
  }), g.createElement("path", {
    d: "M6 3a2 2 0 00-2 2v11a2 2 0 002 2h8a2 2 0 002-2V5a2 2 0 00-2-2 3 3 0 01-3 3H9a3 3 0 01-3-3z"
  }))));
}
const Sd = ["toggled"], Od = z("svg", {
  fill: "currentColor",
  transition: "transform 350ms ease, fill 250ms ease"
});
function bo(e) {
  let {
    toggled: t
  } = e, n = se(e, Sd);
  return g.createElement(Od, pe({
    width: "9",
    height: "5",
    viewBox: "0 0 9 5",
    xmlns: "http://www.w3.org/2000/svg",
    style: {
      transform: `rotate(${t ? 0 : -90}deg)`
    }
  }, n), g.createElement("path", {
    d: "M3.8 4.4c.4.3 1 .3 1.4 0L8 1.7A1 1 0 007.4 0H1.6a1 1 0 00-.7 1.7l3 2.7z"
  }));
}
const Pd = ["input"];
function De(e) {
  let {
    input: t
  } = e, n = se(e, Pd);
  return t ? g.createElement(ks, n) : g.createElement(As, n);
}
function Ms({
  value: e,
  type: t,
  settings: n,
  setValue: r
}) {
  const [o, i] = oe(ui(t, e, n)), a = _(e), s = _(n);
  s.current = n;
  const c = W((u) => i(ui(t, u, s.current)), [t]), l = W((u) => {
    try {
      r(u);
    } catch (f) {
      const {
        type: d,
        previousValue: p
      } = f;
      if (d !== "LEVA_ERROR") throw f;
      c(p);
    }
  }, [c, r]);
  return Y(() => {
    Xt(e, a.current) || c(e), a.current = e;
  }, [e, c]), {
    displayValue: o,
    onChange: i,
    onUpdate: l
  };
}
function an(e, t) {
  const {
    emitOnEditStart: n,
    emitOnEditEnd: r
  } = Ee();
  return au((o) => {
    o.first && (document.body.classList.add("leva__panel__dragged"), n == null || n());
    const i = e(o);
    return o.last && (document.body.classList.remove("leva__panel__dragged"), r == null || r()), i;
  }, t);
}
function Cd(e) {
  const t = _(null), n = _(null), r = _(!1);
  return Y(() => {
    const o = ys(() => {
      t.current.width = t.current.offsetWidth * window.devicePixelRatio, t.current.height = t.current.offsetHeight * window.devicePixelRatio, e(t.current, n.current);
    }, 250);
    return window.addEventListener("resize", o), r.current || (o(), r.current = !0), () => window.removeEventListener("resize", o);
  }, [e]), Y(() => {
    n.current = t.current.getContext("2d");
  }, []), [t, n];
}
function js() {
  const e = _(null), t = _({
    x: 0,
    y: 0
  }), n = W((r) => {
    Object.assign(t.current, r), e.current && (e.current.style.transform = `translate3d(${t.current.x}px, ${t.current.y}px, 0)`);
  }, []);
  return [e, n];
}
const _d = ["__refCount"], ar = (e, t) => {
  if (!e[t]) return null;
  const n = e[t];
  return se(n, _d);
};
function Td(e) {
  const t = on(), [n, r] = oe(ar(t.getData(), e)), o = W((l) => t.setValueAtPath(e, l, !0), [e, t]), i = W((l) => t.setSettingsAtPath(e, l), [e, t]), a = W((l) => t.disableInputAtPath(e, l), [e, t]), s = W(() => t.emitOnEditStart(e), [e, t]), c = W(() => t.emitOnEditEnd(e), [e, t]);
  return Y(() => {
    r(ar(t.getData(), e));
    const l = t.useStore.subscribe((u) => ar(u.data, e), r, {
      equalityFn: Fn
    });
    return () => l();
  }, [t, e]), [n, {
    set: o,
    setSettings: i,
    disable: a,
    storeId: t.storeId,
    emitOnEditStart: s,
    emitOnEditEnd: c
  }];
}
const Rd = z("div", {
  variants: {
    hasRange: {
      true: {
        position: "relative",
        display: "grid",
        gridTemplateColumns: "auto $sizes$numberInputMinWidth",
        columnGap: "$colGap",
        alignItems: "center"
      }
    }
  }
}), Ls = z("div", {
  position: "relative",
  width: "100%",
  height: 2,
  borderRadius: "$xs",
  backgroundColor: "$elevation1"
}), Hr = z("div", {
  position: "absolute",
  width: "$scrubberWidth",
  height: "$scrubberHeight",
  borderRadius: "$xs",
  boxShadow: "0 0 0 2px $colors$elevation2",
  backgroundColor: "$accent2",
  cursor: "pointer",
  $active: "none $accent1",
  $hover: "none $accent3",
  variants: {
    position: {
      left: {
        borderTopRightRadius: 0,
        borderBottomRightRadius: 0,
        transform: "translateX(calc(-0.5 * ($sizes$scrubberWidth + 4px)))"
      },
      right: {
        borderTopLeftRadius: 0,
        borderBottomLeftRadius: 0,
        transform: "translateX(calc(0.5 * ($sizes$scrubberWidth + 4px)))"
      }
    }
  }
}), zs = z("div", {
  position: "relative",
  $flex: "",
  height: "100%",
  cursor: "pointer",
  touchAction: "none"
}), Ns = z("div", {
  position: "absolute",
  height: "100%",
  backgroundColor: "$accent2"
});
function Id({
  value: e,
  min: t,
  max: n,
  onDrag: r,
  step: o,
  initialValue: i
}) {
  const a = _(null), s = _(null), c = _(0), l = Ge("sizes", "scrubberWidth"), u = an(({
    event: d,
    first: p,
    xy: [m],
    movement: [h],
    memo: v
  }) => {
    if (p) {
      const {
        width: y,
        left: w
      } = a.current.getBoundingClientRect();
      c.current = y - parseFloat(l), v = (d == null ? void 0 : d.target) === s.current ? e : In((m - w) / y, t, n);
    }
    const b = v + In(h / c.current, 0, n - t);
    return r(Es(b, {
      step: o,
      initialValue: i
    })), v;
  }), f = Rn(e, t, n);
  return g.createElement(zs, pe({
    ref: a
  }, u()), g.createElement(Ls, null, g.createElement(Ns, {
    style: {
      left: 0,
      right: `${(1 - f) * 100}%`
    }
  })), g.createElement(Hr, {
    ref: s,
    style: {
      left: `calc(${f} * (100% - ${l}))`
    }
  }));
}
const Ad = g.memo(({
  label: e,
  onUpdate: t,
  step: n,
  innerLabelTrim: r
}) => {
  const [o, i] = oe(!1), a = an(({
    active: s,
    delta: [c],
    event: l,
    memo: u = 0,
    first: f,
    last: d,
    target: p
  }) => (f && p.requestPointerLock(), d && document.exitPointerLock(), i(s), u += c / 2, Math.abs(u) >= 1 && (t((m) => parseFloat(m) + Math.floor(u) * n * ws(l)), u = 0), u));
  return g.createElement(ud, pe({
    dragging: o,
    title: e.length > 1 ? e : ""
  }, a()), e.slice(0, r));
});
function Fs({
  label: e,
  id: t,
  displayValue: n,
  onUpdate: r,
  onChange: o,
  settings: i,
  innerLabelTrim: a = 1
}) {
  const s = a > 0 && g.createElement(Ad, {
    label: e,
    step: i.step,
    onUpdate: r,
    innerLabelTrim: a
  });
  return g.createElement(hd, {
    id: t,
    value: String(n),
    onUpdate: r,
    onChange: o,
    innerLabel: s
  });
}
function kd() {
  const e = Ee(), {
    label: t,
    value: n,
    onUpdate: r,
    settings: o,
    id: i
  } = e, {
    min: a,
    max: s
  } = o, c = s !== 1 / 0 && a !== -1 / 0;
  return g.createElement(De, {
    input: !0
  }, g.createElement(Le, null, t), g.createElement(Rd, {
    hasRange: c
  }, c && g.createElement(Id, pe({
    value: parseFloat(n),
    onDrag: r
  }, o)), g.createElement(Fs, pe({}, e, {
    id: i,
    label: "value",
    innerLabelTrim: c ? 0 : 1
  }))));
}
const {
  sanitizeStep: Dd
} = Ss, Md = se(Ss, ["sanitizeStep"]);
var jd = F({
  component: kd
}, Md);
const Ld = (e, t) => Re().schema({
  options: Re().passesAnyOf(Re().object(), Re().array())
}).test(t), zd = (e, {
  values: t
}) => {
  if (t.indexOf(e) < 0) throw Error("Selected value doesn't match Select options");
  return e;
}, Nd = (e, {
  values: t
}) => t.indexOf(e), Fd = (e) => {
  let {
    value: t,
    options: n
  } = e, r, o;
  return Array.isArray(n) ? (o = n, r = n.map((i) => String(i))) : (o = Object.values(n), r = Object.keys(n)), "value" in e ? o.includes(t) || (r.unshift(String(t)), o.unshift(t)) : t = o[0], Object.values(n).includes(t) || (n[String(t)] = t), {
    value: t,
    settings: {
      keys: r,
      values: o
    }
  };
};
var Bd = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  schema: Ld,
  sanitize: zd,
  format: Nd,
  normalize: Fd
});
const Wd = z("div", {
  $flexCenter: "",
  position: "relative",
  "> svg": {
    pointerEvents: "none",
    position: "absolute",
    right: "$md"
  }
}), Yr = z("select", {
  position: "absolute",
  top: 0,
  left: 0,
  width: "100%",
  height: "100%",
  opacity: 0
}), Ud = z("div", {
  display: "flex",
  alignItems: "center",
  width: "100%",
  height: "$rowHeight",
  backgroundColor: "$elevation3",
  borderRadius: "$sm",
  padding: "0 $sm",
  cursor: "pointer",
  [`${Yr}:focus + &`]: {
    $focusStyle: ""
  },
  [`${Yr}:hover + &`]: {
    $hoverStyle: ""
  }
});
function Vd({
  displayValue: e,
  value: t,
  onUpdate: n,
  id: r,
  settings: o,
  disabled: i
}) {
  const {
    keys: a,
    values: s
  } = o, c = _();
  return t === s[e] && (c.current = a[e]), g.createElement(Wd, null, g.createElement(Yr, {
    id: r,
    value: e,
    onChange: (l) => n(s[Number(l.currentTarget.value)]),
    disabled: i
  }, a.map((l, u) => g.createElement("option", {
    key: l,
    value: u
  }, l))), g.createElement(Ud, null, c.current), g.createElement(bo, {
    toggled: !0
  }));
}
function Hd() {
  const {
    label: e,
    value: t,
    displayValue: n,
    onUpdate: r,
    id: o,
    disabled: i,
    settings: a
  } = Ee();
  return g.createElement(De, {
    input: !0
  }, g.createElement(Le, null, e), g.createElement(Vd, {
    id: o,
    value: t,
    displayValue: n,
    onUpdate: r,
    settings: a,
    disabled: i
  }));
}
var Yd = F({
  component: Hd
}, Bd);
const qd = (e) => Re().string().test(e), Kd = (e) => {
  if (typeof e != "string") throw Error("Invalid string");
  return e;
}, Gd = ({
  value: e,
  editable: t = !0,
  rows: n = !1
}) => ({
  value: e,
  settings: {
    editable: t,
    rows: typeof n == "number" ? n : n ? 5 : 0
  }
});
var Xd = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  schema: qd,
  sanitize: Kd,
  normalize: Gd
});
const Qd = ["displayValue", "onUpdate", "onChange", "editable"], Zd = z("div", {
  whiteSpace: "pre-wrap"
});
function Jd(e) {
  let {
    displayValue: t,
    onUpdate: n,
    onChange: r,
    editable: o = !0
  } = e, i = se(e, Qd);
  return o ? g.createElement(mo, pe({
    value: t,
    onUpdate: n,
    onChange: r
  }, i)) : g.createElement(Zd, null, t);
}
function ep() {
  const {
    label: e,
    settings: t,
    displayValue: n,
    onUpdate: r,
    onChange: o
  } = Ee();
  return g.createElement(De, {
    input: !0
  }, g.createElement(Le, null, e), g.createElement(Jd, pe({
    displayValue: n,
    onUpdate: r,
    onChange: o
  }, t)));
}
var tp = F({
  component: ep
}, Xd);
const np = (e) => Re().boolean().test(e), rp = (e) => {
  if (typeof e != "boolean") throw Error("Invalid boolean");
  return e;
};
var op = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  schema: np,
  sanitize: rp
});
const ip = z("div", {
  position: "relative",
  $flex: "",
  height: "$rowHeight",
  input: {
    $reset: "",
    height: 0,
    width: 0,
    opacity: 0,
    margin: 0
  },
  label: {
    position: "relative",
    $flexCenter: "",
    userSelect: "none",
    cursor: "pointer",
    height: "$checkboxSize",
    width: "$checkboxSize",
    backgroundColor: "$elevation3",
    borderRadius: "$sm",
    $hover: ""
  },
  "input:focus + label": {
    $focusStyle: ""
  },
  "input:focus:checked + label, input:checked + label:hover": {
    $hoverStyle: "$accent3"
  },
  "input + label:active": {
    backgroundColor: "$accent1"
  },
  "input:checked + label:active": {
    backgroundColor: "$accent1"
  },
  "label > svg": {
    display: "none",
    width: "90%",
    height: "90%",
    stroke: "$highlight3"
  },
  "input:checked + label": {
    backgroundColor: "$accent2"
  },
  "input:checked + label > svg": {
    display: "block"
  }
});
function ap({
  value: e,
  onUpdate: t,
  id: n,
  disabled: r
}) {
  return g.createElement(ip, null, g.createElement("input", {
    id: n,
    type: "checkbox",
    checked: e,
    onChange: (o) => t(o.currentTarget.checked),
    disabled: r
  }), g.createElement("label", {
    htmlFor: n
  }, g.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24"
  }, g.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 2,
    d: "M5 13l4 4L19 7"
  }))));
}
function sp() {
  const {
    label: e,
    value: t,
    onUpdate: n,
    disabled: r,
    id: o
  } = Ee();
  return g.createElement(De, {
    input: !0
  }, g.createElement(Le, null, e), g.createElement(ap, {
    value: t,
    onUpdate: n,
    id: o,
    disabled: r
  }));
}
var cp = F({
  component: sp
}, op);
const lp = ["locked"];
function up({
  value: e,
  id: t,
  valueKey: n,
  settings: r,
  onUpdate: o,
  innerLabelTrim: i
}) {
  const a = _(e[n]);
  a.current = e[n];
  const s = W((l) => o({
    [n]: bs({
      type: "NUMBER",
      value: a.current,
      settings: r
    }, l)
  }), [o, r, n]), c = Ms({
    type: "NUMBER",
    value: e[n],
    settings: r,
    setValue: s
  });
  return g.createElement(Fs, {
    id: t,
    label: n,
    value: e[n],
    displayValue: c.displayValue,
    onUpdate: c.onUpdate,
    onChange: c.onChange,
    settings: r,
    innerLabelTrim: i
  });
}
const fp = z("div", {
  display: "grid",
  columnGap: "$colGap",
  gridAutoFlow: "column dense",
  alignItems: "center",
  variants: {
    withLock: {
      true: {
        gridTemplateColumns: "10px auto",
        "> svg": {
          cursor: "pointer"
        }
      }
    }
  }
});
function dp(e) {
  let {
    locked: t
  } = e, n = se(e, lp);
  return g.createElement("svg", pe({
    width: "10",
    height: "10",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, n), t ? g.createElement("path", {
    d: "M5 4.63601C5 3.76031 5.24219 3.1054 5.64323 2.67357C6.03934 2.24705 6.64582 1.9783 7.5014 1.9783C8.35745 1.9783 8.96306 2.24652 9.35823 2.67208C9.75838 3.10299 10 3.75708 10 4.63325V5.99999H5V4.63601ZM4 5.99999V4.63601C4 3.58148 4.29339 2.65754 4.91049 1.99307C5.53252 1.32329 6.42675 0.978302 7.5014 0.978302C8.57583 0.978302 9.46952 1.32233 10.091 1.99162C10.7076 2.65557 11 3.57896 11 4.63325V5.99999H12C12.5523 5.99999 13 6.44771 13 6.99999V13C13 13.5523 12.5523 14 12 14H3C2.44772 14 2 13.5523 2 13V6.99999C2 6.44771 2.44772 5.99999 3 5.99999H4ZM3 6.99999H12V13H3V6.99999Z",
    fill: "currentColor",
    fillRule: "evenodd",
    clipRule: "evenodd"
  }) : g.createElement("path", {
    d: "M9 3.63601C9 2.76044 9.24207 2.11211 9.64154 1.68623C10.0366 1.26502 10.6432 1 11.5014 1C12.4485 1 13.0839 1.30552 13.4722 1.80636C13.8031 2.23312 14 2.84313 14 3.63325H15C15 2.68242 14.7626 1.83856 14.2625 1.19361C13.6389 0.38943 12.6743 0 11.5014 0C10.4294 0 9.53523 0.337871 8.91218 1.0021C8.29351 1.66167 8 2.58135 8 3.63601V6H1C0.447715 6 0 6.44772 0 7V13C0 13.5523 0.447715 14 1 14H10C10.5523 14 11 13.5523 11 13V7C11 6.44772 10.5523 6 10 6H9V3.63601ZM1 7H10V13H1V7Z",
    fill: "currentColor",
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
}
function yo({
  value: e,
  onUpdate: t,
  settings: n,
  innerLabelTrim: r
}) {
  const {
    id: o,
    setSettings: i
  } = Ee(), {
    lock: a,
    locked: s
  } = n;
  return g.createElement(fp, {
    withLock: a
  }, a && g.createElement(dp, {
    locked: s,
    onClick: () => i({
      locked: !s
    })
  }), Object.keys(e).map((c, l) => g.createElement(up, {
    id: l === 0 ? o : `${o}.${c}`,
    key: c,
    valueKey: c,
    value: e,
    settings: n[c],
    onUpdate: t,
    innerLabelTrim: r
  })));
}
const Bs = (e, t) => {
  const n = {};
  let r = 0, o = 1 / 0;
  Object.entries(e).forEach(([i, a]) => {
    n[i] = xs(F({
      value: a
    }, t[i])).settings, r = Math.max(r, n[i].step), o = Math.min(o, n[i].pad);
  });
  for (let i in n) {
    const {
      step: a,
      min: s,
      max: c
    } = t[i] || {};
    !isFinite(a) && (!isFinite(s) || !isFinite(c)) && (n[i].step = r, n[i].pad = o);
  }
  return n;
}, pp = ["lock"], hp = ["value"];
function gp(e) {
  const t = Re().array().length(e).every.number(), n = (r) => {
    if (!r || typeof r != "object") return !1;
    const o = Object.values(r);
    return o.length === e && o.every((i) => isFinite(i));
  };
  return (r) => t.test(r) || n(r);
}
function mp(e) {
  return Array.isArray(e) ? "array" : "object";
}
function qt(e, t, n) {
  return mp(e) === t ? e : t === "array" ? Object.values(e) : Kf(e, n);
}
const vp = (e, t, n) => {
  const r = qt(e, "object", t.keys);
  for (let a in r) r[a] = $s(r[a], t[a]);
  const o = Object.keys(r);
  let i = {};
  if (o.length === t.keys.length) i = r;
  else {
    const a = qt(n, "object", t.keys);
    if (o.length === 1 && t.locked) {
      const s = o[0], c = r[s], l = a[s], u = l !== 0 ? c / l : 1;
      for (let f in a)
        f === s ? i[s] = c : i[f] = a[f] * u;
    } else
      i = F(F({}, a), r);
  }
  return qt(i, t.format, t.keys);
}, bp = (e, t) => qt(e, "object", t.keys), yp = (e) => !!e && ("step" in e || "min" in e || "max" in e);
function wp(e, t, n = []) {
  const {
    lock: r = !1
  } = t, o = se(t, pp), i = Array.isArray(e) ? "array" : "object", a = i === "object" ? Object.keys(e) : n, s = qt(e, "object", a), c = yp(o) ? a.reduce((u, f) => Object.assign(u, {
    [f]: o
  }), {}) : o, l = Bs(s, c);
  return {
    value: i === "array" ? e : s,
    settings: F(F({}, l), {}, {
      format: i,
      keys: a,
      lock: r,
      locked: !1
    })
  };
}
function Ws(e) {
  return {
    schema: gp(e.length),
    normalize: (t) => {
      let {
        value: n
      } = t, r = se(t, hp);
      return wp(n, r, e);
    },
    format: (t, n) => bp(t, n),
    sanitize: (t, n, r) => vp(t, n, r)
  };
}
var $p = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) }, Ve = function(e) {
  return typeof e == "string" ? e.length > 0 : typeof e == "number";
}, ye = function(e, t, n) {
  return t === void 0 && (t = 0), n === void 0 && (n = Math.pow(10, t)), Math.round(n * e) / n + 0;
}, Ae = function(e, t, n) {
  return t === void 0 && (t = 0), n === void 0 && (n = 1), e > n ? n : e > t ? e : t;
}, Us = function(e) {
  return (e = isFinite(e) ? e % 360 : 0) > 0 ? e : e + 360;
}, wi = function(e) {
  return { r: Ae(e.r, 0, 255), g: Ae(e.g, 0, 255), b: Ae(e.b, 0, 255), a: Ae(e.a) };
}, sr = function(e) {
  return { r: ye(e.r), g: ye(e.g), b: ye(e.b), a: ye(e.a, 3) };
}, xp = /^#([0-9a-f]{3,8})$/i, gn = function(e) {
  var t = e.toString(16);
  return t.length < 2 ? "0" + t : t;
}, Vs = function(e) {
  var t = e.r, n = e.g, r = e.b, o = e.a, i = Math.max(t, n, r), a = i - Math.min(t, n, r), s = a ? i === t ? (n - r) / a : i === n ? 2 + (r - t) / a : 4 + (t - n) / a : 0;
  return { h: 60 * (s < 0 ? s + 6 : s), s: i ? a / i * 100 : 0, v: i / 255 * 100, a: o };
}, Hs = function(e) {
  var t = e.h, n = e.s, r = e.v, o = e.a;
  t = t / 360 * 6, n /= 100, r /= 100;
  var i = Math.floor(t), a = r * (1 - n), s = r * (1 - (t - i) * n), c = r * (1 - (1 - t + i) * n), l = i % 6;
  return { r: 255 * [r, s, a, a, c, r][l], g: 255 * [c, r, r, s, a, a][l], b: 255 * [a, a, c, r, r, s][l], a: o };
}, $i = function(e) {
  return { h: Us(e.h), s: Ae(e.s, 0, 100), l: Ae(e.l, 0, 100), a: Ae(e.a) };
}, xi = function(e) {
  return { h: ye(e.h), s: ye(e.s), l: ye(e.l), a: ye(e.a, 3) };
}, Ei = function(e) {
  return Hs((n = (t = e).s, { h: t.h, s: (n *= ((r = t.l) < 50 ? r : 100 - r) / 100) > 0 ? 2 * n / (r + n) * 100 : 0, v: r + n, a: t.a }));
  var t, n, r;
}, Kt = function(e) {
  return { h: (t = Vs(e)).h, s: (o = (200 - (n = t.s)) * (r = t.v) / 100) > 0 && o < 200 ? n * r / 100 / (o <= 100 ? o : 200 - o) * 100 : 0, l: o / 2, a: t.a };
  var t, n, r, o;
}, Ep = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, Sp = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, Op = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, Pp = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, qr = { string: [[function(e) {
  var t = xp.exec(e);
  return t ? (e = t[1]).length <= 4 ? { r: parseInt(e[0] + e[0], 16), g: parseInt(e[1] + e[1], 16), b: parseInt(e[2] + e[2], 16), a: e.length === 4 ? ye(parseInt(e[3] + e[3], 16) / 255, 2) : 1 } : e.length === 6 || e.length === 8 ? { r: parseInt(e.substr(0, 2), 16), g: parseInt(e.substr(2, 2), 16), b: parseInt(e.substr(4, 2), 16), a: e.length === 8 ? ye(parseInt(e.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
}, "hex"], [function(e) {
  var t = Op.exec(e) || Pp.exec(e);
  return t ? t[2] !== t[4] || t[4] !== t[6] ? null : wi({ r: Number(t[1]) / (t[2] ? 100 / 255 : 1), g: Number(t[3]) / (t[4] ? 100 / 255 : 1), b: Number(t[5]) / (t[6] ? 100 / 255 : 1), a: t[7] === void 0 ? 1 : Number(t[7]) / (t[8] ? 100 : 1) }) : null;
}, "rgb"], [function(e) {
  var t = Ep.exec(e) || Sp.exec(e);
  if (!t) return null;
  var n, r, o = $i({ h: (n = t[1], r = t[2], r === void 0 && (r = "deg"), Number(n) * ($p[r] || 1)), s: Number(t[3]), l: Number(t[4]), a: t[5] === void 0 ? 1 : Number(t[5]) / (t[6] ? 100 : 1) });
  return Ei(o);
}, "hsl"]], object: [[function(e) {
  var t = e.r, n = e.g, r = e.b, o = e.a, i = o === void 0 ? 1 : o;
  return Ve(t) && Ve(n) && Ve(r) ? wi({ r: Number(t), g: Number(n), b: Number(r), a: Number(i) }) : null;
}, "rgb"], [function(e) {
  var t = e.h, n = e.s, r = e.l, o = e.a, i = o === void 0 ? 1 : o;
  if (!Ve(t) || !Ve(n) || !Ve(r)) return null;
  var a = $i({ h: Number(t), s: Number(n), l: Number(r), a: Number(i) });
  return Ei(a);
}, "hsl"], [function(e) {
  var t = e.h, n = e.s, r = e.v, o = e.a, i = o === void 0 ? 1 : o;
  if (!Ve(t) || !Ve(n) || !Ve(r)) return null;
  var a = function(s) {
    return { h: Us(s.h), s: Ae(s.s, 0, 100), v: Ae(s.v, 0, 100), a: Ae(s.a) };
  }({ h: Number(t), s: Number(n), v: Number(r), a: Number(i) });
  return Hs(a);
}, "hsv"]] }, Si = function(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n][0](e);
    if (r) return [r, t[n][1]];
  }
  return [null, void 0];
}, Ys = function(e) {
  return typeof e == "string" ? Si(e.trim(), qr.string) : typeof e == "object" && e !== null ? Si(e, qr.object) : [null, void 0];
}, Cp = function(e) {
  return Ys(e)[1];
}, cr = function(e, t) {
  var n = Kt(e);
  return { h: n.h, s: Ae(n.s + 100 * t, 0, 100), l: n.l, a: n.a };
}, lr = function(e) {
  return (299 * e.r + 587 * e.g + 114 * e.b) / 1e3 / 255;
}, Oi = function(e, t) {
  var n = Kt(e);
  return { h: n.h, s: n.s, l: Ae(n.l + 100 * t, 0, 100), a: n.a };
}, Kr = function() {
  function e(t) {
    this.parsed = Ys(t)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
  }
  return e.prototype.isValid = function() {
    return this.parsed !== null;
  }, e.prototype.brightness = function() {
    return ye(lr(this.rgba), 2);
  }, e.prototype.isDark = function() {
    return lr(this.rgba) < 0.5;
  }, e.prototype.isLight = function() {
    return lr(this.rgba) >= 0.5;
  }, e.prototype.toHex = function() {
    return t = sr(this.rgba), n = t.r, r = t.g, o = t.b, a = (i = t.a) < 1 ? gn(ye(255 * i)) : "", "#" + gn(n) + gn(r) + gn(o) + a;
    var t, n, r, o, i, a;
  }, e.prototype.toRgb = function() {
    return sr(this.rgba);
  }, e.prototype.toRgbString = function() {
    return t = sr(this.rgba), n = t.r, r = t.g, o = t.b, (i = t.a) < 1 ? "rgba(" + n + ", " + r + ", " + o + ", " + i + ")" : "rgb(" + n + ", " + r + ", " + o + ")";
    var t, n, r, o, i;
  }, e.prototype.toHsl = function() {
    return xi(Kt(this.rgba));
  }, e.prototype.toHslString = function() {
    return t = xi(Kt(this.rgba)), n = t.h, r = t.s, o = t.l, (i = t.a) < 1 ? "hsla(" + n + ", " + r + "%, " + o + "%, " + i + ")" : "hsl(" + n + ", " + r + "%, " + o + "%)";
    var t, n, r, o, i;
  }, e.prototype.toHsv = function() {
    return t = Vs(this.rgba), { h: ye(t.h), s: ye(t.s), v: ye(t.v), a: ye(t.a, 3) };
    var t;
  }, e.prototype.invert = function() {
    return Pe({ r: 255 - (t = this.rgba).r, g: 255 - t.g, b: 255 - t.b, a: t.a });
    var t;
  }, e.prototype.saturate = function(t) {
    return t === void 0 && (t = 0.1), Pe(cr(this.rgba, t));
  }, e.prototype.desaturate = function(t) {
    return t === void 0 && (t = 0.1), Pe(cr(this.rgba, -t));
  }, e.prototype.grayscale = function() {
    return Pe(cr(this.rgba, -1));
  }, e.prototype.lighten = function(t) {
    return t === void 0 && (t = 0.1), Pe(Oi(this.rgba, t));
  }, e.prototype.darken = function(t) {
    return t === void 0 && (t = 0.1), Pe(Oi(this.rgba, -t));
  }, e.prototype.rotate = function(t) {
    return t === void 0 && (t = 15), this.hue(this.hue() + t);
  }, e.prototype.alpha = function(t) {
    return typeof t == "number" ? Pe({ r: (n = this.rgba).r, g: n.g, b: n.b, a: t }) : ye(this.rgba.a, 3);
    var n;
  }, e.prototype.hue = function(t) {
    var n = Kt(this.rgba);
    return typeof t == "number" ? Pe({ h: t, s: n.s, l: n.l, a: n.a }) : ye(n.h);
  }, e.prototype.isEqual = function(t) {
    return this.toHex() === Pe(t).toHex();
  }, e;
}(), Pe = function(e) {
  return e instanceof Kr ? e : new Kr(e);
}, Pi = [], _p = function(e) {
  e.forEach(function(t) {
    Pi.indexOf(t) < 0 && (t(Kr, qr), Pi.push(t));
  });
};
function Tp(e, t) {
  var n = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, r = {};
  for (var o in n) r[n[o]] = o;
  var i = {};
  e.prototype.toName = function(a) {
    if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
    var s, c, l = r[this.toHex()];
    if (l) return l;
    if (a != null && a.closest) {
      var u = this.toRgb(), f = 1 / 0, d = "black";
      if (!i.length) for (var p in n) i[p] = new e(n[p]).toRgb();
      for (var m in n) {
        var h = (s = u, c = i[m], Math.pow(s.r - c.r, 2) + Math.pow(s.g - c.g, 2) + Math.pow(s.b - c.b, 2));
        h < f && (f = h, d = m);
      }
      return d;
    }
  }, t.string.push([function(a) {
    var s = a.toLowerCase(), c = s === "transparent" ? "#0000" : n[s];
    return c ? new e(c).toRgb() : null;
  }, "name"]);
}
function jt() {
  return (jt = Object.assign || function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }).apply(this, arguments);
}
function wo(e, t) {
  if (e == null) return {};
  var n, r, o = {}, i = Object.keys(e);
  for (r = 0; r < i.length; r++) t.indexOf(n = i[r]) >= 0 || (o[n] = e[n]);
  return o;
}
function Gr(e) {
  var t = _(e), n = _(function(r) {
    t.current && t.current(r);
  });
  return t.current = e, n.current;
}
var It = function(e, t, n) {
  return t === void 0 && (t = 0), n === void 0 && (n = 1), e > n ? n : e < t ? t : e;
}, Gt = function(e) {
  return "touches" in e;
}, Xr = function(e) {
  return e && e.ownerDocument.defaultView || self;
}, Ci = function(e, t, n) {
  var r = e.getBoundingClientRect(), o = Gt(t) ? function(i, a) {
    for (var s = 0; s < i.length; s++) if (i[s].identifier === a) return i[s];
    return i[0];
  }(t.touches, n) : t;
  return { left: It((o.pageX - (r.left + Xr(e).pageXOffset)) / r.width), top: It((o.pageY - (r.top + Xr(e).pageYOffset)) / r.height) };
}, _i = function(e) {
  !Gt(e) && e.preventDefault();
}, $o = g.memo(function(e) {
  var t = e.onMove, n = e.onKey, r = wo(e, ["onMove", "onKey"]), o = _(null), i = Gr(t), a = Gr(n), s = _(null), c = _(!1), l = ge(function() {
    var p = function(v) {
      _i(v), (Gt(v) ? v.touches.length > 0 : v.buttons > 0) && o.current ? i(Ci(o.current, v, s.current)) : h(!1);
    }, m = function() {
      return h(!1);
    };
    function h(v) {
      var b = c.current, y = Xr(o.current), w = v ? y.addEventListener : y.removeEventListener;
      w(b ? "touchmove" : "mousemove", p), w(b ? "touchend" : "mouseup", m);
    }
    return [function(v) {
      var b = v.nativeEvent, y = o.current;
      if (y && (_i(b), !function(x, $) {
        return $ && !Gt(x);
      }(b, c.current) && y)) {
        if (Gt(b)) {
          c.current = !0;
          var w = b.changedTouches || [];
          w.length && (s.current = w[0].identifier);
        }
        y.focus(), i(Ci(y, b, s.current)), h(!0);
      }
    }, function(v) {
      var b = v.which || v.keyCode;
      b < 37 || b > 40 || (v.preventDefault(), a({ left: b === 39 ? 0.05 : b === 37 ? -0.05 : 0, top: b === 40 ? 0.05 : b === 38 ? -0.05 : 0 }));
    }, h];
  }, [a, i]), u = l[0], f = l[1], d = l[2];
  return Y(function() {
    return d;
  }, [d]), g.createElement("div", jt({}, r, { onTouchStart: u, onMouseDown: u, className: "react-colorful__interactive", ref: o, onKeyDown: f, tabIndex: 0, role: "slider" }));
}), sn = function(e) {
  return e.filter(Boolean).join(" ");
}, xo = function(e) {
  var t = e.color, n = e.left, r = e.top, o = r === void 0 ? 0.5 : r, i = sn(["react-colorful__pointer", e.className]);
  return g.createElement("div", { className: i, style: { top: 100 * o + "%", left: 100 * n + "%" } }, g.createElement("div", { className: "react-colorful__pointer-fill", style: { backgroundColor: t } }));
}, Ce = function(e, t, n) {
  return t === void 0 && (t = 0), n === void 0 && (n = Math.pow(10, t)), Math.round(n * e) / n;
}, qs = function(e) {
  var t = e.s, n = e.v, r = e.a, o = (200 - t) * n / 100;
  return { h: Ce(e.h), s: Ce(o > 0 && o < 200 ? t * n / 100 / (o <= 100 ? o : 200 - o) * 100 : 0), l: Ce(o / 2), a: Ce(r, 2) };
}, Qr = function(e) {
  var t = qs(e);
  return "hsl(" + t.h + ", " + t.s + "%, " + t.l + "%)";
}, ur = function(e) {
  var t = qs(e);
  return "hsla(" + t.h + ", " + t.s + "%, " + t.l + "%, " + t.a + ")";
}, Ks = function(e) {
  var t = e.h, n = e.s, r = e.v, o = e.a;
  t = t / 360 * 6, n /= 100, r /= 100;
  var i = Math.floor(t), a = r * (1 - n), s = r * (1 - (t - i) * n), c = r * (1 - (1 - t + i) * n), l = i % 6;
  return { r: Ce(255 * [r, s, a, a, c, r][l]), g: Ce(255 * [c, r, r, s, a, a][l]), b: Ce(255 * [a, a, c, r, r, s][l]), a: Ce(o, 2) };
}, Gs = function(e) {
  var t = e.r, n = e.g, r = e.b, o = e.a, i = Math.max(t, n, r), a = i - Math.min(t, n, r), s = a ? i === t ? (n - r) / a : i === n ? 2 + (r - t) / a : 4 + (t - n) / a : 0;
  return { h: Ce(60 * (s < 0 ? s + 6 : s)), s: Ce(i ? a / i * 100 : 0), v: Ce(i / 255 * 100), a: o };
}, Xs = g.memo(function(e) {
  var t = e.hue, n = e.onChange, r = sn(["react-colorful__hue", e.className]);
  return g.createElement("div", { className: r }, g.createElement($o, { onMove: function(o) {
    n({ h: 360 * o.left });
  }, onKey: function(o) {
    n({ h: It(t + 360 * o.left, 0, 360) });
  }, "aria-label": "Hue", "aria-valuenow": Ce(t), "aria-valuemax": "360", "aria-valuemin": "0" }, g.createElement(xo, { className: "react-colorful__hue-pointer", left: t / 360, color: Qr({ h: t, s: 100, v: 100, a: 1 }) })));
}), Qs = g.memo(function(e) {
  var t = e.hsva, n = e.onChange, r = { backgroundColor: Qr({ h: t.h, s: 100, v: 100, a: 1 }) };
  return g.createElement("div", { className: "react-colorful__saturation", style: r }, g.createElement($o, { onMove: function(o) {
    n({ s: 100 * o.left, v: 100 - 100 * o.top });
  }, onKey: function(o) {
    n({ s: It(t.s + 100 * o.left, 0, 100), v: It(t.v - 100 * o.top, 0, 100) });
  }, "aria-label": "Color", "aria-valuetext": "Saturation " + Ce(t.s) + "%, Brightness " + Ce(t.v) + "%" }, g.createElement(xo, { className: "react-colorful__saturation-pointer", top: 1 - t.v / 100, left: t.s / 100, color: Qr(t) })));
}), Eo = function(e, t) {
  if (e === t) return !0;
  for (var n in e) if (e[n] !== t[n]) return !1;
  return !0;
};
function Zs(e, t, n) {
  var r = Gr(n), o = oe(function() {
    return e.toHsva(t);
  }), i = o[0], a = o[1], s = _({ color: t, hsva: i });
  Y(function() {
    if (!e.equal(t, s.current.color)) {
      var l = e.toHsva(t);
      s.current = { hsva: l, color: t }, a(l);
    }
  }, [t, e]), Y(function() {
    var l;
    Eo(i, s.current.hsva) || e.equal(l = e.fromHsva(i), s.current.color) || (s.current = { hsva: i, color: l }, r(l));
  }, [i, e, r]);
  var c = W(function(l) {
    a(function(u) {
      return Object.assign({}, u, l);
    });
  }, []);
  return [i, c];
}
var Rp = typeof window < "u" ? Qe : Y, Ip = function() {
  return typeof __webpack_nonce__ < "u" ? __webpack_nonce__ : void 0;
}, Ti = /* @__PURE__ */ new Map(), Js = function(e) {
  Rp(function() {
    var t = e.current ? e.current.ownerDocument : document;
    if (t !== void 0 && !Ti.has(t)) {
      var n = t.createElement("style");
      n.innerHTML = `.react-colorful{position:relative;display:flex;flex-direction:column;width:200px;height:200px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.react-colorful__saturation{position:relative;flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(0deg,#000,transparent),linear-gradient(90deg,#fff,hsla(0,0%,100%,0))}.react-colorful__alpha-gradient,.react-colorful__pointer-fill{content:"";position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none;border-radius:inherit}.react-colorful__alpha-gradient,.react-colorful__saturation{box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}.react-colorful__alpha,.react-colorful__hue{position:relative;height:24px}.react-colorful__hue{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.react-colorful__last-control{border-radius:0 0 8px 8px}.react-colorful__interactive{position:absolute;left:0;top:0;right:0;bottom:0;border-radius:inherit;outline:none;touch-action:none}.react-colorful__pointer{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}.react-colorful__interactive:focus .react-colorful__pointer{transform:translate(-50%,-50%) scale(1.1)}.react-colorful__alpha,.react-colorful__alpha-pointer{background-color:#fff;background-image:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>')}.react-colorful__saturation-pointer{z-index:3}.react-colorful__hue-pointer{z-index:2}`, Ti.set(t, n);
      var r = Ip();
      r && n.setAttribute("nonce", r), t.head.appendChild(n);
    }
  }, []);
}, Ap = function(e) {
  var t = e.className, n = e.colorModel, r = e.color, o = r === void 0 ? n.defaultColor : r, i = e.onChange, a = wo(e, ["className", "colorModel", "color", "onChange"]), s = _(null);
  Js(s);
  var c = Zs(n, o, i), l = c[0], u = c[1], f = sn(["react-colorful", t]);
  return g.createElement("div", jt({}, a, { ref: s, className: f }), g.createElement(Qs, { hsva: l, onChange: u }), g.createElement(Xs, { hue: l.h, onChange: u, className: "react-colorful__last-control" }));
}, kp = function(e) {
  var t = e.className, n = e.hsva, r = e.onChange, o = { backgroundImage: "linear-gradient(90deg, " + ur(Object.assign({}, n, { a: 0 })) + ", " + ur(Object.assign({}, n, { a: 1 })) + ")" }, i = sn(["react-colorful__alpha", t]), a = Ce(100 * n.a);
  return g.createElement("div", { className: i }, g.createElement("div", { className: "react-colorful__alpha-gradient", style: o }), g.createElement($o, { onMove: function(s) {
    r({ a: s.left });
  }, onKey: function(s) {
    r({ a: It(n.a + s.left) });
  }, "aria-label": "Alpha", "aria-valuetext": a + "%", "aria-valuenow": a, "aria-valuemin": "0", "aria-valuemax": "100" }, g.createElement(xo, { className: "react-colorful__alpha-pointer", left: n.a, color: ur(n) })));
}, Dp = function(e) {
  var t = e.className, n = e.colorModel, r = e.color, o = r === void 0 ? n.defaultColor : r, i = e.onChange, a = wo(e, ["className", "colorModel", "color", "onChange"]), s = _(null);
  Js(s);
  var c = Zs(n, o, i), l = c[0], u = c[1], f = sn(["react-colorful", t]);
  return g.createElement("div", jt({}, a, { ref: s, className: f }), g.createElement(Qs, { hsva: l, onChange: u }), g.createElement(Xs, { hue: l.h, onChange: u }), g.createElement(kp, { hsva: l, onChange: u, className: "react-colorful__last-control" }));
}, Mp = { defaultColor: { r: 0, g: 0, b: 0, a: 1 }, toHsva: Gs, fromHsva: Ks, equal: Eo }, jp = function(e) {
  return g.createElement(Dp, jt({}, e, { colorModel: Mp }));
}, Lp = { defaultColor: { r: 0, g: 0, b: 0 }, toHsva: function(e) {
  return Gs({ r: e.r, g: e.g, b: e.b, a: 1 });
}, fromHsva: function(e) {
  return { r: (t = Ks(e)).r, g: t.g, b: t.b };
  var t;
}, equal: Eo }, zp = function(e) {
  return g.createElement(Ap, jt({}, e, { colorModel: Lp }));
};
function So(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var mn = { exports: {} }, vn = { exports: {} }, ne = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ri;
function Np() {
  if (Ri) return ne;
  Ri = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, c = e ? Symbol.for("react.async_mode") : 60111, l = e ? Symbol.for("react.concurrent_mode") : 60111, u = e ? Symbol.for("react.forward_ref") : 60112, f = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, p = e ? Symbol.for("react.memo") : 60115, m = e ? Symbol.for("react.lazy") : 60116, h = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, b = e ? Symbol.for("react.responder") : 60118, y = e ? Symbol.for("react.scope") : 60119;
  function w($) {
    if (typeof $ == "object" && $ !== null) {
      var E = $.$$typeof;
      switch (E) {
        case t:
          switch ($ = $.type, $) {
            case c:
            case l:
            case r:
            case i:
            case o:
            case f:
              return $;
            default:
              switch ($ = $ && $.$$typeof, $) {
                case s:
                case u:
                case m:
                case p:
                case a:
                  return $;
                default:
                  return E;
              }
          }
        case n:
          return E;
      }
    }
  }
  function x($) {
    return w($) === l;
  }
  return ne.AsyncMode = c, ne.ConcurrentMode = l, ne.ContextConsumer = s, ne.ContextProvider = a, ne.Element = t, ne.ForwardRef = u, ne.Fragment = r, ne.Lazy = m, ne.Memo = p, ne.Portal = n, ne.Profiler = i, ne.StrictMode = o, ne.Suspense = f, ne.isAsyncMode = function($) {
    return x($) || w($) === c;
  }, ne.isConcurrentMode = x, ne.isContextConsumer = function($) {
    return w($) === s;
  }, ne.isContextProvider = function($) {
    return w($) === a;
  }, ne.isElement = function($) {
    return typeof $ == "object" && $ !== null && $.$$typeof === t;
  }, ne.isForwardRef = function($) {
    return w($) === u;
  }, ne.isFragment = function($) {
    return w($) === r;
  }, ne.isLazy = function($) {
    return w($) === m;
  }, ne.isMemo = function($) {
    return w($) === p;
  }, ne.isPortal = function($) {
    return w($) === n;
  }, ne.isProfiler = function($) {
    return w($) === i;
  }, ne.isStrictMode = function($) {
    return w($) === o;
  }, ne.isSuspense = function($) {
    return w($) === f;
  }, ne.isValidElementType = function($) {
    return typeof $ == "string" || typeof $ == "function" || $ === r || $ === l || $ === i || $ === o || $ === f || $ === d || typeof $ == "object" && $ !== null && ($.$$typeof === m || $.$$typeof === p || $.$$typeof === a || $.$$typeof === s || $.$$typeof === u || $.$$typeof === v || $.$$typeof === b || $.$$typeof === y || $.$$typeof === h);
  }, ne.typeOf = w, ne;
}
var re = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ii;
function Fp() {
  return Ii || (Ii = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, c = e ? Symbol.for("react.async_mode") : 60111, l = e ? Symbol.for("react.concurrent_mode") : 60111, u = e ? Symbol.for("react.forward_ref") : 60112, f = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, p = e ? Symbol.for("react.memo") : 60115, m = e ? Symbol.for("react.lazy") : 60116, h = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, b = e ? Symbol.for("react.responder") : 60118, y = e ? Symbol.for("react.scope") : 60119;
    function w(I) {
      return typeof I == "string" || typeof I == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      I === r || I === l || I === i || I === o || I === f || I === d || typeof I == "object" && I !== null && (I.$$typeof === m || I.$$typeof === p || I.$$typeof === a || I.$$typeof === s || I.$$typeof === u || I.$$typeof === v || I.$$typeof === b || I.$$typeof === y || I.$$typeof === h);
    }
    function x(I) {
      if (typeof I == "object" && I !== null) {
        var ve = I.$$typeof;
        switch (ve) {
          case t:
            var ze = I.type;
            switch (ze) {
              case c:
              case l:
              case r:
              case i:
              case o:
              case f:
                return ze;
              default:
                var Ue = ze && ze.$$typeof;
                switch (Ue) {
                  case s:
                  case u:
                  case m:
                  case p:
                  case a:
                    return Ue;
                  default:
                    return ve;
                }
            }
          case n:
            return ve;
        }
      }
    }
    var $ = c, E = l, O = s, C = a, B = t, R = u, T = r, A = m, M = p, Z = n, G = i, J = o, ie = f, ce = !1;
    function he(I) {
      return ce || (ce = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), S(I) || x(I) === c;
    }
    function S(I) {
      return x(I) === l;
    }
    function P(I) {
      return x(I) === s;
    }
    function H(I) {
      return x(I) === a;
    }
    function U(I) {
      return typeof I == "object" && I !== null && I.$$typeof === t;
    }
    function N(I) {
      return x(I) === u;
    }
    function q(I) {
      return x(I) === r;
    }
    function L(I) {
      return x(I) === m;
    }
    function j(I) {
      return x(I) === p;
    }
    function V(I) {
      return x(I) === n;
    }
    function Q(I) {
      return x(I) === i;
    }
    function X(I) {
      return x(I) === o;
    }
    function me(I) {
      return x(I) === f;
    }
    re.AsyncMode = $, re.ConcurrentMode = E, re.ContextConsumer = O, re.ContextProvider = C, re.Element = B, re.ForwardRef = R, re.Fragment = T, re.Lazy = A, re.Memo = M, re.Portal = Z, re.Profiler = G, re.StrictMode = J, re.Suspense = ie, re.isAsyncMode = he, re.isConcurrentMode = S, re.isContextConsumer = P, re.isContextProvider = H, re.isElement = U, re.isForwardRef = N, re.isFragment = q, re.isLazy = L, re.isMemo = j, re.isPortal = V, re.isProfiler = Q, re.isStrictMode = X, re.isSuspense = me, re.isValidElementType = w, re.typeOf = x;
  }()), re;
}
var Ai;
function ec() {
  return Ai || (Ai = 1, process.env.NODE_ENV === "production" ? vn.exports = Np() : vn.exports = Fp()), vn.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var fr, ki;
function Bp() {
  if (ki) return fr;
  ki = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var c = Object.getOwnPropertyNames(a).map(function(u) {
        return a[u];
      });
      if (c.join("") !== "0123456789")
        return !1;
      var l = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(u) {
        l[u] = u;
      }), Object.keys(Object.assign({}, l)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return fr = o() ? Object.assign : function(i, a) {
    for (var s, c = r(i), l, u = 1; u < arguments.length; u++) {
      s = Object(arguments[u]);
      for (var f in s)
        t.call(s, f) && (c[f] = s[f]);
      if (e) {
        l = e(s);
        for (var d = 0; d < l.length; d++)
          n.call(s, l[d]) && (c[l[d]] = s[l[d]]);
      }
    }
    return c;
  }, fr;
}
var dr, Di;
function Oo() {
  if (Di) return dr;
  Di = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return dr = e, dr;
}
var pr, Mi;
function tc() {
  return Mi || (Mi = 1, pr = Function.call.bind(Object.prototype.hasOwnProperty)), pr;
}
var hr, ji;
function Wp() {
  if (ji) return hr;
  ji = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = /* @__PURE__ */ Oo(), n = {}, r = /* @__PURE__ */ tc();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, c, l) {
    if (process.env.NODE_ENV !== "production") {
      for (var u in i)
        if (r(i, u)) {
          var f;
          try {
            if (typeof i[u] != "function") {
              var d = Error(
                (c || "React class") + ": " + s + " type `" + u + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[u] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            f = i[u](a, u, c, s, null, t);
          } catch (m) {
            f = m;
          }
          if (f && !(f instanceof Error) && e(
            (c || "React class") + ": type specification of " + s + " `" + u + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof f + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), f instanceof Error && !(f.message in n)) {
            n[f.message] = !0;
            var p = l ? l() : "";
            e(
              "Failed " + s + " type: " + f.message + (p ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, hr = o, hr;
}
var gr, Li;
function Up() {
  if (Li) return gr;
  Li = 1;
  var e = ec(), t = Bp(), n = /* @__PURE__ */ Oo(), r = /* @__PURE__ */ tc(), o = /* @__PURE__ */ Wp(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var c = "Warning: " + s;
    typeof console < "u" && console.error(c);
    try {
      throw new Error(c);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return gr = function(s, c) {
    var l = typeof Symbol == "function" && Symbol.iterator, u = "@@iterator";
    function f(S) {
      var P = S && (l && S[l] || S[u]);
      if (typeof P == "function")
        return P;
    }
    var d = "<<anonymous>>", p = {
      array: b("array"),
      bigint: b("bigint"),
      bool: b("boolean"),
      func: b("function"),
      number: b("number"),
      object: b("object"),
      string: b("string"),
      symbol: b("symbol"),
      any: y(),
      arrayOf: w,
      element: x(),
      elementType: $(),
      instanceOf: E,
      node: R(),
      objectOf: C,
      oneOf: O,
      oneOfType: B,
      shape: A,
      exact: M
    };
    function m(S, P) {
      return S === P ? S !== 0 || 1 / S === 1 / P : S !== S && P !== P;
    }
    function h(S, P) {
      this.message = S, this.data = P && typeof P == "object" ? P : {}, this.stack = "";
    }
    h.prototype = Error.prototype;
    function v(S) {
      if (process.env.NODE_ENV !== "production")
        var P = {}, H = 0;
      function U(q, L, j, V, Q, X, me) {
        if (V = V || d, X = X || j, me !== n) {
          if (c) {
            var I = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw I.name = "Invariant Violation", I;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ve = V + ":" + j;
            !P[ve] && // Avoid spamming the console because they are often not actionable except for lib authors
            H < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + X + "` prop on `" + V + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), P[ve] = !0, H++);
          }
        }
        return L[j] == null ? q ? L[j] === null ? new h("The " + Q + " `" + X + "` is marked as required " + ("in `" + V + "`, but its value is `null`.")) : new h("The " + Q + " `" + X + "` is marked as required in " + ("`" + V + "`, but its value is `undefined`.")) : null : S(L, j, V, Q, X);
      }
      var N = U.bind(null, !1);
      return N.isRequired = U.bind(null, !0), N;
    }
    function b(S) {
      function P(H, U, N, q, L, j) {
        var V = H[U], Q = J(V);
        if (Q !== S) {
          var X = ie(V);
          return new h(
            "Invalid " + q + " `" + L + "` of type " + ("`" + X + "` supplied to `" + N + "`, expected ") + ("`" + S + "`."),
            { expectedType: S }
          );
        }
        return null;
      }
      return v(P);
    }
    function y() {
      return v(a);
    }
    function w(S) {
      function P(H, U, N, q, L) {
        if (typeof S != "function")
          return new h("Property `" + L + "` of component `" + N + "` has invalid PropType notation inside arrayOf.");
        var j = H[U];
        if (!Array.isArray(j)) {
          var V = J(j);
          return new h("Invalid " + q + " `" + L + "` of type " + ("`" + V + "` supplied to `" + N + "`, expected an array."));
        }
        for (var Q = 0; Q < j.length; Q++) {
          var X = S(j, Q, N, q, L + "[" + Q + "]", n);
          if (X instanceof Error)
            return X;
        }
        return null;
      }
      return v(P);
    }
    function x() {
      function S(P, H, U, N, q) {
        var L = P[H];
        if (!s(L)) {
          var j = J(L);
          return new h("Invalid " + N + " `" + q + "` of type " + ("`" + j + "` supplied to `" + U + "`, expected a single ReactElement."));
        }
        return null;
      }
      return v(S);
    }
    function $() {
      function S(P, H, U, N, q) {
        var L = P[H];
        if (!e.isValidElementType(L)) {
          var j = J(L);
          return new h("Invalid " + N + " `" + q + "` of type " + ("`" + j + "` supplied to `" + U + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return v(S);
    }
    function E(S) {
      function P(H, U, N, q, L) {
        if (!(H[U] instanceof S)) {
          var j = S.name || d, V = he(H[U]);
          return new h("Invalid " + q + " `" + L + "` of type " + ("`" + V + "` supplied to `" + N + "`, expected ") + ("instance of `" + j + "`."));
        }
        return null;
      }
      return v(P);
    }
    function O(S) {
      if (!Array.isArray(S))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function P(H, U, N, q, L) {
        for (var j = H[U], V = 0; V < S.length; V++)
          if (m(j, S[V]))
            return null;
        var Q = JSON.stringify(S, function(me, I) {
          var ve = ie(I);
          return ve === "symbol" ? String(I) : I;
        });
        return new h("Invalid " + q + " `" + L + "` of value `" + String(j) + "` " + ("supplied to `" + N + "`, expected one of " + Q + "."));
      }
      return v(P);
    }
    function C(S) {
      function P(H, U, N, q, L) {
        if (typeof S != "function")
          return new h("Property `" + L + "` of component `" + N + "` has invalid PropType notation inside objectOf.");
        var j = H[U], V = J(j);
        if (V !== "object")
          return new h("Invalid " + q + " `" + L + "` of type " + ("`" + V + "` supplied to `" + N + "`, expected an object."));
        for (var Q in j)
          if (r(j, Q)) {
            var X = S(j, Q, N, q, L + "." + Q, n);
            if (X instanceof Error)
              return X;
          }
        return null;
      }
      return v(P);
    }
    function B(S) {
      if (!Array.isArray(S))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var P = 0; P < S.length; P++) {
        var H = S[P];
        if (typeof H != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + ce(H) + " at index " + P + "."
          ), a;
      }
      function U(N, q, L, j, V) {
        for (var Q = [], X = 0; X < S.length; X++) {
          var me = S[X], I = me(N, q, L, j, V, n);
          if (I == null)
            return null;
          I.data && r(I.data, "expectedType") && Q.push(I.data.expectedType);
        }
        var ve = Q.length > 0 ? ", expected one of type [" + Q.join(", ") + "]" : "";
        return new h("Invalid " + j + " `" + V + "` supplied to " + ("`" + L + "`" + ve + "."));
      }
      return v(U);
    }
    function R() {
      function S(P, H, U, N, q) {
        return Z(P[H]) ? null : new h("Invalid " + N + " `" + q + "` supplied to " + ("`" + U + "`, expected a ReactNode."));
      }
      return v(S);
    }
    function T(S, P, H, U, N) {
      return new h(
        (S || "React class") + ": " + P + " type `" + H + "." + U + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + N + "`."
      );
    }
    function A(S) {
      function P(H, U, N, q, L) {
        var j = H[U], V = J(j);
        if (V !== "object")
          return new h("Invalid " + q + " `" + L + "` of type `" + V + "` " + ("supplied to `" + N + "`, expected `object`."));
        for (var Q in S) {
          var X = S[Q];
          if (typeof X != "function")
            return T(N, q, L, Q, ie(X));
          var me = X(j, Q, N, q, L + "." + Q, n);
          if (me)
            return me;
        }
        return null;
      }
      return v(P);
    }
    function M(S) {
      function P(H, U, N, q, L) {
        var j = H[U], V = J(j);
        if (V !== "object")
          return new h("Invalid " + q + " `" + L + "` of type `" + V + "` " + ("supplied to `" + N + "`, expected `object`."));
        var Q = t({}, H[U], S);
        for (var X in Q) {
          var me = S[X];
          if (r(S, X) && typeof me != "function")
            return T(N, q, L, X, ie(me));
          if (!me)
            return new h(
              "Invalid " + q + " `" + L + "` key `" + X + "` supplied to `" + N + "`.\nBad object: " + JSON.stringify(H[U], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(S), null, "  ")
            );
          var I = me(j, X, N, q, L + "." + X, n);
          if (I)
            return I;
        }
        return null;
      }
      return v(P);
    }
    function Z(S) {
      switch (typeof S) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !S;
        case "object":
          if (Array.isArray(S))
            return S.every(Z);
          if (S === null || s(S))
            return !0;
          var P = f(S);
          if (P) {
            var H = P.call(S), U;
            if (P !== S.entries) {
              for (; !(U = H.next()).done; )
                if (!Z(U.value))
                  return !1;
            } else
              for (; !(U = H.next()).done; ) {
                var N = U.value;
                if (N && !Z(N[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function G(S, P) {
      return S === "symbol" ? !0 : P ? P["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && P instanceof Symbol : !1;
    }
    function J(S) {
      var P = typeof S;
      return Array.isArray(S) ? "array" : S instanceof RegExp ? "object" : G(P, S) ? "symbol" : P;
    }
    function ie(S) {
      if (typeof S > "u" || S === null)
        return "" + S;
      var P = J(S);
      if (P === "object") {
        if (S instanceof Date)
          return "date";
        if (S instanceof RegExp)
          return "regexp";
      }
      return P;
    }
    function ce(S) {
      var P = ie(S);
      switch (P) {
        case "array":
        case "object":
          return "an " + P;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + P;
        default:
          return P;
      }
    }
    function he(S) {
      return !S.constructor || !S.constructor.name ? d : S.constructor.name;
    }
    return p.checkPropTypes = o, p.resetWarningCache = o.resetWarningCache, p.PropTypes = p, p;
  }, gr;
}
var mr, zi;
function Vp() {
  if (zi) return mr;
  zi = 1;
  var e = /* @__PURE__ */ Oo();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, mr = function() {
    function r(a, s, c, l, u, f) {
      if (f !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, mr;
}
var Ni;
function Hp() {
  if (Ni) return mn.exports;
  if (Ni = 1, process.env.NODE_ENV !== "production") {
    var e = ec(), t = !0;
    mn.exports = /* @__PURE__ */ Up()(e.isElement, t);
  } else
    mn.exports = /* @__PURE__ */ Vp()();
  return mn.exports;
}
var Yp = /* @__PURE__ */ Hp();
const le = /* @__PURE__ */ So(Yp);
function Lt(e, t, n, r) {
  function o(i) {
    return i instanceof n ? i : new n(function(a) {
      a(i);
    });
  }
  return new (n || (n = Promise))(function(i, a) {
    function s(u) {
      try {
        l(r.next(u));
      } catch (f) {
        a(f);
      }
    }
    function c(u) {
      try {
        l(r.throw(u));
      } catch (f) {
        a(f);
      }
    }
    function l(u) {
      u.done ? i(u.value) : o(u.value).then(s, c);
    }
    l((r = r.apply(e, t || [])).next());
  });
}
function zt(e, t) {
  var n = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, o, i, a = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
  return a.next = s(0), a.throw = s(1), a.return = s(2), typeof Symbol == "function" && (a[Symbol.iterator] = function() {
    return this;
  }), a;
  function s(l) {
    return function(u) {
      return c([l, u]);
    };
  }
  function c(l) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; a && (a = 0, l[0] && (n = 0)), n; ) try {
      if (r = 1, o && (i = l[0] & 2 ? o.return : l[0] ? o.throw || ((i = o.return) && i.call(o), 0) : o.next) && !(i = i.call(o, l[1])).done) return i;
      switch (o = 0, i && (l = [l[0] & 2, i.value]), l[0]) {
        case 0:
        case 1:
          i = l;
          break;
        case 4:
          return n.label++, { value: l[1], done: !1 };
        case 5:
          n.label++, o = l[1], l = [0];
          continue;
        case 7:
          l = n.ops.pop(), n.trys.pop();
          continue;
        default:
          if (i = n.trys, !(i = i.length > 0 && i[i.length - 1]) && (l[0] === 6 || l[0] === 2)) {
            n = 0;
            continue;
          }
          if (l[0] === 3 && (!i || l[1] > i[0] && l[1] < i[3])) {
            n.label = l[1];
            break;
          }
          if (l[0] === 6 && n.label < i[1]) {
            n.label = i[1], i = l;
            break;
          }
          if (i && n.label < i[2]) {
            n.label = i[2], n.ops.push(l);
            break;
          }
          i[2] && n.ops.pop(), n.trys.pop();
          continue;
      }
      l = t.call(e, n);
    } catch (u) {
      l = [6, u], o = 0;
    } finally {
      r = i = 0;
    }
    if (l[0] & 5) throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}
function qp(e, t) {
  var n = typeof Symbol == "function" && e[Symbol.iterator];
  if (!n) return e;
  var r = n.call(e), o, i = [], a;
  try {
    for (; (t === void 0 || t-- > 0) && !(o = r.next()).done; ) i.push(o.value);
  } catch (s) {
    a = { error: s };
  } finally {
    try {
      o && !o.done && (n = r.return) && n.call(r);
    } finally {
      if (a) throw a.error;
    }
  }
  return i;
}
function Kp() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e = e.concat(qp(arguments[t]));
  return e;
}
var Gp = /* @__PURE__ */ new Map([
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types
  ["aac", "audio/aac"],
  ["abw", "application/x-abiword"],
  ["arc", "application/x-freearc"],
  ["avif", "image/avif"],
  ["avi", "video/x-msvideo"],
  ["azw", "application/vnd.amazon.ebook"],
  ["bin", "application/octet-stream"],
  ["bmp", "image/bmp"],
  ["bz", "application/x-bzip"],
  ["bz2", "application/x-bzip2"],
  ["cda", "application/x-cdf"],
  ["csh", "application/x-csh"],
  ["css", "text/css"],
  ["csv", "text/csv"],
  ["doc", "application/msword"],
  ["docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"],
  ["eot", "application/vnd.ms-fontobject"],
  ["epub", "application/epub+zip"],
  ["gz", "application/gzip"],
  ["gif", "image/gif"],
  ["heic", "image/heic"],
  ["heif", "image/heif"],
  ["htm", "text/html"],
  ["html", "text/html"],
  ["ico", "image/vnd.microsoft.icon"],
  ["ics", "text/calendar"],
  ["jar", "application/java-archive"],
  ["jpeg", "image/jpeg"],
  ["jpg", "image/jpeg"],
  ["js", "text/javascript"],
  ["json", "application/json"],
  ["jsonld", "application/ld+json"],
  ["mid", "audio/midi"],
  ["midi", "audio/midi"],
  ["mjs", "text/javascript"],
  ["mp3", "audio/mpeg"],
  ["mp4", "video/mp4"],
  ["mpeg", "video/mpeg"],
  ["mpkg", "application/vnd.apple.installer+xml"],
  ["odp", "application/vnd.oasis.opendocument.presentation"],
  ["ods", "application/vnd.oasis.opendocument.spreadsheet"],
  ["odt", "application/vnd.oasis.opendocument.text"],
  ["oga", "audio/ogg"],
  ["ogv", "video/ogg"],
  ["ogx", "application/ogg"],
  ["opus", "audio/opus"],
  ["otf", "font/otf"],
  ["png", "image/png"],
  ["pdf", "application/pdf"],
  ["php", "application/x-httpd-php"],
  ["ppt", "application/vnd.ms-powerpoint"],
  ["pptx", "application/vnd.openxmlformats-officedocument.presentationml.presentation"],
  ["rar", "application/vnd.rar"],
  ["rtf", "application/rtf"],
  ["sh", "application/x-sh"],
  ["svg", "image/svg+xml"],
  ["swf", "application/x-shockwave-flash"],
  ["tar", "application/x-tar"],
  ["tif", "image/tiff"],
  ["tiff", "image/tiff"],
  ["ts", "video/mp2t"],
  ["ttf", "font/ttf"],
  ["txt", "text/plain"],
  ["vsd", "application/vnd.visio"],
  ["wav", "audio/wav"],
  ["weba", "audio/webm"],
  ["webm", "video/webm"],
  ["webp", "image/webp"],
  ["woff", "font/woff"],
  ["woff2", "font/woff2"],
  ["xhtml", "application/xhtml+xml"],
  ["xls", "application/vnd.ms-excel"],
  ["xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"],
  ["xml", "application/xml"],
  ["xul", "application/vnd.mozilla.xul+xml"],
  ["zip", "application/zip"],
  ["7z", "application/x-7z-compressed"],
  // Others
  ["mkv", "video/x-matroska"],
  ["mov", "video/quicktime"],
  ["msg", "application/vnd.ms-outlook"]
]);
function cn(e, t) {
  var n = Xp(e);
  if (typeof n.path != "string") {
    var r = e.webkitRelativePath;
    Object.defineProperty(n, "path", {
      value: typeof t == "string" ? t : typeof r == "string" && r.length > 0 ? r : e.name,
      writable: !1,
      configurable: !1,
      enumerable: !0
    });
  }
  return n;
}
function Xp(e) {
  var t = e.name, n = t && t.lastIndexOf(".") !== -1;
  if (n && !e.type) {
    var r = t.split(".").pop().toLowerCase(), o = Gp.get(r);
    o && Object.defineProperty(e, "type", {
      value: o,
      writable: !1,
      configurable: !1,
      enumerable: !0
    });
  }
  return e;
}
var Qp = [
  // Thumbnail cache files for macOS and Windows
  ".DS_Store",
  "Thumbs.db"
  // Windows
];
function Zp(e) {
  return Lt(this, void 0, void 0, function() {
    return zt(this, function(t) {
      return kn(e) && Jp(e) ? [2, rh(e.dataTransfer, e.type)] : eh(e) ? [2, th(e)] : Array.isArray(e) && e.every(function(n) {
        return "getFile" in n && typeof n.getFile == "function";
      }) ? [2, nh(e)] : [2, []];
    });
  });
}
function Jp(e) {
  return kn(e.dataTransfer);
}
function eh(e) {
  return kn(e) && kn(e.target);
}
function kn(e) {
  return typeof e == "object" && e !== null;
}
function th(e) {
  return Zr(e.target.files).map(function(t) {
    return cn(t);
  });
}
function nh(e) {
  return Lt(this, void 0, void 0, function() {
    var t;
    return zt(this, function(n) {
      switch (n.label) {
        case 0:
          return [4, Promise.all(e.map(function(r) {
            return r.getFile();
          }))];
        case 1:
          return t = n.sent(), [2, t.map(function(r) {
            return cn(r);
          })];
      }
    });
  });
}
function rh(e, t) {
  return Lt(this, void 0, void 0, function() {
    var n, r;
    return zt(this, function(o) {
      switch (o.label) {
        case 0:
          return e === null ? [2, []] : e.items ? (n = Zr(e.items).filter(function(i) {
            return i.kind === "file";
          }), t !== "drop" ? [2, n] : [4, Promise.all(n.map(oh))]) : [3, 2];
        case 1:
          return r = o.sent(), [2, Fi(nc(r))];
        case 2:
          return [2, Fi(Zr(e.files).map(function(i) {
            return cn(i);
          }))];
      }
    });
  });
}
function Fi(e) {
  return e.filter(function(t) {
    return Qp.indexOf(t.name) === -1;
  });
}
function Zr(e) {
  if (e === null)
    return [];
  for (var t = [], n = 0; n < e.length; n++) {
    var r = e[n];
    t.push(r);
  }
  return t;
}
function oh(e) {
  if (typeof e.webkitGetAsEntry != "function")
    return Bi(e);
  var t = e.webkitGetAsEntry();
  return t && t.isDirectory ? rc(t) : Bi(e);
}
function nc(e) {
  return e.reduce(function(t, n) {
    return Kp(t, Array.isArray(n) ? nc(n) : [n]);
  }, []);
}
function Bi(e) {
  var t = e.getAsFile();
  if (!t)
    return Promise.reject(e + " is not a File");
  var n = cn(t);
  return Promise.resolve(n);
}
function ih(e) {
  return Lt(this, void 0, void 0, function() {
    return zt(this, function(t) {
      return [2, e.isDirectory ? rc(e) : ah(e)];
    });
  });
}
function rc(e) {
  var t = e.createReader();
  return new Promise(function(n, r) {
    var o = [];
    function i() {
      var a = this;
      t.readEntries(function(s) {
        return Lt(a, void 0, void 0, function() {
          var c, l, u;
          return zt(this, function(f) {
            switch (f.label) {
              case 0:
                if (s.length) return [3, 5];
                f.label = 1;
              case 1:
                return f.trys.push([1, 3, , 4]), [4, Promise.all(o)];
              case 2:
                return c = f.sent(), n(c), [3, 4];
              case 3:
                return l = f.sent(), r(l), [3, 4];
              case 4:
                return [3, 6];
              case 5:
                u = Promise.all(s.map(ih)), o.push(u), i(), f.label = 6;
              case 6:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }, function(s) {
        r(s);
      });
    }
    i();
  });
}
function ah(e) {
  return Lt(this, void 0, void 0, function() {
    return zt(this, function(t) {
      return [2, new Promise(function(n, r) {
        e.file(function(o) {
          var i = cn(o, e.fullPath);
          n(i);
        }, function(o) {
          r(o);
        });
      })];
    });
  });
}
var bn = {}, Wi;
function sh() {
  return Wi || (Wi = 1, bn.__esModule = !0, bn.default = function(e, t) {
    if (e && t) {
      var n = Array.isArray(t) ? t : t.split(",");
      if (n.length === 0)
        return !0;
      var r = e.name || "", o = (e.type || "").toLowerCase(), i = o.replace(/\/.*$/, "");
      return n.some(function(a) {
        var s = a.trim().toLowerCase();
        return s.charAt(0) === "." ? r.toLowerCase().endsWith(s) : s.endsWith("/*") ? i === s.replace(/\/.*$/, "") : o === s;
      });
    }
    return !0;
  }), bn;
}
var ch = sh();
const lh = /* @__PURE__ */ So(ch);
function Ui(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Vi(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Ui(Object(n), !0).forEach(function(r) {
      oc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ui(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function oc(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function Hi(e, t) {
  return ph(e) || dh(e, t) || fh(e, t) || uh();
}
function uh() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function fh(e, t) {
  if (e) {
    if (typeof e == "string") return Yi(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Yi(e, t);
  }
}
function Yi(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = new Array(t); n < t; n++)
    r[n] = e[n];
  return r;
}
function dh(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var r = [], o = !0, i = !1, a, s;
    try {
      for (n = n.call(e); !(o = (a = n.next()).done) && (r.push(a.value), !(t && r.length === t)); o = !0)
        ;
    } catch (c) {
      i = !0, s = c;
    } finally {
      try {
        !o && n.return != null && n.return();
      } finally {
        if (i) throw s;
      }
    }
    return r;
  }
}
function ph(e) {
  if (Array.isArray(e)) return e;
}
var hh = "file-invalid-type", gh = "file-too-large", mh = "file-too-small", vh = "too-many-files", bh = function(t) {
  t = Array.isArray(t) && t.length === 1 ? t[0] : t;
  var n = Array.isArray(t) ? "one of ".concat(t.join(", ")) : t;
  return {
    code: hh,
    message: "File type must be ".concat(n)
  };
}, qi = function(t) {
  return {
    code: gh,
    message: "File is larger than ".concat(t, " ").concat(t === 1 ? "byte" : "bytes")
  };
}, Ki = function(t) {
  return {
    code: mh,
    message: "File is smaller than ".concat(t, " ").concat(t === 1 ? "byte" : "bytes")
  };
}, yh = {
  code: vh,
  message: "Too many files"
};
function ic(e, t) {
  var n = e.type === "application/x-moz-file" || lh(e, t);
  return [n, n ? null : bh(t)];
}
function ac(e, t, n) {
  if (Ut(e.size))
    if (Ut(t) && Ut(n)) {
      if (e.size > n) return [!1, qi(n)];
      if (e.size < t) return [!1, Ki(t)];
    } else {
      if (Ut(t) && e.size < t) return [!1, Ki(t)];
      if (Ut(n) && e.size > n) return [!1, qi(n)];
    }
  return [!0, null];
}
function Ut(e) {
  return e != null;
}
function wh(e) {
  var t = e.files, n = e.accept, r = e.minSize, o = e.maxSize, i = e.multiple, a = e.maxFiles;
  return !i && t.length > 1 || i && a >= 1 && t.length > a ? !1 : t.every(function(s) {
    var c = ic(s, n), l = Hi(c, 1), u = l[0], f = ac(s, r, o), d = Hi(f, 1), p = d[0];
    return u && p;
  });
}
function Dn(e) {
  return typeof e.isPropagationStopped == "function" ? e.isPropagationStopped() : typeof e.cancelBubble < "u" ? e.cancelBubble : !1;
}
function yn(e) {
  return e.dataTransfer ? Array.prototype.some.call(e.dataTransfer.types, function(t) {
    return t === "Files" || t === "application/x-moz-file";
  }) : !!e.target && !!e.target.files;
}
function Gi(e) {
  e.preventDefault();
}
function $h(e) {
  return e.indexOf("MSIE") !== -1 || e.indexOf("Trident/") !== -1;
}
function xh(e) {
  return e.indexOf("Edge/") !== -1;
}
function Eh() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.navigator.userAgent;
  return $h(e) || xh(e);
}
function Ne() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return function(r) {
    for (var o = arguments.length, i = new Array(o > 1 ? o - 1 : 0), a = 1; a < o; a++)
      i[a - 1] = arguments[a];
    return t.some(function(s) {
      return !Dn(r) && s && s.apply(void 0, [r].concat(i)), Dn(r);
    });
  };
}
function Sh() {
  return "showOpenFilePicker" in window;
}
function Oh(e) {
  return e = typeof e == "string" ? e.split(",") : e, [{
    description: "everything",
    // TODO: Need to handle filtering more elegantly than this!
    accept: Array.isArray(e) ? (
      // Accept just MIME types as per spec
      // NOTE: accept can be https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#unique_file_type_specifiers
      e.filter(function(t) {
        return t === "audio/*" || t === "video/*" || t === "image/*" || t === "text/*" || /\w+\/[-+.\w]+/g.test(t);
      }).reduce(function(t, n) {
        return Vi(Vi({}, t), {}, oc({}, n, []));
      }, {})
    ) : {}
  }];
}
function Ph(e) {
  return e instanceof DOMException && (e.name === "AbortError" || e.code === e.ABORT_ERR);
}
function Ch(e) {
  return e instanceof DOMException && (e.name === "SecurityError" || e.code === e.SECURITY_ERR);
}
var _h = ["children"], Th = ["open"], Rh = ["refKey", "role", "onKeyDown", "onFocus", "onBlur", "onClick", "onDragEnter", "onDragOver", "onDragLeave", "onDrop"], Ih = ["refKey", "onChange", "onClick"];
function Ah(e) {
  return Mh(e) || Dh(e) || sc(e) || kh();
}
function kh() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Dh(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function Mh(e) {
  if (Array.isArray(e)) return Jr(e);
}
function vr(e, t) {
  return zh(e) || Lh(e, t) || sc(e, t) || jh();
}
function jh() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function sc(e, t) {
  if (e) {
    if (typeof e == "string") return Jr(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Jr(e, t);
  }
}
function Jr(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = new Array(t); n < t; n++)
    r[n] = e[n];
  return r;
}
function Lh(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var r = [], o = !0, i = !1, a, s;
    try {
      for (n = n.call(e); !(o = (a = n.next()).done) && (r.push(a.value), !(t && r.length === t)); o = !0)
        ;
    } catch (c) {
      i = !0, s = c;
    } finally {
      try {
        !o && n.return != null && n.return();
      } finally {
        if (i) throw s;
      }
    }
    return r;
  }
}
function zh(e) {
  if (Array.isArray(e)) return e;
}
function Xi(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ue(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Xi(Object(n), !0).forEach(function(r) {
      eo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Xi(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function eo(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function Mn(e, t) {
  if (e == null) return {};
  var n = Nh(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function Nh(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
var Po = /* @__PURE__ */ be(function(e, t) {
  var n = e.children, r = Mn(e, _h), o = lc(r), i = o.open, a = Mn(o, Th);
  return Nn(t, function() {
    return {
      open: i
    };
  }, [i]), /* @__PURE__ */ g.createElement(Ia, null, n(ue(ue({}, a), {}, {
    open: i
  })));
});
Po.displayName = "Dropzone";
var cc = {
  disabled: !1,
  getFilesFromEvent: Zp,
  maxSize: 1 / 0,
  minSize: 0,
  multiple: !0,
  maxFiles: 0,
  preventDropOnDocument: !0,
  noClick: !1,
  noKeyboard: !1,
  noDrag: !1,
  noDragEventsBubbling: !1,
  validator: null,
  useFsAccessApi: !0
};
Po.defaultProps = cc;
Po.propTypes = {
  /**
   * Render function that exposes the dropzone state and prop getter fns
   *
   * @param {object} params
   * @param {Function} params.getRootProps Returns the props you should apply to the root drop container you render
   * @param {Function} params.getInputProps Returns the props you should apply to hidden file input you render
   * @param {Function} params.open Open the native file selection dialog
   * @param {boolean} params.isFocused Dropzone area is in focus
   * @param {boolean} params.isFileDialogActive File dialog is opened
   * @param {boolean} params.isDragActive Active drag is in progress
   * @param {boolean} params.isDragAccept Dragged files are accepted
   * @param {boolean} params.isDragReject Some dragged files are rejected
   * @param {File[]} params.draggedFiles Files in active drag
   * @param {File[]} params.acceptedFiles Accepted files
   * @param {FileRejection[]} params.fileRejections Rejected files and why they were rejected
   */
  children: le.func,
  /**
   * Set accepted file types.
   * See https://github.com/okonet/attr-accept for more information.
   * Keep in mind that mime type determination is not reliable across platforms. CSV files,
   * for example, are reported as text/plain under macOS but as application/vnd.ms-excel under
   * Windows. In some cases there might not be a mime type set at all.
   * See: https://github.com/react-dropzone/react-dropzone/issues/276
   */
  accept: le.oneOfType([le.string, le.arrayOf(le.string)]),
  /**
   * Allow drag 'n' drop (or selection from the file dialog) of multiple files
   */
  multiple: le.bool,
  /**
   * If false, allow dropped items to take over the current browser window
   */
  preventDropOnDocument: le.bool,
  /**
   * If true, disables click to open the native file selection dialog
   */
  noClick: le.bool,
  /**
   * If true, disables SPACE/ENTER to open the native file selection dialog.
   * Note that it also stops tracking the focus state.
   */
  noKeyboard: le.bool,
  /**
   * If true, disables drag 'n' drop
   */
  noDrag: le.bool,
  /**
   * If true, stops drag event propagation to parents
   */
  noDragEventsBubbling: le.bool,
  /**
   * Minimum file size (in bytes)
   */
  minSize: le.number,
  /**
   * Maximum file size (in bytes)
   */
  maxSize: le.number,
  /**
   * Maximum accepted number of files
   * The default value is 0 which means there is no limitation to how many files are accepted.
   */
  maxFiles: le.number,
  /**
   * Enable/disable the dropzone
   */
  disabled: le.bool,
  /**
   * Use this to provide a custom file aggregator
   *
   * @param {(DragEvent|Event)} event A drag event or input change event (if files were selected via the file dialog)
   */
  getFilesFromEvent: le.func,
  /**
   * Cb for when closing the file dialog with no selection
   */
  onFileDialogCancel: le.func,
  /**
   * Cb for when opening the file dialog
   */
  onFileDialogOpen: le.func,
  /**
   * Set to true to use the https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API
   * to open the file picker instead of using an `<input type="file">` click event.
   */
  useFsAccessApi: le.bool,
  /**
   * Cb for when the `dragenter` event occurs.
   *
   * @param {DragEvent} event
   */
  onDragEnter: le.func,
  /**
   * Cb for when the `dragleave` event occurs
   *
   * @param {DragEvent} event
   */
  onDragLeave: le.func,
  /**
   * Cb for when the `dragover` event occurs
   *
   * @param {DragEvent} event
   */
  onDragOver: le.func,
  /**
   * Cb for when the `drop` event occurs.
   * Note that this callback is invoked after the `getFilesFromEvent` callback is done.
   *
   * Files are accepted or rejected based on the `accept`, `multiple`, `minSize` and `maxSize` props.
   * `accept` must be a valid [MIME type](http://www.iana.org/assignments/media-types/media-types.xhtml) according to [input element specification](https://www.w3.org/wiki/HTML/Elements/input/file) or a valid file extension.
   * If `multiple` is set to false and additional files are dropped,
   * all files besides the first will be rejected.
   * Any file which does not have a size in the [`minSize`, `maxSize`] range, will be rejected as well.
   *
   * Note that the `onDrop` callback will always be invoked regardless if the dropped files were accepted or rejected.
   * If you'd like to react to a specific scenario, use the `onDropAccepted`/`onDropRejected` props.
   *
   * `onDrop` will provide you with an array of [File](https://developer.mozilla.org/en-US/docs/Web/API/File) objects which you can then process and send to a server.
   * For example, with [SuperAgent](https://github.com/visionmedia/superagent) as a http/ajax library:
   *
   * ```js
   * function onDrop(acceptedFiles) {
   *   const req = request.post('/upload')
   *   acceptedFiles.forEach(file => {
   *     req.attach(file.name, file)
   *   })
   *   req.end(callback)
   * }
   * ```
   *
   * @param {File[]} acceptedFiles
   * @param {FileRejection[]} fileRejections
   * @param {(DragEvent|Event)} event A drag event or input change event (if files were selected via the file dialog)
   */
  onDrop: le.func,
  /**
   * Cb for when the `drop` event occurs.
   * Note that if no files are accepted, this callback is not invoked.
   *
   * @param {File[]} files
   * @param {(DragEvent|Event)} event
   */
  onDropAccepted: le.func,
  /**
   * Cb for when the `drop` event occurs.
   * Note that if no files are rejected, this callback is not invoked.
   *
   * @param {FileRejection[]} fileRejections
   * @param {(DragEvent|Event)} event
   */
  onDropRejected: le.func,
  /**
   * Custom validation function
   * @param {File} file
   * @returns {FileError|FileError[]}
   */
  validator: le.func
};
var to = {
  isFocused: !1,
  isFileDialogActive: !1,
  isDragActive: !1,
  isDragAccept: !1,
  isDragReject: !1,
  draggedFiles: [],
  acceptedFiles: [],
  fileRejections: []
};
function lc() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = ue(ue({}, cc), e), n = t.accept, r = t.disabled, o = t.getFilesFromEvent, i = t.maxSize, a = t.minSize, s = t.multiple, c = t.maxFiles, l = t.onDragEnter, u = t.onDragLeave, f = t.onDragOver, d = t.onDrop, p = t.onDropAccepted, m = t.onDropRejected, h = t.onFileDialogCancel, v = t.onFileDialogOpen, b = t.useFsAccessApi, y = t.preventDropOnDocument, w = t.noClick, x = t.noKeyboard, $ = t.noDrag, E = t.noDragEventsBubbling, O = t.validator, C = ge(function() {
    return typeof v == "function" ? v : Qi;
  }, [v]), B = ge(function() {
    return typeof h == "function" ? h : Qi;
  }, [h]), R = _(null), T = _(null), A = oo(Fh, to), M = vr(A, 2), Z = M[0], G = M[1], J = Z.isFocused, ie = Z.isFileDialogActive, ce = Z.draggedFiles, he = _(typeof window < "u" && window.isSecureContext && b && Sh()), S = function() {
    !he.current && ie && setTimeout(function() {
      if (T.current) {
        var K = T.current.files;
        K.length || (G({
          type: "closeDialog"
        }), B());
      }
    }, 300);
  };
  Y(function() {
    return window.addEventListener("focus", S, !1), function() {
      window.removeEventListener("focus", S, !1);
    };
  }, [T, ie, B, he]);
  var P = _([]), H = function(K) {
    R.current && R.current.contains(K.target) || (K.preventDefault(), P.current = []);
  };
  Y(function() {
    return y && (document.addEventListener("dragover", Gi, !1), document.addEventListener("drop", H, !1)), function() {
      y && (document.removeEventListener("dragover", Gi), document.removeEventListener("drop", H));
    };
  }, [R, y]);
  var U = W(function(k) {
    k.preventDefault(), k.persist(), $t(k), P.current = [].concat(Ah(P.current), [k.target]), yn(k) && Promise.resolve(o(k)).then(function(K) {
      Dn(k) && !E || (G({
        draggedFiles: K,
        isDragActive: !0,
        type: "setDraggedFiles"
      }), l && l(k));
    });
  }, [o, l, E]), N = W(function(k) {
    k.preventDefault(), k.persist(), $t(k);
    var K = yn(k);
    if (K && k.dataTransfer)
      try {
        k.dataTransfer.dropEffect = "copy";
      } catch {
      }
    return K && f && f(k), !1;
  }, [f, E]), q = W(function(k) {
    k.preventDefault(), k.persist(), $t(k);
    var K = P.current.filter(function(_e) {
      return R.current && R.current.contains(_e);
    }), $e = K.indexOf(k.target);
    $e !== -1 && K.splice($e, 1), P.current = K, !(K.length > 0) && (G({
      isDragActive: !1,
      type: "setDraggedFiles",
      draggedFiles: []
    }), yn(k) && u && u(k));
  }, [R, u, E]), L = W(function(k, K) {
    var $e = [], _e = [];
    k.forEach(function(Me) {
      var Ft = ic(Me, n), xt = vr(Ft, 2), Xn = xt[0], Qn = xt[1], Zn = ac(Me, a, i), ln = vr(Zn, 2), Jn = ln[0], er = ln[1], tr = O ? O(Me) : null;
      if (Xn && Jn && !tr)
        $e.push(Me);
      else {
        var nr = [Qn, er];
        tr && (nr = nr.concat(tr)), _e.push({
          file: Me,
          errors: nr.filter(function(wc) {
            return wc;
          })
        });
      }
    }), (!s && $e.length > 1 || s && c >= 1 && $e.length > c) && ($e.forEach(function(Me) {
      _e.push({
        file: Me,
        errors: [yh]
      });
    }), $e.splice(0)), G({
      acceptedFiles: $e,
      fileRejections: _e,
      type: "setFiles"
    }), d && d($e, _e, K), _e.length > 0 && m && m(_e, K), $e.length > 0 && p && p($e, K);
  }, [G, s, n, a, i, c, d, p, m, O]), j = W(function(k) {
    k.preventDefault(), k.persist(), $t(k), P.current = [], yn(k) && Promise.resolve(o(k)).then(function(K) {
      Dn(k) && !E || L(K, k);
    }), G({
      type: "reset"
    });
  }, [o, L, E]), V = W(function() {
    if (he.current) {
      G({
        type: "openDialog"
      }), C();
      var k = {
        multiple: s,
        types: Oh(n)
      };
      window.showOpenFilePicker(k).then(function(K) {
        return o(K);
      }).then(function(K) {
        L(K, null), G({
          type: "closeDialog"
        });
      }).catch(function(K) {
        Ph(K) ? (B(K), G({
          type: "closeDialog"
        })) : Ch(K) && (he.current = !1, T.current && (T.current.value = null, T.current.click()));
      });
      return;
    }
    T.current && (G({
      type: "openDialog"
    }), C(), T.current.value = null, T.current.click());
  }, [G, C, B, b, L, n, s]), Q = W(function(k) {
    !R.current || !R.current.isEqualNode(k.target) || (k.key === " " || k.key === "Enter" || k.keyCode === 32 || k.keyCode === 13) && (k.preventDefault(), V());
  }, [R, V]), X = W(function() {
    G({
      type: "focus"
    });
  }, []), me = W(function() {
    G({
      type: "blur"
    });
  }, []), I = W(function() {
    w || (Eh() ? setTimeout(V, 0) : V());
  }, [w, V]), ve = function(K) {
    return r ? null : K;
  }, ze = function(K) {
    return x ? null : ve(K);
  }, Ue = function(K) {
    return $ ? null : ve(K);
  }, $t = function(K) {
    E && K.stopPropagation();
  }, Kn = ge(function() {
    return function() {
      var k = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, K = k.refKey, $e = K === void 0 ? "ref" : K, _e = k.role, Me = k.onKeyDown, Ft = k.onFocus, xt = k.onBlur, Xn = k.onClick, Qn = k.onDragEnter, Zn = k.onDragOver, ln = k.onDragLeave, Jn = k.onDrop, er = Mn(k, Rh);
      return ue(ue(eo({
        onKeyDown: ze(Ne(Me, Q)),
        onFocus: ze(Ne(Ft, X)),
        onBlur: ze(Ne(xt, me)),
        onClick: ve(Ne(Xn, I)),
        onDragEnter: Ue(Ne(Qn, U)),
        onDragOver: Ue(Ne(Zn, N)),
        onDragLeave: Ue(Ne(ln, q)),
        onDrop: Ue(Ne(Jn, j)),
        role: typeof _e == "string" && _e !== "" ? _e : "button"
      }, $e, R), !r && !x ? {
        tabIndex: 0
      } : {}), er);
    };
  }, [R, Q, X, me, I, U, N, q, j, x, $, r]), Gn = W(function(k) {
    k.stopPropagation();
  }, []), et = ge(function() {
    return function() {
      var k = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, K = k.refKey, $e = K === void 0 ? "ref" : K, _e = k.onChange, Me = k.onClick, Ft = Mn(k, Ih), xt = eo({
        accept: n,
        multiple: s,
        type: "file",
        style: {
          display: "none"
        },
        onChange: ve(Ne(_e, j)),
        onClick: ve(Ne(Me, Gn)),
        tabIndex: -1
      }, $e, T);
      return ue(ue({}, xt), Ft);
    };
  }, [T, n, s, j, r]), tt = ce.length, Nt = tt > 0 && wh({
    files: ce,
    accept: n,
    minSize: a,
    maxSize: i,
    multiple: s,
    maxFiles: c
  }), nt = tt > 0 && !Nt;
  return ue(ue({}, Z), {}, {
    isDragAccept: Nt,
    isDragReject: nt,
    isFocused: J && !r,
    getRootProps: Kn,
    getInputProps: et,
    rootRef: R,
    inputRef: T,
    open: ve(V)
  });
}
function Fh(e, t) {
  switch (t.type) {
    case "focus":
      return ue(ue({}, e), {}, {
        isFocused: !0
      });
    case "blur":
      return ue(ue({}, e), {}, {
        isFocused: !1
      });
    case "openDialog":
      return ue(ue({}, to), {}, {
        isFileDialogActive: !0
      });
    case "closeDialog":
      return ue(ue({}, e), {}, {
        isFileDialogActive: !1
      });
    case "setDraggedFiles":
      var n = t.isDragActive, r = t.draggedFiles;
      return ue(ue({}, e), {}, {
        draggedFiles: r,
        isDragActive: n
      });
    case "setFiles":
      return ue(ue({}, e), {}, {
        acceptedFiles: t.acceptedFiles,
        fileRejections: t.fileRejections
      });
    case "reset":
      return ue({}, to);
    default:
      return e;
  }
}
function Qi() {
}
function Bh(e) {
  let t;
  const n = /* @__PURE__ */ new Set(), r = (l, u) => {
    const f = typeof l == "function" ? l(t) : l;
    if (f !== t) {
      const d = t;
      t = u ? f : Object.assign({}, t, f), n.forEach((p) => p(t, d));
    }
  }, o = () => t, i = (l, u = o, f = Object.is) => {
    console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
    let d = u(t);
    function p() {
      const m = u(t);
      if (!f(d, m)) {
        const h = d;
        l(d = m, h);
      }
    }
    return n.add(p), () => n.delete(p);
  }, c = { setState: r, getState: o, subscribe: (l, u, f) => u || f ? i(l, u, f) : (n.add(l), () => n.delete(l)), destroy: () => n.clear() };
  return t = e(r, o, c), c;
}
const Wh = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent), Zi = Wh ? Y : Qe;
function Uh(e) {
  const t = typeof e == "function" ? Bh(e) : e, n = (r = t.getState, o = Object.is) => {
    const [, i] = oo((v) => v + 1, 0), a = t.getState(), s = _(a), c = _(r), l = _(o), u = _(!1), f = _();
    f.current === void 0 && (f.current = r(a));
    let d, p = !1;
    (s.current !== a || c.current !== r || l.current !== o || u.current) && (d = r(a), p = !o(f.current, d)), Zi(() => {
      p && (f.current = d), s.current = a, c.current = r, l.current = o, u.current = !1;
    });
    const m = _(a);
    Zi(() => {
      const v = () => {
        try {
          const y = t.getState(), w = c.current(y);
          l.current(f.current, w) || (s.current = y, f.current = w, i());
        } catch {
          u.current = !0, i();
        }
      }, b = t.subscribe(v);
      return t.getState() !== m.current && v(), b;
    }, []);
    const h = p ? d : f.current;
    return xc(h), h;
  };
  return Object.assign(n, t), n[Symbol.iterator] = function() {
    console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
    const r = [n, t];
    return {
      next() {
        const o = r.length <= 0;
        return { value: r.shift(), done: o };
      }
    };
  }, n;
}
const Vh = (e) => (t, n, r) => {
  const o = r.subscribe;
  return r.subscribe = (a, s, c) => {
    let l = a;
    if (s) {
      const u = (c == null ? void 0 : c.equalityFn) || Object.is;
      let f = a(r.getState());
      l = (d) => {
        const p = a(d);
        if (!u(f, p)) {
          const m = f;
          s(f = p, m);
        }
      }, c != null && c.fireImmediately && s(f, f);
    }
    return o(l);
  }, e(t, n, r);
};
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var br, Ji;
function Hh() {
  return Ji || (Ji = 1, br = function(t) {
    return t != null && typeof t == "object" && Array.isArray(t) === !1;
  }), br;
}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var yr, ea;
function uc() {
  if (ea) return yr;
  ea = 1;
  var e = Hh();
  function t(n) {
    return e(n) === !0 && Object.prototype.toString.call(n) === "[object Object]";
  }
  return yr = function(r) {
    var o, i;
    return !(t(r) === !1 || (o = r.constructor, typeof o != "function") || (i = o.prototype, t(i) === !1) || i.hasOwnProperty("isPrototypeOf") === !1);
  }, yr;
}
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var wr, ta;
function Co() {
  if (ta) return wr;
  ta = 1;
  var e = uc();
  return wr = function(n) {
    return e(n) || typeof n == "function" || Array.isArray(n);
  }, wr;
}
/*!
 * for-in <https://github.com/jonschlinkert/for-in>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var $r, na;
function Yh() {
  return na || (na = 1, $r = function(t, n, r) {
    for (var o in t)
      if (n.call(r, t[o], o, t) === !1)
        break;
  }), $r;
}
var xr, ra;
function qh() {
  if (ra) return xr;
  ra = 1;
  var e = Co(), t = Yh();
  function n(a, s) {
    for (var c = arguments.length, l = 0; ++l < c; ) {
      var u = arguments[l];
      o(u) && t(u, r, a);
    }
    return a;
  }
  function r(a, s) {
    if (i(s)) {
      var c = this[s];
      o(a) && o(c) ? n(c, a) : this[s] = a;
    }
  }
  function o(a) {
    return e(a) && !Array.isArray(a);
  }
  function i(a) {
    return a !== "__proto__" && a !== "constructor" && a !== "prototype";
  }
  return xr = n, xr;
}
/*!
 * get-value <https://github.com/jonschlinkert/get-value>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var Er, oa;
function Kh() {
  if (oa) return Er;
  oa = 1, Er = function(n, r, o, i, a) {
    if (!e(n) || !r)
      return n;
    if (r = t(r), o && (r += "." + t(o)), i && (r += "." + t(i)), a && (r += "." + t(a)), r in n)
      return n[r];
    for (var s = r.split("."), c = s.length, l = -1; n && ++l < c; ) {
      for (var u = s[l]; u[u.length - 1] === "\\"; )
        u = u.slice(0, -1) + "." + s[++l];
      n = n[u];
    }
    return n;
  };
  function e(n) {
    return n !== null && (typeof n == "object" || typeof n == "function");
  }
  function t(n) {
    return n ? Array.isArray(n) ? n.join(".") : n : "";
  }
  return Er;
}
/*!
 * assign-symbols <https://github.com/jonschlinkert/assign-symbols>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var Sr, ia;
function Gh() {
  return ia || (ia = 1, Sr = function(e, t) {
    if (e === null || typeof e > "u")
      throw new TypeError("expected first argument to be an object.");
    if (typeof t > "u" || typeof Symbol > "u" || typeof Object.getOwnPropertySymbols != "function")
      return e;
    for (var n = Object.prototype.propertyIsEnumerable, r = Object(e), o = arguments.length, i = 0; ++i < o; )
      for (var a = Object(arguments[i]), s = Object.getOwnPropertySymbols(a), c = 0; c < s.length; c++) {
        var l = s[c];
        n.call(a, l) && (r[l] = a[l]);
      }
    return r;
  }), Sr;
}
var Or, aa;
function Xh() {
  if (aa) return Or;
  aa = 1;
  var e = Co(), t = Gh();
  Or = Object.assign || function(s) {
    if (s === null || typeof s > "u")
      throw new TypeError("Cannot convert undefined or null to object");
    i(s) || (s = {});
    for (var c = 1; c < arguments.length; c++) {
      var l = arguments[c];
      r(l) && (l = o(l)), i(l) && (n(s, l), t(s, l));
    }
    return s;
  };
  function n(s, c) {
    for (var l in c)
      a(c, l) && (s[l] = c[l]);
  }
  function r(s) {
    return s && typeof s == "string";
  }
  function o(s) {
    var c = {};
    for (var l in s)
      c[l] = s[l];
    return c;
  }
  function i(s) {
    return s && typeof s == "object" || e(s);
  }
  function a(s, c) {
    return Object.prototype.hasOwnProperty.call(s, c);
  }
  return Or;
}
/*!
 * split-string <https://github.com/jonschlinkert/split-string>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var Pr, sa;
function Qh() {
  if (sa) return Pr;
  sa = 1;
  var e = Xh();
  Pr = function(o, i, a) {
    if (typeof o != "string")
      throw new TypeError("expected a string");
    typeof i == "function" && (a = i, i = null), typeof i == "string" && (i = { sep: i });
    var s = e({ sep: "." }, i), c = s.quotes || ['"', "'", "`"], l;
    s.brackets === !0 ? l = {
      "<": ">",
      "(": ")",
      "[": "]",
      "{": "}"
    } : s.brackets && (l = s.brackets);
    var u = [], f = [], d = [""], p = s.sep, m = o.length, h = -1, v;
    function b() {
      if (l && f.length)
        return l[f[f.length - 1]];
    }
    for (; ++h < m; ) {
      var y = o[h], w = o[h + 1], x = { val: y, idx: h, arr: d, str: o };
      if (u.push(x), y === "\\") {
        x.val = r(s, o, h) === !0 ? y + w : w, x.escaped = !0, typeof a == "function" && a(x), d[d.length - 1] += x.val, h++;
        continue;
      }
      if (l && l[y]) {
        f.push(y);
        var $ = b(), E = h + 1;
        if (o.indexOf($, E + 1) !== -1)
          for (; f.length && E < m; ) {
            var O = o[++E];
            if (O === "\\") {
              O++;
              continue;
            }
            if (c.indexOf(O) !== -1) {
              E = t(o, O, E + 1);
              continue;
            }
            if ($ = b(), f.length && o.indexOf($, E + 1) === -1)
              break;
            if (l[O]) {
              f.push(O);
              continue;
            }
            $ === O && f.pop();
          }
        if (v = E, v === -1) {
          d[d.length - 1] += y;
          continue;
        }
        y = o.slice(h, v + 1), x.val = y, x.idx = h = v;
      }
      if (c.indexOf(y) !== -1) {
        if (v = t(o, y, h + 1), v === -1) {
          d[d.length - 1] += y;
          continue;
        }
        n(y, s) === !0 ? y = o.slice(h, v + 1) : y = o.slice(h + 1, v), x.val = y, x.idx = h = v;
      }
      if (typeof a == "function" && (a(x, u), y = x.val, h = x.idx), x.val === p && x.split !== !1) {
        d.push("");
        continue;
      }
      d[d.length - 1] += x.val;
    }
    return d;
  };
  function t(o, i, a, s) {
    var c = o.indexOf(i, a);
    return o.charAt(c - 1) === "\\" ? t(o, i, c + 1) : c;
  }
  function n(o, i) {
    return i.keepDoubleQuotes === !0 && o === '"' || i.keepSingleQuotes === !0 && o === "'" ? !0 : i.keepQuotes;
  }
  function r(o, i, a) {
    return typeof o.keepEscaping == "function" ? o.keepEscaping(i, a) : o.keepEscaping === !0 || i[a + 1] === "\\";
  }
  return Pr;
}
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var Cr, ca;
function Zh() {
  return ca || (ca = 1, Cr = function(t) {
    return typeof t < "u" && t !== null && (typeof t == "object" || typeof t == "function");
  }), Cr;
}
var _r, la;
function Jh() {
  if (la) return _r;
  la = 1;
  var e = Zh();
  _r = function(o) {
    e(o) || (o = {});
    for (var i = arguments.length, a = 1; a < i; a++) {
      var s = arguments[a];
      e(s) && t(o, s);
    }
    return o;
  };
  function t(r, o) {
    for (var i in o)
      n(o, i) && (r[i] = o[i]);
  }
  function n(r, o) {
    return Object.prototype.hasOwnProperty.call(r, o);
  }
  return _r;
}
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var Tr, ua;
function eg() {
  return ua || (ua = 1, Tr = function(t) {
    return typeof t < "u" && t !== null && (typeof t == "object" || typeof t == "function");
  }), Tr;
}
/*!
 * set-value <https://github.com/jonschlinkert/set-value>
 *
 * Copyright (c) 2014-2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var Rr, fa;
function tg() {
  if (fa) return Rr;
  fa = 1;
  var e = Qh(), t = Jh(), n = uc(), r = eg();
  Rr = function(i, a, s) {
    if (!r(i) || (Array.isArray(a) && (a = [].concat.apply([], a).join(".")), typeof a != "string"))
      return i;
    for (var c = e(a, { sep: ".", brackets: !0 }).filter(o), l = c.length, u = -1, f = i; ++u < l; ) {
      var d = c[u];
      if (u !== l - 1) {
        r(f[d]) || (f[d] = {}), f = f[d];
        continue;
      }
      n(f[d]) && n(s) ? f[d] = t({}, f[d], s) : f[d] = s;
    }
    return i;
  };
  function o(i) {
    return i !== "__proto__" && i !== "constructor" && i !== "prototype";
  }
  return Rr;
}
var Ir, da;
function ng() {
  if (da) return Ir;
  da = 1;
  var e = Co(), t = qh(), n = Kh(), r = tg();
  return Ir = function(i, a, s) {
    if (!e(i))
      throw new TypeError("expected an object");
    if (typeof a != "string" || s == null)
      return t.apply(null, arguments);
    if (typeof s == "string")
      return r(i, a, s), i;
    var c = n(i, a);
    return e(s) && e(c) && (s = t({}, c, s)), r(i, a, s), i;
  }, Ir;
}
var rg = ng();
const og = /* @__PURE__ */ So(rg), _o = (...e) => e.filter(Boolean).join(".");
function ig(e) {
  const t = e.split(".");
  return [t.pop(), t.join(".") || void 0];
}
function ag(e, t) {
  return Object.entries(Yf(e, t)).reduce(
    (n, [, {
      value: r,
      disabled: o,
      key: i
    }]) => (n[i] = o ? void 0 : r, n),
    {}
  );
}
function sg(e, t) {
  const n = _();
  return Xt(e, n.current) || (n.current = e), n.current;
}
function fc(e, t) {
  return ge(e, sg(t));
}
function cg(e) {
  const t = _(null), n = _(null), r = _(!0);
  return Qe(() => {
    e || (t.current.style.height = "0px", t.current.style.overflow = "hidden");
  }, []), Y(() => {
    if (r.current) {
      r.current = !1;
      return;
    }
    let o;
    const i = t.current, a = () => {
      e && (i.style.removeProperty("height"), i.style.removeProperty("overflow"), n.current.scrollIntoView({
        behavior: "smooth",
        block: "nearest"
      }));
    };
    i.addEventListener("transitionend", a, {
      once: !0
    });
    const {
      height: s
    } = n.current.getBoundingClientRect();
    return i.style.height = s + "px", e || (i.style.overflow = "hidden", o = window.setTimeout(() => i.style.height = "0px", 50)), () => {
      i.removeEventListener("transitionend", a), clearTimeout(o);
    };
  }, [e]), {
    wrapperRef: t,
    contentRef: n
  };
}
const lg = (e) => {
  const [t, n] = oe(e.getVisiblePaths());
  return Y(() => {
    n(e.getVisiblePaths());
    const r = e.useStore.subscribe(e.getVisiblePaths, n, {
      equalityFn: Fn
    });
    return () => r();
  }, [e]), t;
};
function ug(e, t, n) {
  return e.useStore((o) => {
    const i = F(F({}, n), o.data);
    return ag(i, t);
  }, Fn);
}
function dc(e = 3) {
  const t = _(null), n = _(null), [r, o] = oe(!1), i = W(() => o(!0), []), a = W(() => o(!1), []);
  return Qe(() => {
    if (r) {
      const {
        bottom: s,
        top: c,
        left: l
      } = t.current.getBoundingClientRect(), {
        height: u
      } = n.current.getBoundingClientRect(), f = s + u > window.innerHeight - 40 ? "up" : "down";
      n.current.style.position = "fixed", n.current.style.zIndex = "10000", n.current.style.left = l + "px", f === "down" ? n.current.style.top = s + e + "px" : n.current.style.bottom = window.innerHeight - c + e + "px";
    }
  }, [e, r]), {
    popinRef: t,
    wrapperRef: n,
    shown: r,
    show: i,
    hide: a
  };
}
_p([Tp]);
const fg = {
  rgb: "toRgb",
  hsl: "toHsl",
  hsv: "toHsv",
  hex: "toHex"
};
Re.extend({
  color: () => (e) => Pe(e).isValid()
});
const dg = (e) => Re().color().test(e);
function pc(e, {
  format: t,
  hasAlpha: n,
  isString: r
}) {
  const o = fg[t] + (r && t !== "hex" ? "String" : ""), i = e[o]();
  return typeof i == "object" && !n ? qf(i, ["a"]) : i;
}
const hc = (e, t) => {
  const n = Pe(e);
  if (!n.isValid()) throw Error("Invalid color");
  return pc(n, t);
}, pg = (e, t) => pc(Pe(e), F(F({}, t), {}, {
  isString: !0,
  format: "hex"
})), hg = ({
  value: e
}) => {
  const t = Cp(e), n = t === "name" ? "hex" : t, r = typeof e == "object" ? "a" in e : t === "hex" && e.length === 8 || /^(rgba)|(hsla)|(hsva)/.test(e), o = {
    format: n,
    hasAlpha: r,
    isString: typeof e == "string"
  };
  return {
    value: hc(e, o),
    settings: o
  };
};
var gg = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  schema: dg,
  sanitize: hc,
  format: pg,
  normalize: hg
});
const mg = z("div", {
  position: "relative",
  boxSizing: "border-box",
  borderRadius: "$sm",
  overflow: "hidden",
  cursor: "pointer",
  height: "$rowHeight",
  width: "$rowHeight",
  backgroundColor: "#fff",
  backgroundImage: `url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>')`,
  $inputStyle: "",
  $hover: "",
  zIndex: 1,
  variants: {
    active: {
      true: {
        $inputStyle: "$accent1"
      }
    }
  },
  "&::before": {
    content: '""',
    position: "absolute",
    top: 0,
    bottom: 0,
    right: 0,
    left: 0,
    backgroundColor: "currentColor",
    zIndex: 1
  }
}), vg = z("div", {
  position: "relative",
  display: "grid",
  gridTemplateColumns: "$sizes$rowHeight auto",
  columnGap: "$colGap",
  alignItems: "center"
}), bg = z("div", {
  width: "$colorPickerWidth",
  height: "$colorPickerHeight",
  ".react-colorful": {
    width: "100%",
    height: "100%",
    boxShadow: "$level2",
    cursor: "crosshair"
  },
  ".react-colorful__saturation": {
    borderRadius: "$sm $sm 0 0"
  },
  ".react-colorful__alpha, .react-colorful__hue": {
    height: 10
  },
  ".react-colorful__last-control": {
    borderRadius: "0 0 $sm $sm"
  },
  ".react-colorful__pointer": {
    height: 12,
    width: 12
  }
});
function pa(e, t) {
  return t !== "rgb" ? Pe(e).toRgb() : e;
}
function yg({
  value: e,
  displayValue: t,
  settings: n,
  onUpdate: r
}) {
  const {
    emitOnEditStart: o,
    emitOnEditEnd: i
  } = Ee(), {
    format: a,
    hasAlpha: s
  } = n, {
    popinRef: c,
    wrapperRef: l,
    shown: u,
    show: f,
    hide: d
  } = dc(), p = _(0), [m, h] = oe(() => pa(e, a)), v = s ? jp : zp, b = () => {
    h(pa(e, a)), f(), o();
  }, y = () => {
    d(), i(), window.clearTimeout(p.current);
  }, w = () => {
    p.current = window.setTimeout(y, 500);
  };
  return Y(() => () => window.clearTimeout(p.current), []), g.createElement(g.Fragment, null, g.createElement(mg, {
    ref: c,
    active: u,
    onClick: () => b(),
    style: {
      color: t
    }
  }), u && g.createElement(vo, null, g.createElement(Ds, {
    onPointerUp: y
  }), g.createElement(bg, {
    ref: l,
    onMouseEnter: () => window.clearTimeout(p.current),
    onMouseLeave: (x) => x.buttons === 0 && w()
  }, g.createElement(v, {
    color: m,
    onChange: r
  }))));
}
function wg() {
  const {
    value: e,
    displayValue: t,
    label: n,
    onChange: r,
    onUpdate: o,
    settings: i
  } = Ee();
  return g.createElement(De, {
    input: !0
  }, g.createElement(Le, null, n), g.createElement(vg, null, g.createElement(yg, {
    value: e,
    displayValue: t,
    onChange: r,
    onUpdate: o,
    settings: i
  }), g.createElement(mo, {
    value: t,
    onChange: r,
    onUpdate: o
  })));
}
var $g = F({
  component: wg
}, gg);
function xg() {
  const {
    label: e,
    displayValue: t,
    onUpdate: n,
    settings: r
  } = Ee();
  return g.createElement(De, {
    input: !0
  }, g.createElement(Le, null, e), g.createElement(yo, {
    value: t,
    settings: r,
    onUpdate: n
  }));
}
var Eg = F({
  component: xg
}, Ws(["x", "y", "z"]));
const Sg = z("div", {
  $flexCenter: "",
  position: "relative",
  backgroundColor: "$elevation3",
  borderRadius: "$sm",
  cursor: "pointer",
  height: "$rowHeight",
  width: "$rowHeight",
  touchAction: "none",
  $draggable: "",
  $hover: "",
  "&:active": {
    cursor: "none"
  },
  "&::after": {
    content: '""',
    backgroundColor: "$accent2",
    height: 4,
    width: 4,
    borderRadius: 2
  }
}), Og = z("div", {
  $flexCenter: "",
  width: "$joystickWidth",
  height: "$joystickHeight",
  borderRadius: "$sm",
  boxShadow: "$level2",
  position: "fixed",
  zIndex: 1e4,
  overflow: "hidden",
  $draggable: "",
  transform: "translate(-50%, -50%)",
  variants: {
    isOutOfBounds: {
      true: {
        backgroundColor: "$elevation1"
      },
      false: {
        backgroundColor: "$elevation3"
      }
    }
  },
  "> div": {
    position: "absolute",
    $flexCenter: "",
    borderStyle: "solid",
    borderWidth: 1,
    borderColor: "$highlight1",
    backgroundColor: "$elevation3",
    width: "80%",
    height: "80%",
    "&::after,&::before": {
      content: '""',
      position: "absolute",
      zindex: 10,
      backgroundColor: "$highlight1"
    },
    "&::before": {
      width: "100%",
      height: 1
    },
    "&::after": {
      height: "100%",
      width: 1
    }
  },
  "> span": {
    position: "relative",
    zindex: 100,
    width: 10,
    height: 10,
    backgroundColor: "$accent2",
    borderRadius: "50%"
  }
});
function Pg({
  value: e,
  settings: t,
  onUpdate: n
}) {
  const r = _(), o = _(0), i = _(0), a = _(1), [s, c] = oe(!1), [l, u] = oe(!1), [f, d] = js(), p = _(null), m = _(null);
  Qe(() => {
    if (s) {
      const {
        top: A,
        left: M,
        width: Z,
        height: G
      } = p.current.getBoundingClientRect();
      m.current.style.left = M + Z / 2 + "px", m.current.style.top = A + G / 2 + "px";
    }
  }, [s]);
  const {
    keys: [h, v],
    joystick: b
  } = t, y = b === "invertY" ? 1 : -1, {
    [h]: {
      step: w
    },
    [v]: {
      step: x
    }
  } = t, $ = Ge("sizes", "joystickWidth"), E = Ge("sizes", "joystickHeight"), O = parseFloat($) * 0.8 / 2, C = parseFloat(E) * 0.8 / 2, B = W(() => {
    r.current || (u(!0), o.current && d({
      x: o.current * O
    }), i.current && d({
      y: i.current * -C
    }), r.current = window.setInterval(() => {
      n((A) => {
        const M = w * o.current * a.current, Z = y * x * i.current * a.current;
        return Array.isArray(A) ? {
          [h]: A[0] + M,
          [v]: A[1] + Z
        } : {
          [h]: A[h] + M,
          [v]: A[v] + Z
        };
      });
    }, 16));
  }, [O, C, n, d, w, x, h, v, y]), R = W(() => {
    window.clearTimeout(r.current), r.current = void 0, u(!1);
  }, []);
  Y(() => {
    function A(M) {
      a.current = ws(M);
    }
    return window.addEventListener("keydown", A), window.addEventListener("keyup", A), () => {
      window.clearTimeout(r.current), window.removeEventListener("keydown", A), window.removeEventListener("keyup", A);
    };
  }, []);
  const T = an(({
    first: A,
    active: M,
    delta: [Z, G],
    movement: [J, ie]
  }) => {
    A && c(!0);
    const ce = dt(J, -O, O), he = dt(ie, -C, C);
    o.current = Math.abs(J) > Math.abs(ce) ? Math.sign(J - ce) : 0, i.current = Math.abs(ie) > Math.abs(he) ? Math.sign(he - ie) : 0;
    let S = e[h], P = e[v];
    M ? (o.current || (S += Z * w * a.current, d({
      x: ce
    })), i.current || (P -= y * G * x * a.current, d({
      y: he
    })), o.current || i.current ? B() : R(), n({
      [h]: S,
      [v]: P
    })) : (c(!1), o.current = 0, i.current = 0, d({
      x: 0,
      y: 0
    }), R());
  });
  return g.createElement(Sg, pe({
    ref: p
  }, T()), s && g.createElement(vo, null, g.createElement(Og, {
    ref: m,
    isOutOfBounds: l
  }, g.createElement("div", null), g.createElement("span", {
    ref: f
  }))));
}
const Cg = z("div", {
  display: "grid",
  columnGap: "$colGap",
  variants: {
    withJoystick: {
      true: {
        gridTemplateColumns: "$sizes$rowHeight auto"
      },
      false: {
        gridTemplateColumns: "auto"
      }
    }
  }
});
function _g() {
  const {
    label: e,
    displayValue: t,
    onUpdate: n,
    settings: r
  } = Ee();
  return g.createElement(De, {
    input: !0
  }, g.createElement(Le, null, e), g.createElement(Cg, {
    withJoystick: !!r.joystick
  }, r.joystick && g.createElement(Pg, {
    value: t,
    settings: r,
    onUpdate: n
  }), g.createElement(yo, {
    value: t,
    settings: r,
    onUpdate: n
  })));
}
const Tg = ["joystick"], gc = Ws(["x", "y"]), Rg = (e) => {
  let {
    joystick: t = !0
  } = e, n = se(e, Tg);
  const {
    value: r,
    settings: o
  } = gc.normalize(n);
  return {
    value: r,
    settings: F(F({}, o), {}, {
      joystick: t
    })
  };
};
var Ig = F(F({
  component: _g
}, gc), {}, {
  normalize: Rg
});
const Ag = (e) => {
  if (e !== void 0) {
    if (e instanceof File)
      try {
        return URL.createObjectURL(e);
      } catch {
        return;
      }
    if (typeof e == "string" && e.indexOf("blob:") === 0) return e;
    throw Error("Invalid image format [undefined | blob | File].");
  }
}, kg = (e, t) => typeof t == "object" && "image" in t, Dg = ({
  image: e
}) => ({
  value: e
});
var Mg = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  sanitize: Ag,
  schema: kg,
  normalize: Dg
});
const jg = z("div", {
  position: "relative",
  display: "grid",
  gridTemplateColumns: "$sizes$rowHeight auto 20px",
  columnGap: "$colGap",
  alignItems: "center"
}), Lg = z("div", {
  $flexCenter: "",
  overflow: "hidden",
  height: "$rowHeight",
  background: "$elevation3",
  textAlign: "center",
  color: "inherit",
  borderRadius: "$sm",
  outline: "none",
  userSelect: "none",
  cursor: "pointer",
  $inputStyle: "",
  $hover: "",
  $focusWithin: "",
  $active: "$accent1 $elevation1",
  variants: {
    isDragAccept: {
      true: {
        $inputStyle: "$accent1",
        backgroundColor: "$elevation1"
      }
    }
  }
}), zg = z("div", {
  boxSizing: "border-box",
  borderRadius: "$sm",
  height: "$rowHeight",
  width: "$rowHeight",
  $inputStyle: "",
  backgroundSize: "cover",
  backgroundPosition: "center",
  variants: {
    hasImage: {
      true: {
        cursor: "pointer",
        $hover: "",
        $active: ""
      }
    }
  }
}), Ng = z("div", {
  $flexCenter: "",
  width: "$imagePreviewWidth",
  height: "$imagePreviewHeight",
  borderRadius: "$sm",
  boxShadow: "$level2",
  pointerEvents: "none",
  $inputStyle: "",
  backgroundSize: "cover",
  backgroundPosition: "center"
}), Fg = z("div", {
  fontSize: "0.8em",
  height: "100%",
  padding: "$rowGap $md"
}), Bg = z("div", {
  $flexCenter: "",
  top: "0",
  right: "0",
  marginRight: "$sm",
  height: "100%",
  cursor: "pointer",
  variants: {
    disabled: {
      true: {
        color: "$elevation3",
        cursor: "default"
      }
    }
  },
  "&::after,&::before": {
    content: '""',
    position: "absolute",
    height: 2,
    width: 10,
    borderRadius: 1,
    backgroundColor: "currentColor"
  },
  "&::after": {
    transform: "rotate(45deg)"
  },
  "&::before": {
    transform: "rotate(-45deg)"
  }
});
function Wg() {
  const {
    label: e,
    value: t,
    onUpdate: n,
    disabled: r
  } = Ee(), {
    popinRef: o,
    wrapperRef: i,
    shown: a,
    show: s,
    hide: c
  } = dc(), l = W((m) => {
    m.length && n(m[0]);
  }, [n]), u = W((m) => {
    m.stopPropagation(), n(void 0);
  }, [n]), {
    getRootProps: f,
    getInputProps: d,
    isDragAccept: p
  } = lc({
    maxFiles: 1,
    accept: "image/*",
    onDrop: l,
    disabled: r
  });
  return g.createElement(De, {
    input: !0
  }, g.createElement(Le, null, e), g.createElement(jg, null, g.createElement(zg, {
    ref: o,
    hasImage: !!t,
    onPointerDown: () => !!t && s(),
    onPointerUp: c,
    style: {
      backgroundImage: t ? `url(${t})` : "none"
    }
  }), a && !!t && g.createElement(vo, null, g.createElement(Ds, {
    onPointerUp: c,
    style: {
      cursor: "pointer"
    }
  }), g.createElement(Ng, {
    ref: i,
    style: {
      backgroundImage: `url(${t})`
    }
  })), g.createElement(Lg, f({
    isDragAccept: p
  }), g.createElement("input", d()), g.createElement(Fg, null, p ? "drop image" : "click or drop")), g.createElement(Bg, {
    onClick: u,
    disabled: !t
  })));
}
var Ug = F({
  component: Wg
}, Mg);
const ha = Re().number(), Vg = (e, t) => Re().array().length(2).every.number().test(e) && Re().schema({
  min: ha,
  max: ha
}).test(t), jn = (e) => ({
  min: e[0],
  max: e[1]
}), mc = (e, {
  bounds: [t, n]
}, r) => {
  const o = Array.isArray(e) ? jn(e) : e, i = {
    min: r[0],
    max: r[1]
  }, {
    min: a,
    max: s
  } = F(F({}, i), o);
  return [dt(Number(a), t, Math.max(t, s)), dt(Number(s), Math.min(n, a), n)];
}, Hg = ({
  value: e,
  min: t,
  max: n
}) => {
  const r = {
    min: t,
    max: n
  }, o = Bs(jn(e), {
    min: r,
    max: r
  }), i = [t, n], a = F(F({}, o), {}, {
    bounds: i
  });
  return {
    value: mc(jn(e), a, e),
    settings: a
  };
};
var Yg = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  schema: Vg,
  format: jn,
  sanitize: mc,
  normalize: Hg
});
const qg = ["value", "bounds", "onDrag"], Kg = ["bounds"], Gg = z("div", {
  display: "grid",
  columnGap: "$colGap",
  gridTemplateColumns: "auto calc($sizes$numberInputMinWidth * 2 + $space$rowGap)"
});
function Xg(e) {
  let {
    value: t,
    bounds: [n, r],
    onDrag: o
  } = e, i = se(e, qg);
  const a = _(null), s = _(null), c = _(null), l = _(0), u = Ge("sizes", "scrubberWidth"), f = an(({
    event: m,
    first: h,
    xy: [v],
    movement: [b],
    memo: y = {}
  }) => {
    if (h) {
      const {
        width: x,
        left: $
      } = a.current.getBoundingClientRect();
      l.current = x - parseFloat(u);
      const E = (m == null ? void 0 : m.target) === s.current || (m == null ? void 0 : m.target) === c.current;
      y.pos = In((v - $) / x, n, r);
      const O = Math.abs(y.pos - t.min) - Math.abs(y.pos - t.max);
      y.key = O < 0 || O === 0 && y.pos <= t.min ? "min" : "max", E && (y.pos = t[y.key]);
    }
    const w = y.pos + In(b / l.current, 0, r - n);
    return o({
      [y.key]: Dd(w, i[y.key])
    }), y;
  }), d = `calc(${Rn(t.min, n, r)} * (100% - ${u} - 8px) + 4px)`, p = `calc(${1 - Rn(t.max, n, r)} * (100% - ${u} - 8px) + 4px)`;
  return g.createElement(zs, pe({
    ref: a
  }, f()), g.createElement(Ls, null, g.createElement(Ns, {
    style: {
      left: d,
      right: p
    }
  })), g.createElement(Hr, {
    position: "left",
    ref: s,
    style: {
      left: d
    }
  }), g.createElement(Hr, {
    position: "right",
    ref: c,
    style: {
      right: p
    }
  }));
}
function Qg() {
  const {
    label: e,
    displayValue: t,
    onUpdate: n,
    settings: r
  } = Ee(), o = se(r, Kg);
  return g.createElement(g.Fragment, null, g.createElement(De, {
    input: !0
  }, g.createElement(Le, null, e), g.createElement(Gg, null, g.createElement(Xg, pe({
    value: t
  }, r, {
    onDrag: n
  })), g.createElement(yo, {
    value: t,
    settings: o,
    onUpdate: n,
    innerLabelTrim: 0
  }))));
}
var Zg = F({
  component: Qg
}, Yg);
const Jg = () => {
  const e = /* @__PURE__ */ new Map();
  return {
    on: (t, n) => {
      let r = e.get(t);
      r === void 0 && (r = /* @__PURE__ */ new Set(), e.set(t, r)), r.add(n);
    },
    off: (t, n) => {
      const r = e.get(t);
      r !== void 0 && (r.delete(n), r.size === 0 && e.delete(t));
    },
    emit: (t, ...n) => {
      const r = e.get(t);
      if (r !== void 0)
        for (const o of r)
          o(...n);
    }
  };
}, em = ["type", "value"], tm = ["onChange", "transient", "onEditStart", "onEditEnd"], nm = function() {
  const t = Uh(Vh(() => ({
    data: {}
  }))), n = Jg();
  this.storeId = Hf(), this.useStore = t;
  const r = {}, o = /* @__PURE__ */ new Set();
  this.getVisiblePaths = () => {
    const a = this.getData(), s = Object.keys(a), c = [];
    Object.entries(r).forEach(([u, f]) => {
      f.render && s.some((d) => d.indexOf(u) === 0) && !f.render(this.get) && c.push(u + ".");
    });
    const l = [];
    return o.forEach((u) => {
      u in a && a[u].__refCount > 0 && c.every((f) => u.indexOf(f) === -1) && (!a[u].render || a[u].render(this.get)) && l.push(u);
    }), l;
  }, this.setOrderedPaths = (a) => {
    a.forEach((s) => o.add(s));
  }, this.orderPaths = (a) => (this.setOrderedPaths(a), a), this.disposePaths = (a) => {
    t.setState((s) => {
      const c = s.data;
      return a.forEach((l) => {
        if (l in c) {
          const u = c[l];
          u.__refCount--, u.__refCount === 0 && u.type in ke && delete c[l];
        }
      }), {
        data: c
      };
    });
  }, this.dispose = () => {
    t.setState(() => ({
      data: {}
    }));
  }, this.getFolderSettings = (a) => r[a] || {}, this.getData = () => t.getState().data, this.addData = (a, s) => {
    t.setState((c) => {
      const l = c.data;
      return Object.entries(a).forEach(([u, f]) => {
        let d = l[u];
        if (d) {
          const {
            type: p,
            value: m
          } = f, h = se(f, em);
          p !== d.type ? Ye(fe.INPUT_TYPE_OVERRIDE, p) : ((d.__refCount === 0 || s) && Object.assign(d, h), d.__refCount++);
        } else
          l[u] = F(F({}, f), {}, {
            __refCount: 1
          });
      }), {
        data: l
      };
    });
  }, this.setValueAtPath = (a, s, c) => {
    t.setState((l) => {
      const u = l.data;
      return yi(u[a], s, a, this, c), {
        data: u
      };
    });
  }, this.setSettingsAtPath = (a, s) => {
    t.setState((c) => {
      const l = c.data;
      return l[a].settings = F(F({}, l[a].settings), s), {
        data: l
      };
    });
  }, this.disableInputAtPath = (a, s) => {
    t.setState((c) => {
      const l = c.data;
      return l[a].disabled = s, {
        data: l
      };
    });
  }, this.set = (a, s) => {
    t.setState((c) => {
      const l = c.data;
      return Object.entries(a).forEach(([u, f]) => {
        try {
          yi(l[u], f, void 0, void 0, s);
        } catch (d) {
          process.env.NODE_ENV === "development" && console.warn(`[This message will only show in development]: \`set\` for path ${u} has failed.`, d);
        }
      }), {
        data: l
      };
    });
  }, this.getInput = (a) => {
    try {
      return this.getData()[a];
    } catch {
      Ye(fe.PATH_DOESNT_EXIST, a);
    }
  }, this.get = (a) => {
    var s;
    return (s = this.getInput(a)) === null || s === void 0 ? void 0 : s.value;
  }, this.emitOnEditStart = (a) => {
    n.emit(`onEditStart:${a}`, this.get(a), a, F(F({}, this.getInput(a)), {}, {
      get: this.get
    }));
  }, this.emitOnEditEnd = (a) => {
    n.emit(`onEditEnd:${a}`, this.get(a), a, F(F({}, this.getInput(a)), {}, {
      get: this.get
    }));
  }, this.subscribeToEditStart = (a, s) => {
    const c = `onEditStart:${a}`;
    return n.on(c, s), () => n.off(c, s);
  }, this.subscribeToEditEnd = (a, s) => {
    const c = `onEditEnd:${a}`;
    return n.on(c, s), () => n.off(c, s);
  };
  const i = (a, s, c) => {
    const l = {};
    return Object.entries(a).forEach(([u, f]) => {
      if (u === "") return Ye(fe.EMPTY_KEY);
      let d = _o(s, u);
      if (f.type === ke.FOLDER) {
        const p = i(f.schema, d, c);
        Object.assign(l, p), d in r || (r[d] = f.settings);
      } else if (u in c)
        Ye(fe.DUPLICATE_KEYS, u, d, c[u].path);
      else {
        const p = Jf(f, u, d, l);
        if (p) {
          const {
            type: m,
            options: h,
            input: v
          } = p, {
            onChange: b,
            transient: y,
            onEditStart: w,
            onEditEnd: x
          } = h, $ = se(h, tm);
          l[d] = F(F(F({
            type: m
          }, $), v), {}, {
            fromPanel: !0
          }), c[u] = {
            path: d,
            onChange: b,
            transient: y,
            onEditStart: w,
            onEditEnd: x
          };
        } else
          Ye(fe.UNKNOWN_INPUT, d, f);
      }
    }), l;
  };
  this.getDataFromSchema = (a) => {
    const s = {};
    return [i(a, "", s), s];
  };
}, To = new nm();
process.env.NODE_ENV === "development" && typeof window < "u" && (window.__STORE = To);
const rm = {
  collapsed: !1
};
function Ht(e, t) {
  return {
    type: ke.FOLDER,
    schema: e,
    settings: F(F({}, rm), t)
  };
}
const om = {
  disabled: !1
};
function ga(e, t) {
  return {
    type: ke.BUTTON,
    onClick: e,
    settings: F(F({}, om), t)
  };
}
const ma = (e) => "__levaInput" in e, im = (e, t) => {
  const n = {}, r = t ? t.toLowerCase() : null;
  return e.forEach((o) => {
    const [i, a] = ig(o);
    (!r || i.toLowerCase().indexOf(r) > -1) && og(n, a, {
      [i]: {
        __levaInput: !0,
        path: o
      }
    });
  }), n;
}, am = ["type", "label", "path", "valueKey", "value", "settings", "setValue", "disabled"];
function sm(e) {
  let {
    type: t,
    label: n,
    path: r,
    valueKey: o,
    value: i,
    settings: a,
    setValue: s,
    disabled: c
  } = e, l = se(e, am);
  const {
    displayValue: u,
    onChange: f,
    onUpdate: d
  } = Ms({
    type: t,
    value: i,
    settings: a,
    setValue: s
  }), p = bt[t].component;
  return p ? g.createElement(Os.Provider, {
    value: F({
      key: o,
      path: r,
      id: "" + r,
      label: n,
      displayValue: u,
      value: i,
      onChange: f,
      onUpdate: d,
      settings: a,
      setValue: s,
      disabled: c
    }, l)
  }, g.createElement(bd, {
    disabled: c
  }, g.createElement(p, null))) : (Ye(fe.NO_COMPONENT_FOR_TYPE, t, r), null);
}
const cm = z("button", {
  display: "block",
  $reset: "",
  fontWeight: "$button",
  height: "$rowHeight",
  borderStyle: "none",
  borderRadius: "$sm",
  backgroundColor: "$elevation1",
  color: "$highlight1",
  "&:not(:disabled)": {
    color: "$highlight3",
    backgroundColor: "$accent2",
    cursor: "pointer",
    $hover: "$accent3",
    $active: "$accent3 $accent1",
    $focus: ""
  }
});
function lm({
  onClick: e,
  settings: t,
  label: n
}) {
  const r = on();
  return g.createElement(De, null, g.createElement(cm, {
    disabled: t.disabled,
    onClick: () => e(r.get)
  }, n));
}
const um = z("div", {
  $flex: "",
  justifyContent: "flex-end",
  gap: "$colGap"
}), fm = z("button", {
  $reset: "",
  cursor: "pointer",
  borderRadius: "$xs",
  "&:hover": {
    backgroundColor: "$elevation3"
  }
}), dm = ({
  label: e,
  opts: t
}) => {
  let n = typeof e == "string" && e.trim() === "" ? null : e, r = t;
  return typeof t.opts == "object" && (r.label !== void 0 && (n = t.label), r = t.opts), {
    label: n,
    opts: r
  };
};
function pm(e) {
  const {
    label: t,
    opts: n
  } = dm(e), r = on();
  return g.createElement(De, {
    input: !!t
  }, t && g.createElement(Le, null, t), g.createElement(um, null, Object.entries(n).map(([o, i]) => g.createElement(fm, {
    key: o,
    onClick: () => i(r.get)
  }, o))));
}
const hm = z("canvas", {
  height: "$monitorHeight",
  width: "100%",
  display: "block",
  borderRadius: "$sm"
}), vc = 100;
function gm(e, t) {
  e.push(t), e.length > vc && e.shift();
}
const mm = be(function({
  initialValue: e
}, t) {
  const n = Ge("colors", "highlight3"), r = Ge("colors", "elevation2"), o = Ge("colors", "highlight1"), [i, a] = ge(() => [Pe(o).alpha(0.4).toRgbString(), Pe(o).alpha(0.1).toRgbString()], [o]), s = _([e]), c = _(e), l = _(e), u = _(), f = W((m, h) => {
    if (!m) return;
    const {
      width: v,
      height: b
    } = m, y = new Path2D(), w = v / vc, x = b * 0.05;
    for (let O = 0; O < s.current.length; O++) {
      const C = Rn(s.current[O], c.current, l.current), B = w * O, R = b - C * (b - x * 2) - x;
      y.lineTo(B, R);
    }
    h.clearRect(0, 0, v, b);
    const $ = new Path2D(y);
    $.lineTo(w * (s.current.length + 1), b), $.lineTo(0, b), $.lineTo(0, 0);
    const E = h.createLinearGradient(0, 0, 0, b);
    E.addColorStop(0, i), E.addColorStop(1, a), h.fillStyle = E, h.fill($), h.strokeStyle = r, h.lineJoin = "round", h.lineWidth = 14, h.stroke(y), h.strokeStyle = n, h.lineWidth = 2, h.stroke(y);
  }, [n, r, i, a]), [d, p] = Cd(f);
  return Nn(t, () => ({
    frame: (m) => {
      (c.current === void 0 || m < c.current) && (c.current = m), (l.current === void 0 || m > l.current) && (l.current = m), gm(s.current, m), u.current = requestAnimationFrame(() => f(d.current, p.current));
    }
  }), [d, p, f]), Y(() => () => cancelAnimationFrame(u.current), []), g.createElement(hm, {
    ref: d
  });
}), va = (e) => Number.isFinite(e) ? e.toPrecision(2) : e.toString(), vm = be(function({
  initialValue: e
}, t) {
  const [n, r] = oe(va(e));
  return Nn(t, () => ({
    frame: (o) => r(va(o))
  }), []), g.createElement("div", null, n);
});
function ba(e) {
  return typeof e == "function" ? e() : e.current;
}
function bm({
  label: e,
  objectOrFn: t,
  settings: n
}) {
  const r = _(), o = _(ba(t));
  return Y(() => {
    const i = window.setInterval(() => {
      var a;
      document.hidden || (a = r.current) === null || a === void 0 || a.frame(ba(t));
    }, n.interval);
    return () => window.clearInterval(i);
  }, [t, n.interval]), g.createElement(De, {
    input: !0
  }, g.createElement(Le, {
    align: "top"
  }, e), n.graph ? g.createElement(mm, {
    ref: r,
    initialValue: o.current
  }) : g.createElement(vm, {
    ref: r,
    initialValue: o.current
  }));
}
const ym = ["type", "label", "key"], wm = {
  [ke.BUTTON]: lm,
  [ke.BUTTON_GROUP]: pm,
  [ke.MONITOR]: bm
}, $m = g.memo(({
  path: e
}) => {
  const [t, {
    set: n,
    setSettings: r,
    disable: o,
    storeId: i,
    emitOnEditStart: a,
    emitOnEditEnd: s
  }] = Td(e);
  if (!t) return null;
  const {
    type: c,
    label: l,
    key: u
  } = t, f = se(t, ym);
  if (c in ke) {
    const d = wm[c];
    return g.createElement(d, pe({
      label: l,
      path: e
    }, f));
  }
  return c in bt ? g.createElement(sm, pe({
    key: i + e,
    type: c,
    label: l,
    storeId: i,
    path: e,
    valueKey: u,
    setValue: n,
    setSettings: r,
    disable: o,
    emitOnEditStart: a,
    emitOnEditEnd: s
  }, f)) : (Lf(fe.UNSUPPORTED_INPUT, c, e), null);
});
function xm({
  toggle: e,
  toggled: t,
  name: n
}) {
  return g.createElement(gd, {
    onClick: () => e()
  }, g.createElement(bo, {
    toggled: t
  }), g.createElement("div", null, n));
}
const Em = ({
  name: e,
  path: t,
  tree: n
}) => {
  const r = on(), o = _o(t, e), {
    collapsed: i,
    color: a
  } = r.getFolderSettings(o), [s, c] = oe(!i), l = _(null), u = Ge("colors", "folderWidgetColor"), f = Ge("colors", "folderTextColor");
  return Qe(() => {
    l.current.style.setProperty("--leva-colors-folderWidgetColor", a || u), l.current.style.setProperty("--leva-colors-folderTextColor", a || f);
  }, [a, u, f]), g.createElement(An, {
    ref: l
  }, g.createElement(xm, {
    name: e,
    toggled: s,
    toggle: () => c((d) => !d)
  }), g.createElement(bc, {
    parent: o,
    tree: n,
    toggled: s
  }));
}, bc = g.memo(({
  isRoot: e = !1,
  fill: t = !1,
  flat: n = !1,
  parent: r,
  tree: o,
  toggled: i
}) => {
  const {
    wrapperRef: a,
    contentRef: s
  } = cg(i), c = on(), l = ([f, d]) => {
    var p;
    return (ma(d) ? (p = c.getInput(d.path)) === null || p === void 0 ? void 0 : p.order : c.getFolderSettings(_o(r, f)).order) || 0;
  }, u = Object.entries(o).sort((f, d) => l(f) - l(d));
  return g.createElement(Ur, {
    ref: a,
    isRoot: e,
    fill: t,
    flat: n
  }, g.createElement(Is, {
    ref: s,
    isRoot: e,
    toggled: i
  }, u.map(([f, d]) => ma(d) ? g.createElement($m, {
    key: d.path,
    valueKey: d.valueKey,
    path: d.path
  }) : g.createElement(Em, {
    key: f,
    name: f,
    path: r,
    tree: d
  }))));
}), Sm = z("div", {
  position: "relative",
  fontFamily: "$mono",
  fontSize: "$root",
  color: "$rootText",
  backgroundColor: "$elevation1",
  variants: {
    fill: {
      false: {
        position: "fixed",
        top: "10px",
        right: "10px",
        zIndex: 1e3,
        width: "$rootWidth"
      },
      true: {
        position: "relative",
        width: "100%"
      }
    },
    flat: {
      false: {
        borderRadius: "$lg",
        boxShadow: "$level1"
      }
    },
    oneLineLabels: {
      true: {
        [`${ks}`]: {
          gridTemplateColumns: "auto",
          gridAutoColumns: "minmax(max-content, 1fr)",
          gridAutoRows: "minmax($sizes$rowHeight), auto)",
          rowGap: 0,
          columnGap: 0,
          marginTop: "$rowGap"
        }
      }
    },
    hideTitleBar: {
      true: {
        $$titleBarHeight: "0px"
      },
      false: {
        $$titleBarHeight: "$sizes$titleBarHeight"
      }
    }
  },
  "&,*,*:after,*:before": {
    boxSizing: "border-box"
  },
  "*::selection": {
    backgroundColor: "$accent2"
  }
}), yc = 40, Ln = z("i", {
  $flexCenter: "",
  width: yc,
  userSelect: "none",
  cursor: "pointer",
  "> svg": {
    fill: "$highlight1",
    transition: "transform 350ms ease, fill 250ms ease"
  },
  "&:hover > svg": {
    fill: "$highlight3"
  },
  variants: {
    active: {
      true: {
        "> svg": {
          fill: "$highlight2"
        }
      }
    }
  }
}), Om = z("div", {
  display: "flex",
  alignItems: "stretch",
  justifyContent: "space-between",
  height: "$titleBarHeight",
  variants: {
    mode: {
      drag: {
        cursor: "grab"
      }
    }
  }
}), Pm = z("div", {
  $flex: "",
  position: "relative",
  width: "100%",
  overflow: "hidden",
  transition: "height 250ms ease",
  color: "$highlight3",
  paddingLeft: "$md",
  [`> ${Ln}`]: {
    height: 30
  },
  variants: {
    toggled: {
      true: {
        height: 30
      },
      false: {
        height: 0
      }
    }
  }
}), Cm = z("input", {
  $reset: "",
  flex: 1,
  position: "relative",
  height: 30,
  width: "100%",
  backgroundColor: "transparent",
  fontSize: "10px",
  borderRadius: "$root",
  "&:focus": {},
  "&::placeholder": {
    color: "$highlight2"
  }
}), _m = z("div", {
  touchAction: "none",
  $flexCenter: "",
  flex: 1,
  "> svg": {
    fill: "$highlight1"
  },
  color: "$highlight1",
  variants: {
    drag: {
      true: {
        $draggable: "",
        "> svg": {
          transition: "fill 250ms ease"
        },
        "&:hover": {
          color: "$highlight3"
        },
        "&:hover > svg": {
          fill: "$highlight3"
        }
      }
    },
    filterEnabled: {
      false: {
        paddingRight: yc
      }
    }
  }
}), Tm = g.forwardRef(({
  setFilter: e,
  toggle: t
}, n) => {
  const [r, o] = oe(""), i = ge(() => ys(e, 250), [e]), a = () => {
    e(""), o("");
  }, s = (c) => {
    const l = c.currentTarget.value;
    t(!0), o(l);
  };
  return Y(() => {
    i(r);
  }, [r, i]), g.createElement(g.Fragment, null, g.createElement(Cm, {
    ref: n,
    value: r,
    placeholder: "[Open filter with CMD+SHIFT+L]",
    onPointerDown: (c) => c.stopPropagation(),
    onChange: s
  }), g.createElement(Ln, {
    onClick: () => a(),
    style: {
      visibility: r ? "visible" : "hidden"
    }
  }, g.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    height: "14",
    width: "14",
    viewBox: "0 0 20 20",
    fill: "currentColor"
  }, g.createElement("path", {
    fillRule: "evenodd",
    d: "M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z",
    clipRule: "evenodd"
  }))));
});
function Rm({
  setFilter: e,
  onDrag: t,
  onDragStart: n,
  onDragEnd: r,
  toggle: o,
  toggled: i,
  title: a,
  drag: s,
  filterEnabled: c,
  from: l
}) {
  const [u, f] = oe(!1), d = _(null);
  Y(() => {
    var m, h;
    u ? (m = d.current) === null || m === void 0 || m.focus() : (h = d.current) === null || h === void 0 || h.blur();
  }, [u]);
  const p = an(({
    offset: [m, h],
    first: v,
    last: b
  }) => {
    t({
      x: m,
      y: h
    }), v && n({
      x: m,
      y: h
    }), b && r({
      x: m,
      y: h
    });
  }, {
    filterTaps: !0,
    from: ({
      offset: [m, h]
    }) => [(l == null ? void 0 : l.x) || m, (l == null ? void 0 : l.y) || h]
  });
  return Y(() => {
    const m = (h) => {
      h.key === "L" && h.shiftKey && h.metaKey && f((v) => !v);
    };
    return window.addEventListener("keydown", m), () => window.removeEventListener("keydown", m);
  }, []), g.createElement(g.Fragment, null, g.createElement(Om, {
    mode: s ? "drag" : void 0
  }, g.createElement(Ln, {
    active: !i,
    onClick: () => o()
  }, g.createElement(bo, {
    toggled: i,
    width: 12,
    height: 8
  })), g.createElement(_m, pe({}, s ? p() : {}, {
    drag: s,
    filterEnabled: c
  }), a === void 0 && s ? g.createElement("svg", {
    width: "20",
    height: "10",
    viewBox: "0 0 28 14",
    xmlns: "http://www.w3.org/2000/svg"
  }, g.createElement("circle", {
    cx: "2",
    cy: "2",
    r: "2"
  }), g.createElement("circle", {
    cx: "14",
    cy: "2",
    r: "2"
  }), g.createElement("circle", {
    cx: "26",
    cy: "2",
    r: "2"
  }), g.createElement("circle", {
    cx: "2",
    cy: "12",
    r: "2"
  }), g.createElement("circle", {
    cx: "14",
    cy: "12",
    r: "2"
  }), g.createElement("circle", {
    cx: "26",
    cy: "12",
    r: "2"
  })) : a), c && g.createElement(Ln, {
    active: u,
    onClick: () => f((m) => !m)
  }, g.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    height: "20",
    viewBox: "0 0 20 20"
  }, g.createElement("path", {
    d: "M9 9a2 2 0 114 0 2 2 0 01-4 0z"
  }), g.createElement("path", {
    fillRule: "evenodd",
    d: "M10 18a8 8 0 100-16 8 8 0 000 16zm1-13a4 4 0 00-3.446 6.032l-2.261 2.26a1 1 0 101.414 1.415l2.261-2.261A4 4 0 1011 5z",
    clipRule: "evenodd"
  })))), g.createElement(Pm, {
    toggled: u
  }, g.createElement(Tm, {
    ref: d,
    setFilter: e,
    toggle: o
  })));
}
const Im = ["store", "hidden", "theme", "collapsed"];
function Am(e) {
  let {
    store: t,
    hidden: n = !1,
    theme: r,
    collapsed: o = !1
  } = e, i = se(e, Im);
  const a = fc(() => ld(r), [r]), [s, c] = oe(!o), l = typeof o == "object" ? !o.collapsed : s, u = ge(() => typeof o == "object" ? (f) => {
    typeof f == "function" ? o.onChange(!f(!o.collapsed)) : o.onChange(!f);
  } : c, [o]);
  return !t || n ? null : g.createElement(go.Provider, {
    value: a
  }, g.createElement(km, pe({
    store: t
  }, i, {
    toggled: l,
    setToggle: u,
    rootClass: a.className
  })));
}
const km = g.memo(({
  store: e,
  rootClass: t,
  fill: n = !1,
  flat: r = !1,
  neverHide: o = !1,
  oneLineLabels: i = !1,
  titleBar: a = {
    title: void 0,
    drag: !0,
    filter: !0,
    position: void 0,
    onDrag: void 0,
    onDragStart: void 0,
    onDragEnd: void 0
  },
  hideCopyButton: s = !1,
  toggled: c,
  setToggle: l
}) => {
  var u, f;
  const d = lg(e), [p, m] = oe(""), h = ge(() => im(d, p), [d, p]), [v, b] = js(), y = o || d.length > 0, w = typeof a == "object" && a.title || void 0, x = typeof a == "object" && (u = a.drag) !== null && u !== void 0 ? u : !0, $ = typeof a == "object" && (f = a.filter) !== null && f !== void 0 ? f : !0, E = typeof a == "object" && a.position || void 0, O = typeof a == "object" && a.onDrag || void 0, C = typeof a == "object" && a.onDragStart || void 0, B = typeof a == "object" && a.onDragEnd || void 0;
  return g.useEffect(() => {
    b({
      x: E == null ? void 0 : E.x,
      y: E == null ? void 0 : E.y
    });
  }, [E, b]), cd(), g.createElement(Cs.Provider, {
    value: {
      hideCopyButton: s
    }
  }, g.createElement(Sm, {
    ref: v,
    className: t,
    fill: n,
    flat: r,
    oneLineLabels: i,
    hideTitleBar: !a,
    style: {
      display: y ? "block" : "none"
    }
  }, a && g.createElement(Rm, {
    onDrag: (R) => {
      b(R), O == null || O(R);
    },
    onDragStart: (R) => C == null ? void 0 : C(R),
    onDragEnd: (R) => B == null ? void 0 : B(R),
    setFilter: m,
    toggle: (R) => l((T) => R ?? !T),
    toggled: c,
    title: w,
    drag: x,
    filterEnabled: $,
    from: E
  }), y && g.createElement(Ps.Provider, {
    value: e
  }, g.createElement(bc, {
    isRoot: !0,
    fill: n,
    flat: r,
    tree: h,
    toggled: c
  }))));
}), Dm = ["isRoot"];
let zn = !1, ht = null;
function Mm(e) {
  let {
    isRoot: t = !1
  } = e, n = se(e, Dm);
  return Y(() => (zn = !0, !t && ht && (ht.remove(), ht = null), () => {
    t || (zn = !1);
  }), [t]), g.createElement(Am, pe({
    store: To
  }, n));
}
function jm(e) {
  Y(() => {
    e && !zn && (ht || (ht = document.getElementById("leva__root") || Object.assign(document.createElement("div"), {
      id: "leva__root"
    }), document.body && (document.body.appendChild(ht), Tc(ht).render(g.createElement(Mm, {
      isRoot: !0
    })))), zn = !0);
  }, [e]);
}
function Lm(e, t, n, r, o) {
  let i, a, s, c, l;
  return typeof e == "string" ? (a = e, i = t, Array.isArray(n) && (l = n)) : (i = e, Array.isArray(t) ? l = t : (c = t, l = n)), {
    schema: i,
    folderName: a,
    folderSettings: s,
    hookSettings: c,
    deps: l || []
  };
}
function ya(e, t, n, r, o) {
  const {
    folderName: i,
    schema: a,
    folderSettings: s,
    hookSettings: c,
    deps: l
  } = Lm(e, t, n), u = typeof a == "function", f = _(!1), d = _(!0), p = fc(() => {
    f.current = !0;
    const T = typeof a == "function" ? a() : a;
    return i ? {
      [i]: Ht(T, s)
    } : T;
  }, l), m = !(c != null && c.store);
  jm(m);
  const [h] = oe(() => (c == null ? void 0 : c.store) || To), [v, b] = ge(() => h.getDataFromSchema(p), [h, p]), [y, w, x, $, E] = ge(() => {
    const T = [], A = [], M = {}, Z = {}, G = {};
    return Object.values(b).forEach(({
      path: J,
      onChange: ie,
      onEditStart: ce,
      onEditEnd: he,
      transient: S
    }) => {
      T.push(J), ie ? (M[J] = ie, S || A.push(J)) : A.push(J), ce && (Z[J] = ce), he && (G[J] = he);
    }), [T, A, M, Z, G];
  }, [b]), O = ge(() => h.orderPaths(y), [y, h]), C = ug(h, w, v), B = W((T) => {
    const A = Object.entries(T).reduce((M, [Z, G]) => Object.assign(M, {
      [b[Z].path]: G
    }), {});
    h.set(A, !1);
  }, [h, b]), R = W((T) => h.get(b[T].path), [h, b]);
  return Y(() => {
    const T = !d.current && f.current;
    return h.addData(v, T), d.current = !1, f.current = !1, () => h.disposePaths(O);
  }, [h, O, v]), Y(() => {
    const T = [];
    return Object.entries(x).forEach(([A, M]) => {
      M(h.get(A), A, F({
        initial: !0,
        get: h.get
      }, h.getInput(A)));
      const Z = h.useStore.subscribe((G) => {
        const J = G.data[A];
        return [J.disabled ? void 0 : J.value, J];
      }, ([G, J]) => M(G, A, F({
        initial: !1,
        get: h.get
      }, J)), {
        equalityFn: Fn
      });
      T.push(Z);
    }), () => T.forEach((A) => A());
  }, [h, x]), Y(() => {
    const T = [];
    return Object.entries($).forEach(([A, M]) => T.push(h.subscribeToEditStart(A, M))), Object.entries(E).forEach(([A, M]) => T.push(h.subscribeToEditEnd(A, M))), () => T.forEach((A) => A());
  }, [$, E, h]), u ? [C, B, R] : C;
}
Je(je.SELECT, Yd);
Je(je.IMAGE, Ug);
Je(je.NUMBER, jd);
Je(je.COLOR, $g);
Je(je.STRING, tp);
Je(je.BOOLEAN, cp);
Je(je.INTERVAL, Zg);
Je(je.VECTOR3D, Eg);
Je(je.VECTOR2D, Ig);
const zm = ({
  settings: e,
  onChange: t,
  onRestart: n
}) => {
  ya("⚙️ Emitter Settings", {
    Restart: ga(() => n()),
    Export: ga(() => {
      const d = JSON.stringify(f.current);
      console.log("📋 Values saved to clipboard: ", d), navigator.clipboard.writeText(d);
    })
  });
  const [{ ...r }, o] = ya(() => ({
    "🪄 Emitter": Ht({
      duration: 4,
      delay: 0,
      nbParticles: 2e3,
      spawnMode: {
        options: ["time", "burst"],
        value: "time"
      },
      loop: !1,
      startPositionMin: {
        value: [-1, -1, -1],
        min: -10,
        max: 10,
        step: 0.1,
        label: "startPositionMin"
      },
      startPositionMax: {
        value: [1, 1, 1],
        min: -10,
        max: 10,
        step: 0.1,
        label: "startPositionMax"
      },
      startRotationMin: {
        value: [0, 0, 0],
        min: -Math.PI * 2,
        max: Math.PI * 2,
        step: 0.1,
        label: "startRotationMin"
      },
      startRotationMax: {
        value: [0, 0, 0],
        min: -Math.PI * 2,
        max: Math.PI * 2,
        step: 0.1,
        label: "startRotationMax"
      }
    }),
    "✨ Particles": Ht({
      particlesLifetime: {
        value: [0.1, 1],
        min: 0,
        max: 10,
        step: 0.1,
        label: "lifetime"
      }
    }),
    "🌪 Forces": Ht({
      speed: {
        value: [5, 20],
        min: -100,
        max: 100
      },
      directionMin: {
        value: [-1, -1, -1],
        min: -1,
        max: 1,
        step: 0.1
      },
      directionMax: {
        value: [1, 1, 1],
        min: -1,
        max: 1,
        step: 0.1
      },
      rotationSpeedMin: {
        value: [0, 0, 0],
        min: 0,
        max: 10,
        step: 0.1
      },
      rotationSpeedMax: {
        value: [0, 0, 0],
        min: 0,
        max: 10,
        step: 0.1
      }
    }),
    "🎨 Appearance": Ht({
      nbColors: {
        options: [1, 2, 3]
      },
      colorStart: "#ffffff",
      colorEnd: "#ffffff",
      colorStart2: {
        value: "#ff0000",
        render: (d) => d("🎨 Appearance.nbColors") > 1
      },
      colorEnd2: {
        value: "#ffffff",
        render: (d) => d("🎨 Appearance.nbColors") > 1
      },
      colorStart3: {
        value: "#ff0000",
        render: (d) => d("🎨 Appearance.nbColors") > 2
      },
      colorEnd3: {
        value: "#ff0000",
        render: (d) => d("🎨 Appearance.nbColors") > 2
      },
      size: {
        value: [0.01, 1],
        min: 0,
        max: 5,
        step: 0.01,
        label: "size"
      }
    })
  })), {
    nbColors: i,
    colorStart2: a,
    colorEnd2: s,
    colorStart3: c,
    colorEnd3: l,
    ...u
  } = {
    ...r,
    colorStart: [r.colorStart],
    colorEnd: [r.colorEnd]
  };
  r.nbColors > 1 && u.colorStart.push(r.colorStart2), r.nbColors > 1 && u.colorEnd.push(r.colorEnd2), r.nbColors > 2 && u.colorStart.push(r.colorStart3), r.nbColors > 2 && u.colorEnd.push(r.colorEnd3);
  const f = _(u);
  return f.current = u, Y(() => {
    if (e) {
      const d = {
        ...e
      };
      for (let p = 0; p < 2; p++)
        e.colorStart && e.colorStart.length > p && (d[p === 0 ? "colorStart" : `colorStart${p + 1}`] = e.colorStart[p], d.nbColors = p + 1), e.colorEnd && e.colorEnd.length > p && (d[p === 0 ? "colorEnd" : `colorEnd${p + 1}`] = e.colorEnd[p]);
      o({
        ...d
      });
    }
  }, [e]), t(u), null;
}, wa = (e) => {
  let t;
  const n = /* @__PURE__ */ new Set(), r = (l, u) => {
    const f = typeof l == "function" ? l(t) : l;
    if (!Object.is(f, t)) {
      const d = t;
      t = u ?? (typeof f != "object" || f === null) ? f : Object.assign({}, t, f), n.forEach((p) => p(t, d));
    }
  }, o = () => t, s = { setState: r, getState: o, getInitialState: () => c, subscribe: (l) => (n.add(l), () => n.delete(l)) }, c = t = e(r, o, s);
  return s;
}, Nm = (e) => e ? wa(e) : wa, Fm = (e) => e;
function Bm(e, t = Fm) {
  const n = g.useSyncExternalStore(
    e.subscribe,
    () => t(e.getState()),
    () => t(e.getInitialState())
  );
  return g.useDebugValue(n), n;
}
const $a = (e) => {
  const t = Nm(e), n = (r) => Bm(t, r);
  return Object.assign(n, t), n;
}, Wm = (e) => e ? $a(e) : $a, no = Wm((e, t) => ({
  emitters: {},
  shouldEmit: !0,
  registerEmitter: (n, r) => {
    if (t().emitters[n]) {
      console.warn(`Emitter ${n} already exists`);
      return;
    }
    e((o) => (o.emitters[n] = r, o));
  },
  unregisterEmitter: (n) => {
    e((r) => (delete r.emitters[n], r));
  },
  emit: (n, r, o) => {
    const i = t().emitters[n];
    if (!i) {
      console.warn(`Emitter ${n} not found`);
      return;
    }
    i(r, o);
  }
})), rt = new Rt(), ot = new Aa(), xa = new io(), it = new io(), Ea = new Rt(), r0 = be(
  ({
    debug: e,
    emitter: t,
    settings: n = {},
    localDirection: r,
    autoStart: o = !0,
    ...i
  }, a) => {
    const [
      {
        duration: s = 1,
        nbParticles: c = 1e3,
        spawnMode: l = "time",
        // time, burst
        loop: u = !1,
        delay: f = 0,
        colorStart: d = ["white", "skyblue"],
        colorEnd: p = [],
        particlesLifetime: m = [0.1, 1],
        speed: h = [5, 20],
        size: v = [0.1, 1],
        startPositionMin: b = [-1, -1, -1],
        startPositionMax: y = [1, 1, 1],
        startRotationMin: w = [0, 0, 0],
        startRotationMax: x = [0, 0, 0],
        rotationSpeedMin: $ = [0, 0, 0],
        rotationSpeedMax: E = [0, 0, 0],
        directionMin: O = [0, 0, 0],
        directionMax: C = [0, 0, 0]
      },
      B
    ] = oe(n), R = _(0), T = _(0), A = _(0), M = _(null), Z = no((P) => P.emit), G = _(o), J = W(() => {
      G.current = !1;
    }, []), ie = W((P = !1) => {
      P && (R.current = 0, T.current = 0), G.current = !0;
    }, []), ce = W(
      (P, H = !1) => {
        l !== "burst" && console.error(
          "This function is meant to be used with burst spawn mode only."
        );
        const U = c - R.current;
        H && (R.current = 0, T.current = 0), P && (M.current.position.x = P.x, M.current.position.y = P.y, M.current.position.z = P.z), M.current.updateWorldMatrix(!0, !0), M.current.matrixWorld.decompose(rt, ot, Ea), xa.setFromQuaternion(ot), it.setFromQuaternion(ot), Z(t, U, () => {
          const q = te(v[0], v[1]), L = d[fn(0, d.length - 1)];
          return {
            position: [
              rt.x + te(b[0], y[0]),
              rt.y + te(b[1], y[1]),
              rt.z + te(b[2], y[2])
            ],
            direction: (() => {
              const j = new Rt(
                te(O[0], C[0]),
                te(O[1], C[1]),
                te(O[2], C[2])
              );
              return r && j.applyQuaternion(ot), [j.x, j.y, j.z];
            })(),
            scale: [q, q, q],
            rotation: [
              it.x + te(w[0], x[0]),
              it.y + te(w[1], x[1]),
              it.z + te(w[2], x[2])
            ],
            rotationSpeed: [
              te($[0], E[0]),
              te($[1], E[1]),
              te($[2], E[2])
            ],
            lifetime: [
              A.current,
              te(m[0], m[1])
            ],
            colorStart: L,
            colorEnd: p != null && p.length ? p[fn(0, p.length - 1)] : L,
            speed: [te(h[0], h[1])]
          };
        });
      },
      []
    );
    Nn(a, () => ({
      ...M.current,
      stopEmitting: J,
      startEmitting: ie,
      emitAtPos: ce
    })), Ra(({ clock: P }, H) => {
      const U = P.getElapsedTime();
      A.current = U;
      const N = G.current;
      if (R.current < c || u) {
        if (!M || !N)
          return;
        const L = (l === "burst" ? c : Math.max(
          0,
          Math.floor(
            (T.current - f) / s * c
          )
        )) - R.current;
        L > 0 && T.current >= f && (Z(t, L, () => {
          M.current.updateWorldMatrix(!0, !0), M.current.matrixWorld.decompose(rt, ot, Ea), xa.setFromQuaternion(ot), it.setFromQuaternion(ot);
          const V = te(v[0], v[1]), Q = d[fn(0, d.length - 1)];
          return {
            position: [
              rt.x + te(b[0], y[0]),
              rt.y + te(b[1], y[1]),
              rt.z + te(b[2], y[2])
            ],
            direction: (() => {
              const X = new Rt(
                te(O[0], C[0]),
                te(O[1], C[1]),
                te(O[2], C[2])
              );
              return r && X.applyQuaternion(ot), [X.x, X.y, X.z];
            })(),
            scale: [V, V, V],
            rotation: [
              it.x + te(w[0], x[0]),
              it.y + te(w[1], x[1]),
              it.z + te(w[2], x[2])
            ],
            rotationSpeed: [
              te($[0], E[0]),
              te($[1], E[1]),
              te($[2], E[2])
            ],
            lifetime: [
              U,
              te(m[0], m[1])
            ],
            colorStart: Q,
            colorEnd: p != null && p.length ? p[fn(0, p.length - 1)] : Q,
            speed: [te(h[0], h[1])]
          };
        }), R.current += L);
      }
      T.current += H;
    });
    const he = W(() => {
      R.current = 0, T.current = 0;
    }, []), S = ge(
      () => e ? /* @__PURE__ */ Fe(
        zm,
        {
          settings: n,
          onChange: B,
          onRestart: he
        }
      ) : null,
      [e]
    );
    return /* @__PURE__ */ _a(Ta, { children: [
      S,
      /* @__PURE__ */ Fe("object3D", { ...i, ref: M })
    ] });
  }
);
function Um(e, t, n, r) {
  var o;
  return o = class extends un.ShaderMaterial {
    constructor(i) {
      super({
        vertexShader: t,
        fragmentShader: n,
        ...i
      });
      for (const a in e)
        this.uniforms[a] = new un.Uniform(e[a]), Object.defineProperty(this, a, {
          get() {
            return this.uniforms[a].value;
          },
          set(s) {
            this.uniforms[a].value = s;
          }
        });
      this.uniforms = un.UniformsUtils.clone(this.uniforms);
    }
  }, o.key = un.MathUtils.generateUUID(), o;
}
const Vm = `
#define PI 3.1415926535897932384626433832795
// Linear
float easeLinear(float t) 
{

    return t;
    
}

// --------- Power1 ---------
float easeInPower1(float t) {
    return t;
}

float easeOutPower1(float t) {
    return 1.0 - (1.0 - t);
}

float easeInOutPower1(float t) {
    return t;
}

// --------- Power2 ---------
float easeInPower2(float t) {
    return t * t;
}

float easeOutPower2(float t) {
    return 1.0 - pow(1.0 - t, 2.0);
}

float easeInOutPower2(float t) {
    return t < 0.5
        ? 2.0 * t * t
        : 1.0 - pow(-2.0 * t + 2.0, 2.0) / 2.0;
}

// --------- Power3 ---------
float easeInPower3(float t) {
    return t * t * t;
}

float easeOutPower3(float t) {
    return 1.0 - pow(1.0 - t, 3.0);
}

float easeInOutPower3(float t) {
    return t < 0.5
        ? 4.0 * t * t * t
        : 1.0 - pow(-2.0 * t + 2.0, 3.0) / 2.0;
}

// --------- Power4 ---------
float easeInPower4(float t) {
    return t * t * t * t;
}

float easeOutPower4(float t) {
    return 1.0 - pow(1.0 - t, 4.0);
}

float easeInOutPower4(float t) {
    return t < 0.5
        ? 8.0 * t * t * t * t
        : 1.0 - pow(-2.0 * t + 2.0, 4.0) / 2.0;
}

// Quad
float easeInQuad(float t) {
    return t * t;
}

float easeOutQuad(float t) {
    return t * (2.0 - t);
}

float easeInOutQuad(float t) {
    return t < 0.5 
        ? 2.0 * t * t 
        : -1.0 + (4.0 - 2.0 * t) * t;
}

// Cubic
float easeInCubic(float t) {
    return t * t * t;
}

float easeOutCubic(float t) {
    float t1 = t - 1.0;
    return 1.0 + t1 * t1 * t1;
}

float easeInOutCubic(float t) {
    return t < 0.5
        ? 4.0 * t * t * t
        : (t - 1.0) * (2.0 * t - 2.0) * (2.0 * t - 2.0) + 1.0;
}

// Quart
float easeInQuart(float t) {
    return t * t * t * t;
}

float easeOutQuart(float t) {
    float t1 = t - 1.0;
    return 1.0 - t1 * t1 * t1 * t1;
}

float easeInOutQuart(float t) {
    float t1 = t - 1.0;
    return t < 0.5
        ? 8.0 * t * t * t * t
        : 1.0 - 8.0 * t1 * t1 * t1 * t1;
}

// Quint
float easeInQuint(float t) {
    return t * t * t * t * t;
}

float easeOutQuint(float t) {
    float t1 = t - 1.0;
    return 1.0 + t1 * t1 * t1 * t1 * t1;
}

float easeInOutQuint(float t) {
    float t1 = t - 1.0;
    return t < 0.5
        ? 16.0 * t * t * t * t * t
        : 1.0 + 16.0 * t1 * t1 * t1 * t1 * t1;
}

// Sine
float easeInSine(float t) {
    return -1.0 * cos(t * PI * 0.5) + 1.0;
}

float easeOutSine(float t) {
    return sin(t * PI * 0.5);
}

float easeInOutSine(float t) {
    return -0.5 * (cos(PI * t) - 1.0);
}

// Expo
float easeInExpo(float t) {
    return t == 0.0 ? 0.0 : pow(2.0, 10.0 * (t - 1.0));
}

float easeOutExpo(float t) {
    return t == 1.0 ? 1.0 : 1.0 - pow(2.0, -10.0 * t);
}

float easeInOutExpo(float t) {
    if (t == 0.0 || t == 1.0) return t;
    
    return t < 0.5
        ? 0.5 * pow(2.0, (20.0 * t) - 10.0)
        : 0.5 * (-pow(2.0, (-20.0 * t) + 10.0) + 2.0);
}

// Circ
float easeInCirc(float t) {
    return -1.0 * (sqrt(1.0 - t * t) - 1.0);
}

float easeOutCirc(float t) {
    float t1 = t - 1.0;
    return sqrt(1.0 - t1 * t1);
}

float easeInOutCirc(float t) {
    float t1 = 2.0 * t;
    float t2 = t1 - 2.0;
    return t < 0.5
        ? -0.5 * (sqrt(1.0 - t1 * t1) - 1.0)
        : 0.5 * (sqrt(1.0 - t2 * t2) + 1.0);
}

// Elastic
float easeInElastic(float t) {
    if (t == 0.0 || t == 1.0) return t;
    return -pow(2.0, 10.0 * (t - 1.0)) * sin((t - 1.075) * (2.0 * PI) / 0.3);
}

float easeOutElastic(float t) {
    if (t == 0.0 || t == 1.0) return t;
    return pow(2.0, -10.0 * t) * sin((t - 0.075) * (2.0 * PI) / 0.3) + 1.0;
}

float easeInOutElastic(float t) {
    if (t < 0.5) {
        return -0.5 * pow(2.0, 20.0 * t - 10.0) * 
               sin((20.0 * t - 11.125) * (2.0 * PI) / 4.5);
    }
    return pow(2.0, -20.0 * t + 10.0) * 
           sin((20.0 * t - 11.125) * (2.0 * PI) / 4.5) * 0.5 + 1.0;
}

// Back
float easeInBack(float t) {
    float s = 1.70158;
    return t * t * ((s + 1.0) * t - s);
}

float easeOutBack(float t) {
    float s = 1.70158;
    float t1 = t - 1.0;
    return t1 * t1 * ((s + 1.0) * t1 + s) + 1.0;
}

float easeInOutBack(float t) {
    float s = 1.70158 * 1.525;
    t *= 2.0;
    if (t < 1.0) {
        return 0.5 * (t * t * ((s + 1.0) * t - s));
    }
    t -= 2.0;
    return 0.5 * (t * t * ((s + 1.0) * t + s) + 2.0);
}

// Bounce
float easeOutBounce(float t) {
    if (t < 1.0 / 2.75) {
        return 7.5625 * t * t;
    } else if (t < 2.0 / 2.75) {
        t -= 1.5 / 2.75;
        return 7.5625 * t * t + 0.75;
    } else if (t < 2.5 / 2.75) {
        t -= 2.25 / 2.75;
        return 7.5625 * t * t + 0.9375;
    } else {
        t -= 2.625 / 2.75;
        return 7.5625 * t * t + 0.984375;
    }
}

float easeInBounce(float t) {
    return 1.0 - easeOutBounce(1.0 - t);
}

float easeInOutBounce(float t) {
    return t < 0.5
        ? (1.0 - easeOutBounce(1.0 - 2.0 * t)) * 0.5
        : (1.0 + easeOutBounce(2.0 * t - 1.0)) * 0.5;
}

float applyEasing(float t, int easingId) {
    if (easingId == 0) return easeLinear(t);
    else if (easingId == 1) return easeInPower1(t);
    else if (easingId == 2) return easeOutPower1(t);
    else if (easingId == 3) return easeInOutPower1(t);
    else if (easingId == 4) return easeInPower2(t);
    else if (easingId == 5) return easeOutPower2(t);
    else if (easingId == 6) return easeInOutPower2(t);
    else if (easingId == 7) return easeInPower3(t);
    else if (easingId == 8) return easeOutPower3(t);
    else if (easingId == 9) return easeInOutPower3(t);
    else if (easingId == 10) return easeInPower4(t);
    else if (easingId == 11) return easeOutPower4(t);
    else if (easingId == 12) return easeInOutPower4(t);
    else if (easingId == 13) return easeInQuad(t);
    else if (easingId == 14) return easeOutQuad(t);
    else if (easingId == 15) return easeInOutQuad(t);
    else if (easingId == 16) return easeInCubic(t);
    else if (easingId == 17) return easeOutCubic(t);
    else if (easingId == 18) return easeInOutCubic(t);
    else if (easingId == 19) return easeInQuart(t);
    else if (easingId == 20) return easeOutQuart(t);
    else if (easingId == 21) return easeInOutQuart(t);
    else if (easingId == 22) return easeInQuint(t);
    else if (easingId == 23) return easeOutQuint(t);
    else if (easingId == 24) return easeInOutQuint(t);
    else if (easingId == 25) return easeInSine(t);
    else if (easingId == 26) return easeOutSine(t);
    else if (easingId == 27) return easeInOutSine(t);
    else if (easingId == 28) return easeInExpo(t);
    else if (easingId == 29) return easeOutExpo(t);
    else if (easingId == 30) return easeInOutExpo(t);
    else if (easingId == 31) return easeInCirc(t);
    else if (easingId == 32) return easeOutCirc(t);
    else if (easingId == 33) return easeInOutCirc(t);
    else if (easingId == 34) return easeInElastic(t);
    else if (easingId == 35) return easeOutElastic(t);
    else if (easingId == 36) return easeInOutElastic(t);
    else if (easingId == 37) return easeInBack(t);
    else if (easingId == 38) return easeOutBack(t);
    else if (easingId == 39) return easeInOutBack(t);
    else if (easingId == 40) return easeInBounce(t);
    else if (easingId == 41) return easeOutBounce(t);
    else if (easingId == 42) return easeInOutBounce(t);
    // fallback
    return t;
}

`, Sa = new Rt(), wn = new io(), Oa = new Aa(), Pa = new Rt(1, 1, 1), Ca = new Ec(), at = new Sc(), o0 = ({
  name: e,
  settings: t = {},
  alphaMap: n,
  geometry: r
}) => {
  const {
    nbParticles: o = 1e3,
    intensity: i = 1,
    renderMode: a = Ma.Mesh,
    stretchScale: s = 1,
    fadeSize: c = [0.1, 0.9],
    fadeAlpha: l = [0, 1],
    gravity: u = [0, 0, 0],
    frustumCulled: f = !0,
    appearance: d = Da.Square,
    easeFunction: p = "easeLinear",
    blendingMode: m = Oc
  } = t, h = _(null), v = ge(() => new Pc(0.5, 0.5), []), b = Rc.indexOf(p), y = () => {
    if (!$.current || !h.current)
      return;
    [
      h.current.instanceMatrix,
      h.current.geometry.getAttribute("instanceColor"),
      h.current.geometry.getAttribute("instanceColorEnd"),
      h.current.geometry.getAttribute("instanceDirection"),
      h.current.geometry.getAttribute("instanceLifetime"),
      h.current.geometry.getAttribute("instanceSpeed"),
      h.current.geometry.getAttribute("instanceRotationSpeed")
    ].forEach((T) => {
      const A = T;
      A.clearUpdateRanges(), x.current > w.current ? (A.addUpdateRange(0, w.current * A.itemSize), A.addUpdateRange(
        x.current * A.itemSize,
        o * A.itemSize - x.current * A.itemSize
      )) : A.addUpdateRange(
        x.current * A.itemSize,
        w.current * A.itemSize - x.current * A.itemSize
      ), A.needsUpdate = !0;
    }), x.current = w.current, $.current = !1;
  }, w = _(0), x = _(0), $ = _(!1), E = (R, T) => {
    const A = h.current.geometry.getAttribute(
      "instanceColor"
    ), M = h.current.geometry.getAttribute(
      "instanceColorEnd"
    ), Z = h.current.geometry.getAttribute(
      "instanceDirection"
    ), G = h.current.geometry.getAttribute(
      "instanceLifetime"
    ), J = h.current.geometry.getAttribute(
      "instanceSpeed"
    ), ie = h.current.geometry.getAttribute(
      "instanceRotationSpeed"
    );
    for (let ce = 0; ce < R; ce++) {
      w.current >= o && (w.current = 0);
      const {
        scale: he,
        rotation: S,
        rotationSpeed: P,
        position: H,
        direction: U,
        lifetime: N,
        colorStart: q,
        colorEnd: L,
        speed: j
      } = T();
      Sa.set(...H), wn.set(...S), (a === "billboard" || a === "stretchBillboard") && (wn.x = 0, wn.y = 0), Oa.setFromEuler(wn), Pa.set(...he), Ca.compose(Sa, Oa, Pa), h.current.setMatrixAt(w.current, Ca), at.set(q), A.set(
        [at.r, at.g, at.b],
        w.current * 3
      ), at.set(L), M.set(
        [at.r, at.g, at.b],
        w.current * 3
      ), Z.set(U, w.current * 3), G.set(N, w.current * 2), J.set(j, w.current), ie.set(P, w.current * 3), w.current++, w.current = w.current % o;
    }
    h.current.instanceMatrix.needsUpdate = !0, A.needsUpdate = !0, M.needsUpdate = !0, Z.needsUpdate = !0, G.needsUpdate = !0, J.needsUpdate = !0, ie.needsUpdate = !0, $.current = !0;
  }, [O] = oe({
    instanceColor: new Float32Array(o * 3),
    instanceColorEnd: new Float32Array(o * 3),
    instanceDirection: new Float32Array(o * 3),
    instanceLifetime: new Float32Array(o * 2),
    instanceSpeed: new Float32Array(o * 1),
    instanceRotationSpeed: new Float32Array(o * 3)
  });
  Ra(({ clock: R }) => {
    if (!h.current)
      return;
    const T = h.current.material;
    T.uniforms.uTime.value = R.elapsedTime, T.uniforms.uIntensity.value = i, T.uniforms.uStretchScale.value = s, T.uniforms.uFadeSize.value = c, T.uniforms.uFadeAlpha.value = l, T.uniforms.uGravity.value = u, T.uniforms.uAppearanceMode.value = d, T.uniforms.uEasingFunction.value = b;
  });
  const C = no((R) => R.registerEmitter), B = no((R) => R.unregisterEmitter);
  return Y(() => (C(e, E), () => {
    B(e);
  }), []), /* @__PURE__ */ Fe(Ta, { children: /* @__PURE__ */ _a(
    "instancedMesh",
    {
      args: [
        r ? void 0 : v,
        void 0,
        o
      ],
      ref: h,
      frustumCulled: f,
      onBeforeRender: y,
      children: [
        r,
        /* @__PURE__ */ Fe(
          "particlesMaterial",
          {
            blending: m,
            defines: {
              STRETCH_BILLBOARD_MODE: a === "stretchBillboard",
              BILLBOARD_MODE: a === "billboard",
              MESH_MODE: a === "mesh"
            },
            transparent: !0,
            alphaMap: n,
            depthWrite: !1
          }
        ),
        /* @__PURE__ */ Fe(
          "instancedBufferAttribute",
          {
            attach: "geometry-attributes-instanceColor",
            args: [O.instanceColor, 3],
            itemSize: 3,
            count: o,
            usage: Et
          }
        ),
        /* @__PURE__ */ Fe(
          "instancedBufferAttribute",
          {
            attach: "geometry-attributes-instanceColorEnd",
            args: [O.instanceColorEnd, 3],
            itemSize: 3,
            count: o,
            usage: Et
          }
        ),
        /* @__PURE__ */ Fe(
          "instancedBufferAttribute",
          {
            attach: "geometry-attributes-instanceDirection",
            args: [O.instanceDirection, 3],
            itemSize: 3,
            count: o,
            usage: Et
          }
        ),
        /* @__PURE__ */ Fe(
          "instancedBufferAttribute",
          {
            attach: "geometry-attributes-instanceLifetime",
            args: [O.instanceLifetime, 2],
            itemSize: 2,
            count: o,
            usage: Et
          }
        ),
        /* @__PURE__ */ Fe(
          "instancedBufferAttribute",
          {
            attach: "geometry-attributes-instanceSpeed",
            args: [O.instanceSpeed, 1],
            itemSize: 1,
            count: o,
            usage: Et
          }
        ),
        /* @__PURE__ */ Fe(
          "instancedBufferAttribute",
          {
            attach: "geometry-attributes-instanceRotationSpeed",
            args: [O.instanceRotationSpeed, 3],
            itemSize: 3,
            count: o,
            usage: Et
          }
        )
      ]
    }
  ) });
}, Hm = Um(
  {
    uTime: 0,
    uIntensity: 1,
    uStretchScale: 1,
    uFadeSize: [0.1, 0.9],
    uFadeAlpha: [0, 1],
    uGravity: [0, 0, 0],
    uAppearanceMode: 0,
    alphaMap: null,
    uEasingFunction: 0
  },
  /* glsl */
  `
${Vm}
mat4 rotationX(float angle) {
  float s = sin(angle);
  float c = cos(angle);
  return mat4(
      1,  0,  0,  0,
      0,  c, -s,  0,
      0,  s,  c,  0,
      0,  0,  0,  1
  );
}

mat4 rotationY(float angle) {
  float s = sin(angle);
  float c = cos(angle);
  return mat4(
        c,  0,  s,  0,
        0,  1,  0,  0,
      -s,  0,  c,  0,
        0,  0,  0,  1
  );
}

mat4 rotationZ(float angle) {
  float s = sin(angle);
  float c = cos(angle);
  return mat4(
      c, -s,  0,  0,
      s,  c,  0,  0,
      0,  0,  1,  0,
      0,  0,  0,  1
  );
}


vec3 billboard(vec2 v, mat4 view) {
  vec3 up = vec3(view[0][1], view[1][1], view[2][1]);
  vec3 right = vec3(view[0][0], view[1][0], view[2][0]);
  vec3 p = right * v.x + up * v.y;
  return p;
}

uniform float uTime;
uniform vec2 uFadeSize;
uniform vec3 uGravity;
uniform float uStretchScale;
uniform int uEasingFunction;

varying vec2 vUv;
varying vec3 vColor;
varying vec3 vColorEnd;
varying float vProgress;

attribute float instanceSpeed;
attribute vec3 instanceRotationSpeed;
attribute vec3 instanceDirection;
attribute vec3 instanceColor;
attribute vec3 instanceColorEnd;
attribute vec2 instanceLifetime; // x: startTime, y: duration

void main() {
  float startTime = instanceLifetime.x;
  float duration = instanceLifetime.y;
  float age = uTime - startTime;

  // Adjust age based on instanceSpeed direction
  age = instanceSpeed < 0.0 ? duration - (uTime - startTime) : uTime - startTime;
  float progress = clamp(age / duration, 0.0, 1.0);
  vProgress = applyEasing(progress, uEasingFunction);

  if (vProgress < 0.0 || vProgress > 1.0) {
    gl_Position = vec4(vec3(9999.0), 1.0);
    return;
  }

  float scale = smoothstep(0.0, uFadeSize.x, vProgress) * smoothstep(1.01, uFadeSize.y, vProgress);

  vec3 normalizedDirection = length(instanceDirection) > 0.0 ? normalize(instanceDirection) : vec3(0.0);
  vec3 gravityForce = 0.5 * uGravity * (age * age);
  float easedAge = vProgress * duration;
  vec3 offset = normalizedDirection * easedAge * instanceSpeed;
  offset += gravityForce;

  vec3 rotationSpeed = instanceRotationSpeed * age;
  mat4 rotX = rotationX(rotationSpeed.x);
  mat4 rotY = rotationY(rotationSpeed.y);
  mat4 rotZ = rotationZ(rotationSpeed.z);
  mat4 rotationMatrix = rotZ * rotY * rotX;

  vec4 mvPosition;
  #ifdef MESH_MODE
  /* Mesh Mode */
    vec4 startPosition = modelMatrix * instanceMatrix * rotationMatrix * vec4(position * scale, 1.0);
    
    vec3 instancePosition = startPosition.xyz;

    vec3 finalPosition = instancePosition + offset;
    mvPosition = modelViewMatrix * vec4(finalPosition, 1.0);
  #endif
  #ifdef BILLBOARD_MODE
  /* Billboard Mode */
    // Instance position (translation from instanceMatrix)
    vec3 instancePosition = (instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz + offset;
    
    // Compute billboard's local coordinate system
    // Forward vector (billboard's local Z-axis, points toward camera)
    vec3 localZ = normalize(cameraPosition - instancePosition);
    // World up vector (assuming Y-up world)
    vec3 worldUp = vec3(0.0, 1.0, 0.0);
    // Local X-axis (right vector)
    vec3 localX = normalize(cross(worldUp, localZ));
    // Local Y-axis (up vector)
    vec3 localY = cross(localZ, localX);

    // Construct billboard's orientation matrix (converts from local to world space)
    mat3 billboardMatrix = mat3(localX, localY, localZ);

    float scaleX = length(instanceMatrix[0].xyz);
    float scaleY = length(instanceMatrix[1].xyz);
    float scaleZ = length(instanceMatrix[2].xyz);
    vec3 instanceScale = vec3(scaleX, scaleY, scaleZ);

    // Combine billboard orientation with local rotation
    mat3 finalMatrix = billboardMatrix * mat3(rotationMatrix);

    // Extract final right and up vectors, apply scale
    vec3 finalRight = finalMatrix[0] * instanceScale * scale;
    vec3 finalUp = finalMatrix[1] * instanceScale * scale;
    // Compute vertex position in world space
    vec3 vertexWorldPos = instancePosition +
                          finalRight * position.x +
                          finalUp * position.y;
    mvPosition = viewMatrix * vec4(vertexWorldPos, 1.0);
  #endif
    #ifdef STRETCH_BILLBOARD_MODE
  vec3 particleWorldPos = (instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz + offset;

  vec3 worldVelocity = normalizedDirection * instanceSpeed + uGravity * age;
  float currentSpeed = length(worldVelocity);

  if (currentSpeed < 0.001) {
    vec3 instancePositionBillboard = particleWorldPos;

    // Use camera's Up vector in World for a more robust billboard
    vec3 camUpWorld = normalize(vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]));
    vec3 eyeVecBillboard = normalize(cameraPosition - instancePositionBillboard);

    vec3 bLocalX = normalize(cross(camUpWorld, eyeVecBillboard));

    if (length(bLocalX) < 0.001) {

      bLocalX = normalize(vec3(viewMatrix[0][0], viewMatrix[1][0], viewMatrix[2][0]));
    }
    vec3 bLocalY = normalize(cross(eyeVecBillboard, bLocalX));
    mat3 billboardBasis = mat3(bLocalX, bLocalY, eyeVecBillboard);

    float instScaleX = length(instanceMatrix[0].xyz);
    float instScaleY = length(instanceMatrix[1].xyz);

    mat3 rotatedBillboardBasis = billboardBasis * mat3(rotationMatrix);

    vec3 finalRight = rotatedBillboardBasis[0] * instScaleX * scale;
    vec3 finalUp    = rotatedBillboardBasis[1] * instScaleY * scale;
    vec3 vertexWorldPos = instancePositionBillboard + finalRight * position.x + finalUp * position.y;
    mvPosition = viewMatrix * vec4(vertexWorldPos, 1.0);

  } else { 
    vec3 eyeVector = normalize(cameraPosition - particleWorldPos);

    vec3 tangent = normalize(worldVelocity); 

    vec3 projectedTangent = tangent - dot(tangent, eyeVector) * eyeVector;

    vec3 particlePlaneUp;
    vec3 particlePlaneRight; 

    if (length(projectedTangent) < 0.001) {

      particlePlaneUp = tangent;

      vec3 camUpWorld = normalize(vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]));
      particlePlaneRight = normalize(cross(particlePlaneUp, camUpWorld));

      if (length(particlePlaneRight) < 0.001) {
        vec3 camRightWorld = normalize(vec3(viewMatrix[0][0], viewMatrix[1][0], viewMatrix[2][0]));
        particlePlaneRight = normalize(cross(particlePlaneUp, camRightWorld));
      }
    } else {
      particlePlaneUp = normalize(projectedTangent);
      particlePlaneRight = normalize(cross(particlePlaneUp, eyeVector));
    }

    float baseWidth  = length(instanceMatrix[0].xyz);
    float baseLength = length(instanceMatrix[1].xyz);

    float wid = baseWidth * scale;
    float len = baseLength * scale * (1.0 + currentSpeed * uStretchScale);

    float zAngle = instanceRotationSpeed.z * age;
    mat2 spinMatrix = mat2(cos(zAngle), -sin(zAngle), sin(zAngle), cos(zAngle));
    vec2 localSpunPos = spinMatrix * position.xy;

    vec3 worldSpaceVertexOffset = particlePlaneRight * localSpunPos.x * wid +
                                  particlePlaneUp    * localSpunPos.y * len;

    vec3 finalVertexPos = particleWorldPos + worldSpaceVertexOffset;
    mvPosition = viewMatrix * vec4(finalVertexPos, 1.0);
  }
#endif

  gl_Position = projectionMatrix * mvPosition;

  vUv = uv;
  vColor = instanceColor;
  vColorEnd = instanceColorEnd;
}
`,
  /* glsl */
  `
uniform float uIntensity;
uniform vec2 uFadeAlpha;
uniform sampler2D alphaMap;
uniform int uAppearanceMode;

varying vec3 vColor;
varying vec3 vColorEnd;
varying float vProgress;
varying vec2 vUv;


void main() {
  if (vProgress < 0.0 || vProgress > 1.0) {
    discard;
  }
  vec3 finalColor = mix(vColor, vColorEnd, vProgress);
  finalColor *= uIntensity;

  float alpha = smoothstep(0.0, uFadeAlpha.x, vProgress) * smoothstep(1.01, uFadeAlpha.y, vProgress);

  #ifdef USE_ALPHAMAP
    vec2 uv = vUv;
    vec4 tex = texture2D(alphaMap, uv);
    gl_FragColor = vec4(finalColor, tex.a * alpha);
  #else
    if(uAppearanceMode == 1){ // Circular
      vec2 center = vec2(0.5);
      float dist = distance(vUv, center);
      
      if(dist > 0.5){
        discard; // creating circular shape 
      }
    }
    gl_FragColor = vec4(finalColor, alpha);
  #endif
}`
);
$c({ ParticlesMaterial: Hm });
export {
  Da as AppearanceMode,
  Ma as RenderMode,
  r0 as VFXEmitter,
  o0 as VFXParticles
};
